{"ast":null,"code":"/*\n Highcharts JS v7.1.2 (2019-06-03)\n\n (c) 2009-2018 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n(function (Q, I) {\n  \"object\" === typeof module && module.exports ? (I[\"default\"] = I, module.exports = Q.document ? I(Q) : I) : \"function\" === typeof define && define.amd ? define(\"highcharts/highstock\", function () {\n    return I(Q);\n  }) : (Q.Highcharts && Q.Highcharts.error(16, !0), Q.Highcharts = I(Q));\n})(\"undefined\" !== typeof window ? window : this, function (Q) {\n  function I(a, C, A, E) {\n    a.hasOwnProperty(C) || (a[C] = E.apply(null, A));\n  }\n\n  var H = {};\n  I(H, \"parts/Globals.js\", [], function () {\n    var a = \"undefined\" === typeof Q ? \"undefined\" !== typeof window ? window : {} : Q,\n        C = a.document,\n        A = a.navigator && a.navigator.userAgent || \"\",\n        E = C && C.createElementNS && !!C.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\").createSVGRect,\n        m = /(edge|msie|trident)/i.test(A) && !a.opera,\n        g = -1 !== A.indexOf(\"Firefox\"),\n        v = -1 !== A.indexOf(\"Chrome\"),\n        x = g && 4 > parseInt(A.split(\"Firefox/\")[1], 10);\n    return {\n      product: \"Highcharts\",\n      version: \"7.1.2\",\n      deg2rad: 2 * Math.PI / 360,\n      doc: C,\n      hasBidiBug: x,\n      hasTouch: C && \"undefined\" !== typeof C.documentElement.ontouchstart,\n      isMS: m,\n      isWebKit: -1 !== A.indexOf(\"AppleWebKit\"),\n      isFirefox: g,\n      isChrome: v,\n      isSafari: !v && -1 !== A.indexOf(\"Safari\"),\n      isTouchDevice: /(Mobile|Android|Windows Phone)/.test(A),\n      SVG_NS: \"http://www.w3.org/2000/svg\",\n      chartCount: 0,\n      seriesTypes: {},\n      symbolSizes: {},\n      svg: E,\n      win: a,\n      marginNames: [\"plotTop\", \"marginRight\", \"marginBottom\", \"plotLeft\"],\n      noop: function () {},\n      charts: [],\n      dateFormats: {}\n    };\n  });\n  I(H, \"parts/Utilities.js\", [H[\"parts/Globals.js\"]], function (a) {\n    a.timers = [];\n    var C = a.charts,\n        A = a.doc,\n        E = a.win;\n\n    a.error = function (m, g, v) {\n      var x = a.isNumber(m) ? \"Highcharts error #\" + m + \": www.highcharts.com/errors/\" + m : m,\n          y = function () {\n        if (g) throw Error(x);\n        E.console && console.log(x);\n      };\n\n      v ? a.fireEvent(v, \"displayError\", {\n        code: m,\n        message: x\n      }, y) : y();\n    };\n\n    a.Fx = function (a, g, v) {\n      this.options = g;\n      this.elem = a;\n      this.prop = v;\n    };\n\n    a.Fx.prototype = {\n      dSetter: function () {\n        var a = this.paths[0],\n            g = this.paths[1],\n            v = [],\n            x = this.now,\n            y = a.length,\n            z;\n        if (1 === x) v = this.toD;else if (y === g.length && 1 > x) for (; y--;) z = parseFloat(a[y]), v[y] = isNaN(z) ? g[y] : x * parseFloat(g[y] - z) + z;else v = g;\n        this.elem.attr(\"d\", v, null, !0);\n      },\n      update: function () {\n        var a = this.elem,\n            g = this.prop,\n            v = this.now,\n            x = this.options.step;\n        if (this[g + \"Setter\"]) this[g + \"Setter\"]();else a.attr ? a.element && a.attr(g, v, null, !0) : a.style[g] = v + this.unit;\n        x && x.call(a, v, this);\n      },\n      run: function (m, g, v) {\n        var x = this,\n            y = x.options,\n            z = function (a) {\n          return z.stopped ? !1 : x.step(a);\n        },\n            n = E.requestAnimationFrame || function (a) {\n          setTimeout(a, 13);\n        },\n            f = function () {\n          for (var h = 0; h < a.timers.length; h++) a.timers[h]() || a.timers.splice(h--, 1);\n\n          a.timers.length && n(f);\n        };\n\n        m !== g || this.elem[\"forceAnimate:\" + this.prop] ? (this.startTime = +new Date(), this.start = m, this.end = g, this.unit = v, this.now = this.start, this.pos = 0, z.elem = this.elem, z.prop = this.prop, z() && 1 === a.timers.push(z) && n(f)) : (delete y.curAnim[this.prop], y.complete && 0 === Object.keys(y.curAnim).length && y.complete.call(this.elem));\n      },\n      step: function (m) {\n        var g = +new Date(),\n            v,\n            x = this.options,\n            y = this.elem,\n            z = x.complete,\n            n = x.duration,\n            f = x.curAnim;\n        y.attr && !y.element ? m = !1 : m || g >= n + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), v = f[this.prop] = !0, a.objectEach(f, function (a) {\n          !0 !== a && (v = !1);\n        }), v && z && z.call(y), m = !1) : (this.pos = x.easing((g - this.startTime) / n), this.now = this.start + (this.end - this.start) * this.pos, this.update(), m = !0);\n        return m;\n      },\n      initPath: function (m, g, v) {\n        function x(a) {\n          var b, d;\n\n          for (c = a.length; c--;) b = \"M\" === a[c] || \"L\" === a[c], d = /[a-zA-Z]/.test(a[c + 3]), b && d && a.splice(c + 1, 0, a[c + 1], a[c + 2], a[c + 1], a[c + 2]);\n        }\n\n        function y(a, l) {\n          for (; a.length < b;) {\n            a[0] = l[b - a.length];\n            var d = a.slice(0, e);\n            [].splice.apply(a, [0, 0].concat(d));\n            t && (d = a.slice(a.length - e), [].splice.apply(a, [a.length, 0].concat(d)), c--);\n          }\n\n          a[0] = \"M\";\n        }\n\n        function z(a, c) {\n          for (var d = (b - a.length) / e; 0 < d && d--;) l = a.slice().splice(a.length / F - e, e * F), l[0] = c[b - e - d * e], r && (l[e - 6] = l[e - 2], l[e - 5] = l[e - 1]), [].splice.apply(a, [a.length / F, 0].concat(l)), t && d--;\n        }\n\n        g = g || \"\";\n        var n,\n            f = m.startX,\n            h = m.endX,\n            r = -1 < g.indexOf(\"C\"),\n            e = r ? 7 : 3,\n            b,\n            l,\n            c;\n        g = g.split(\" \");\n        v = v.slice();\n        var t = m.isArea,\n            F = t ? 2 : 1,\n            w;\n        r && (x(g), x(v));\n\n        if (f && h) {\n          for (c = 0; c < f.length; c++) if (f[c] === h[0]) {\n            n = c;\n            break;\n          } else if (f[0] === h[h.length - f.length + c]) {\n            n = c;\n            w = !0;\n            break;\n          } else if (f[f.length - 1] === h[h.length - f.length + c]) {\n            n = f.length - c;\n            break;\n          }\n\n          \"undefined\" === typeof n && (g = []);\n        }\n\n        g.length && a.isNumber(n) && (b = v.length + n * F * e, w ? (y(g, v), z(v, g)) : (y(v, g), z(g, v)));\n        return [g, v];\n      },\n      fillSetter: function () {\n        a.Fx.prototype.strokeSetter.apply(this, arguments);\n      },\n      strokeSetter: function () {\n        this.elem.attr(this.prop, a.color(this.start).tweenTo(a.color(this.end), this.pos), null, !0);\n      }\n    };\n\n    a.merge = function () {\n      var m,\n          g = arguments,\n          v,\n          x = {},\n          y = function (g, n) {\n        \"object\" !== typeof g && (g = {});\n        a.objectEach(n, function (f, h) {\n          !a.isObject(f, !0) || a.isClass(f) || a.isDOMElement(f) ? g[h] = n[h] : g[h] = y(g[h] || {}, f);\n        });\n        return g;\n      };\n\n      !0 === g[0] && (x = g[1], g = Array.prototype.slice.call(g, 2));\n      v = g.length;\n\n      for (m = 0; m < v; m++) x = y(x, g[m]);\n\n      return x;\n    };\n\n    a.pInt = function (a, g) {\n      return parseInt(a, g || 10);\n    };\n\n    a.isString = function (a) {\n      return \"string\" === typeof a;\n    };\n\n    a.isArray = function (a) {\n      a = Object.prototype.toString.call(a);\n      return \"[object Array]\" === a || \"[object Array Iterator]\" === a;\n    };\n\n    a.isObject = function (m, g) {\n      return !!m && \"object\" === typeof m && (!g || !a.isArray(m));\n    };\n\n    a.isDOMElement = function (m) {\n      return a.isObject(m) && \"number\" === typeof m.nodeType;\n    };\n\n    a.isClass = function (m) {\n      var g = m && m.constructor;\n      return !(!a.isObject(m, !0) || a.isDOMElement(m) || !g || !g.name || \"Object\" === g.name);\n    };\n\n    a.isNumber = function (a) {\n      return \"number\" === typeof a && !isNaN(a) && Infinity > a && -Infinity < a;\n    };\n\n    a.erase = function (a, g) {\n      for (var m = a.length; m--;) if (a[m] === g) {\n        a.splice(m, 1);\n        break;\n      }\n    };\n\n    a.defined = function (a) {\n      return \"undefined\" !== typeof a && null !== a;\n    };\n\n    a.attr = function (m, g, v) {\n      var x;\n      a.isString(g) ? a.defined(v) ? m.setAttribute(g, v) : m && m.getAttribute && ((x = m.getAttribute(g)) || \"class\" !== g || (x = m.getAttribute(g + \"Name\"))) : a.defined(g) && a.isObject(g) && a.objectEach(g, function (a, g) {\n        m.setAttribute(g, a);\n      });\n      return x;\n    };\n\n    a.splat = function (m) {\n      return a.isArray(m) ? m : [m];\n    };\n\n    a.syncTimeout = function (a, g, v) {\n      if (g) return setTimeout(a, g, v);\n      a.call(0, v);\n    };\n\n    a.clearTimeout = function (m) {\n      a.defined(m) && clearTimeout(m);\n    };\n\n    a.extend = function (a, g) {\n      var m;\n      a || (a = {});\n\n      for (m in g) a[m] = g[m];\n\n      return a;\n    };\n\n    a.pick = function () {\n      var a = arguments,\n          g,\n          v,\n          x = a.length;\n\n      for (g = 0; g < x; g++) if (v = a[g], \"undefined\" !== typeof v && null !== v) return v;\n    };\n\n    a.css = function (m, g) {\n      a.isMS && !a.svg && g && \"undefined\" !== typeof g.opacity && (g.filter = \"alpha(opacity\\x3d\" + 100 * g.opacity + \")\");\n      a.extend(m.style, g);\n    };\n\n    a.createElement = function (m, g, v, x, y) {\n      m = A.createElement(m);\n      var z = a.css;\n      g && a.extend(m, g);\n      y && z(m, {\n        padding: \"0\",\n        border: \"none\",\n        margin: \"0\"\n      });\n      v && z(m, v);\n      x && x.appendChild(m);\n      return m;\n    };\n\n    a.extendClass = function (m, g) {\n      var v = function () {};\n\n      v.prototype = new m();\n      a.extend(v.prototype, g);\n      return v;\n    };\n\n    a.pad = function (a, g, v) {\n      return Array((g || 2) + 1 - String(a).replace(\"-\", \"\").length).join(v || \"0\") + a;\n    };\n\n    a.relativeLength = function (a, g, v) {\n      return /%$/.test(a) ? g * parseFloat(a) / 100 + (v || 0) : parseFloat(a);\n    };\n\n    a.wrap = function (a, g, v) {\n      var m = a[g];\n\n      a[g] = function () {\n        var a = Array.prototype.slice.call(arguments),\n            g = arguments,\n            n = this;\n\n        n.proceed = function () {\n          m.apply(n, arguments.length ? arguments : g);\n        };\n\n        a.unshift(m);\n        a = v.apply(this, a);\n        n.proceed = null;\n        return a;\n      };\n    };\n\n    a.datePropsToTimestamps = function (m) {\n      a.objectEach(m, function (g, v) {\n        a.isObject(g) && \"function\" === typeof g.getTime ? m[v] = g.getTime() : (a.isObject(g) || a.isArray(g)) && a.datePropsToTimestamps(g);\n      });\n    };\n\n    a.formatSingle = function (m, g, v) {\n      var x = /\\.([0-9])/,\n          y = a.defaultOptions.lang;\n      /f$/.test(m) ? (v = (v = m.match(x)) ? v[1] : -1, null !== g && (g = a.numberFormat(g, v, y.decimalPoint, -1 < m.indexOf(\",\") ? y.thousandsSep : \"\"))) : g = (v || a.time).dateFormat(m, g);\n      return g;\n    };\n\n    a.format = function (m, g, v) {\n      for (var x = \"{\", y = !1, z, n, f, h, r = [], e; m;) {\n        x = m.indexOf(x);\n        if (-1 === x) break;\n        z = m.slice(0, x);\n\n        if (y) {\n          z = z.split(\":\");\n          n = z.shift().split(\".\");\n          h = n.length;\n          e = g;\n\n          for (f = 0; f < h; f++) e && (e = e[n[f]]);\n\n          z.length && (e = a.formatSingle(z.join(\":\"), e, v));\n          r.push(e);\n        } else r.push(z);\n\n        m = m.slice(x + 1);\n        x = (y = !y) ? \"}\" : \"{\";\n      }\n\n      r.push(m);\n      return r.join(\"\");\n    };\n\n    a.getMagnitude = function (a) {\n      return Math.pow(10, Math.floor(Math.log(a) / Math.LN10));\n    };\n\n    a.normalizeTickInterval = function (m, g, v, x, y) {\n      var z,\n          n = m;\n      v = a.pick(v, 1);\n      z = m / v;\n      g || (g = y ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === x && (1 === v ? g = g.filter(function (a) {\n        return 0 === a % 1;\n      }) : .1 >= v && (g = [1 / v])));\n\n      for (x = 0; x < g.length && !(n = g[x], y && n * v >= m || !y && z <= (g[x] + (g[x + 1] || g[x])) / 2); x++);\n\n      return n = a.correctFloat(n * v, -Math.round(Math.log(.001) / Math.LN10));\n    };\n\n    a.stableSort = function (a, g) {\n      var m = a.length,\n          x,\n          y;\n\n      for (y = 0; y < m; y++) a[y].safeI = y;\n\n      a.sort(function (a, n) {\n        x = g(a, n);\n        return 0 === x ? a.safeI - n.safeI : x;\n      });\n\n      for (y = 0; y < m; y++) delete a[y].safeI;\n    };\n\n    a.arrayMin = function (a) {\n      for (var g = a.length, m = a[0]; g--;) a[g] < m && (m = a[g]);\n\n      return m;\n    };\n\n    a.arrayMax = function (a) {\n      for (var g = a.length, m = a[0]; g--;) a[g] > m && (m = a[g]);\n\n      return m;\n    };\n\n    a.destroyObjectProperties = function (m, g) {\n      a.objectEach(m, function (a, x) {\n        a && a !== g && a.destroy && a.destroy();\n        delete m[x];\n      });\n    };\n\n    a.discardElement = function (m) {\n      var g = a.garbageBin;\n      g || (g = a.createElement(\"div\"));\n      m && g.appendChild(m);\n      g.innerHTML = \"\";\n    };\n\n    a.correctFloat = function (a, g) {\n      return parseFloat(a.toPrecision(g || 14));\n    };\n\n    a.setAnimation = function (m, g) {\n      g.renderer.globalAnimation = a.pick(m, g.options.chart.animation, !0);\n    };\n\n    a.animObject = function (m) {\n      return a.isObject(m) ? a.merge(m) : {\n        duration: m ? 500 : 0\n      };\n    };\n\n    a.timeUnits = {\n      millisecond: 1,\n      second: 1E3,\n      minute: 6E4,\n      hour: 36E5,\n      day: 864E5,\n      week: 6048E5,\n      month: 24192E5,\n      year: 314496E5\n    };\n\n    a.numberFormat = function (m, g, v, x) {\n      m = +m || 0;\n      g = +g;\n      var y = a.defaultOptions.lang,\n          z = (m.toString().split(\".\")[1] || \"\").split(\"e\")[0].length,\n          n,\n          f,\n          h = m.toString().split(\"e\");\n      -1 === g ? g = Math.min(z, 20) : a.isNumber(g) ? g && h[1] && 0 > h[1] && (n = g + +h[1], 0 <= n ? (h[0] = (+h[0]).toExponential(n).split(\"e\")[0], g = n) : (h[0] = h[0].split(\".\")[0] || 0, m = 20 > g ? (h[0] * Math.pow(10, h[1])).toFixed(g) : 0, h[1] = 0)) : g = 2;\n      f = (Math.abs(h[1] ? h[0] : m) + Math.pow(10, -Math.max(g, z) - 1)).toFixed(g);\n      z = String(a.pInt(f));\n      n = 3 < z.length ? z.length % 3 : 0;\n      v = a.pick(v, y.decimalPoint);\n      x = a.pick(x, y.thousandsSep);\n      m = (0 > m ? \"-\" : \"\") + (n ? z.substr(0, n) + x : \"\");\n      m += z.substr(n).replace(/(\\d{3})(?=\\d)/g, \"$1\" + x);\n      g && (m += v + f.slice(-g));\n      h[1] && 0 !== +m && (m += \"e\" + h[1]);\n      return m;\n    };\n\n    Math.easeInOutSine = function (a) {\n      return -.5 * (Math.cos(Math.PI * a) - 1);\n    };\n\n    a.getStyle = function (m, g, v) {\n      if (\"width\" === g) return Math.max(0, Math.min(m.offsetWidth, m.scrollWidth, m.getBoundingClientRect && \"none\" === a.getStyle(m, \"transform\", !1) ? Math.floor(m.getBoundingClientRect().width) : Infinity) - a.getStyle(m, \"padding-left\") - a.getStyle(m, \"padding-right\"));\n      if (\"height\" === g) return Math.max(0, Math.min(m.offsetHeight, m.scrollHeight) - a.getStyle(m, \"padding-top\") - a.getStyle(m, \"padding-bottom\"));\n      E.getComputedStyle || a.error(27, !0);\n      if (m = E.getComputedStyle(m, void 0)) m = m.getPropertyValue(g), a.pick(v, \"opacity\" !== g) && (m = a.pInt(m));\n      return m;\n    };\n\n    a.inArray = function (a, g, v) {\n      return g.indexOf(a, v);\n    };\n\n    a.find = Array.prototype.find ? function (a, g) {\n      return a.find(g);\n    } : function (a, g) {\n      var m,\n          x = a.length;\n\n      for (m = 0; m < x; m++) if (g(a[m], m)) return a[m];\n    };\n    a.keys = Object.keys;\n\n    a.offset = function (a) {\n      var g = A.documentElement;\n      a = a.parentElement || a.parentNode ? a.getBoundingClientRect() : {\n        top: 0,\n        left: 0\n      };\n      return {\n        top: a.top + (E.pageYOffset || g.scrollTop) - (g.clientTop || 0),\n        left: a.left + (E.pageXOffset || g.scrollLeft) - (g.clientLeft || 0)\n      };\n    };\n\n    a.stop = function (m, g) {\n      for (var v = a.timers.length; v--;) a.timers[v].elem !== m || g && g !== a.timers[v].prop || (a.timers[v].stopped = !0);\n    };\n\n    a.objectEach = function (a, g, v) {\n      for (var m in a) a.hasOwnProperty(m) && g.call(v || a[m], a[m], m, a);\n    };\n\n    a.objectEach({\n      map: \"map\",\n      each: \"forEach\",\n      grep: \"filter\",\n      reduce: \"reduce\",\n      some: \"some\"\n    }, function (m, g) {\n      a[g] = function (a) {\n        return Array.prototype[m].apply(a, [].slice.call(arguments, 1));\n      };\n    });\n\n    a.addEvent = function (m, g, v, x) {\n      void 0 === x && (x = {});\n      var y,\n          z = m.addEventListener || a.addEventListenerPolyfill;\n      y = \"function\" === typeof m && m.prototype ? m.prototype.protoEvents = m.prototype.protoEvents || {} : m.hcEvents = m.hcEvents || {};\n      a.Point && m instanceof a.Point && m.series && m.series.chart && (m.series.chart.runTrackerClick = !0);\n      z && z.call(m, g, v, !1);\n      y[g] || (y[g] = []);\n      y[g].push({\n        fn: v,\n        order: \"number\" === typeof x.order ? x.order : Infinity\n      });\n      y[g].sort(function (a, f) {\n        return a.order - f.order;\n      });\n      return function () {\n        a.removeEvent(m, g, v);\n      };\n    };\n\n    a.removeEvent = function (m, g, v) {\n      function x(n, f) {\n        var h = m.removeEventListener || a.removeEventListenerPolyfill;\n        h && h.call(m, n, f, !1);\n      }\n\n      function y(n) {\n        var f, h;\n        m.nodeName && (g ? (f = {}, f[g] = !0) : f = n, a.objectEach(f, function (a, e) {\n          if (n[e]) for (h = n[e].length; h--;) x(e, n[e][h].fn);\n        }));\n      }\n\n      var z;\n      [\"protoEvents\", \"hcEvents\"].forEach(function (a) {\n        var f = m[a];\n        f && (g ? (z = f[g] || [], v ? (f[g] = z.filter(function (a) {\n          return v !== a.fn;\n        }), x(g, v)) : (y(f), f[g] = [])) : (y(f), m[a] = {}));\n      });\n    };\n\n    a.fireEvent = function (m, g, v, x) {\n      var y, z;\n      v = v || {};\n      A.createEvent && (m.dispatchEvent || m.fireEvent) ? (y = A.createEvent(\"Events\"), y.initEvent(g, !0, !0), a.extend(y, v), m.dispatchEvent ? m.dispatchEvent(y) : m.fireEvent(g, y)) : (v.target || a.extend(v, {\n        preventDefault: function () {\n          v.defaultPrevented = !0;\n        },\n        target: m,\n        type: g\n      }), function (a, f) {\n        void 0 === a && (a = []);\n        void 0 === f && (f = []);\n        var h = 0,\n            r = 0,\n            e = a.length + f.length;\n\n        for (z = 0; z < e; z++) !1 === (a[h] ? f[r] ? a[h].order <= f[r].order ? a[h++] : f[r++] : a[h++] : f[r++]).fn.call(m, v) && v.preventDefault();\n      }(m.protoEvents && m.protoEvents[g], m.hcEvents && m.hcEvents[g]));\n      x && !v.defaultPrevented && x.call(m, v);\n    };\n\n    a.animate = function (m, g, v) {\n      var x,\n          y = \"\",\n          z,\n          n,\n          f;\n      a.isObject(v) || (f = arguments, v = {\n        duration: f[2],\n        easing: f[3],\n        complete: f[4]\n      });\n      a.isNumber(v.duration) || (v.duration = 400);\n      v.easing = \"function\" === typeof v.easing ? v.easing : Math[v.easing] || Math.easeInOutSine;\n      v.curAnim = a.merge(g);\n      a.objectEach(g, function (h, f) {\n        a.stop(m, f);\n        n = new a.Fx(m, v, f);\n        z = null;\n        \"d\" === f ? (n.paths = n.initPath(m, m.d, g.d), n.toD = g.d, x = 0, z = 1) : m.attr ? x = m.attr(f) : (x = parseFloat(a.getStyle(m, f)) || 0, \"opacity\" !== f && (y = \"px\"));\n        z || (z = h);\n        z && z.match && z.match(\"px\") && (z = z.replace(/px/g, \"\"));\n        n.run(x, z, y);\n      });\n    };\n\n    a.seriesType = function (m, g, v, x, y) {\n      var z = a.getOptions(),\n          n = a.seriesTypes;\n      z.plotOptions[m] = a.merge(z.plotOptions[g], v);\n      n[m] = a.extendClass(n[g] || function () {}, x);\n      n[m].prototype.type = m;\n      y && (n[m].prototype.pointClass = a.extendClass(a.Point, y));\n      return n[m];\n    };\n\n    a.uniqueKey = function () {\n      var a = Math.random().toString(36).substring(2, 9),\n          g = 0;\n      return function () {\n        return \"highcharts-\" + a + \"-\" + g++;\n      };\n    }();\n\n    a.isFunction = function (a) {\n      return \"function\" === typeof a;\n    };\n\n    E.jQuery && (E.jQuery.fn.highcharts = function () {\n      var m = [].slice.call(arguments);\n      if (this[0]) return m[0] ? (new a[a.isString(m[0]) ? m.shift() : \"Chart\"](this[0], m[0], m[1]), this) : C[a.attr(this[0], \"data-highcharts-chart\")];\n    });\n  });\n  I(H, \"parts/Color.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.isNumber,\n        A = a.merge,\n        E = a.pInt;\n\n    a.Color = function (m) {\n      if (!(this instanceof a.Color)) return new a.Color(m);\n      this.init(m);\n    };\n\n    a.Color.prototype = {\n      parsers: [{\n        regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n        parse: function (a) {\n          return [E(a[1]), E(a[2]), E(a[3]), parseFloat(a[4], 10)];\n        }\n      }, {\n        regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n        parse: function (a) {\n          return [E(a[1]), E(a[2]), E(a[3]), 1];\n        }\n      }],\n      names: {\n        white: \"#ffffff\",\n        black: \"#000000\"\n      },\n      init: function (m) {\n        var g, v, x, y;\n        if ((this.input = m = this.names[m && m.toLowerCase ? m.toLowerCase() : \"\"] || m) && m.stops) this.stops = m.stops.map(function (g) {\n          return new a.Color(g[1]);\n        });else if (m && m.charAt && \"#\" === m.charAt() && (g = m.length, m = parseInt(m.substr(1), 16), 7 === g ? v = [(m & 16711680) >> 16, (m & 65280) >> 8, m & 255, 1] : 4 === g && (v = [(m & 3840) >> 4 | (m & 3840) >> 8, (m & 240) >> 4 | m & 240, (m & 15) << 4 | m & 15, 1])), !v) for (x = this.parsers.length; x-- && !v;) y = this.parsers[x], (g = y.regex.exec(m)) && (v = y.parse(g));\n        this.rgba = v || [];\n      },\n      get: function (a) {\n        var g = this.input,\n            m = this.rgba,\n            x;\n        this.stops ? (x = A(g), x.stops = [].concat(x.stops), this.stops.forEach(function (g, m) {\n          x.stops[m] = [x.stops[m][0], g.get(a)];\n        })) : x = m && C(m[0]) ? \"rgb\" === a || !a && 1 === m[3] ? \"rgb(\" + m[0] + \",\" + m[1] + \",\" + m[2] + \")\" : \"a\" === a ? m[3] : \"rgba(\" + m.join(\",\") + \")\" : g;\n        return x;\n      },\n      brighten: function (a) {\n        var g,\n            m = this.rgba;\n        if (this.stops) this.stops.forEach(function (g) {\n          g.brighten(a);\n        });else if (C(a) && 0 !== a) for (g = 0; 3 > g; g++) m[g] += E(255 * a), 0 > m[g] && (m[g] = 0), 255 < m[g] && (m[g] = 255);\n        return this;\n      },\n      setOpacity: function (a) {\n        this.rgba[3] = a;\n        return this;\n      },\n      tweenTo: function (a, g) {\n        var m = this.rgba,\n            x = a.rgba;\n        x.length && m && m.length ? (a = 1 !== x[3] || 1 !== m[3], g = (a ? \"rgba(\" : \"rgb(\") + Math.round(x[0] + (m[0] - x[0]) * (1 - g)) + \",\" + Math.round(x[1] + (m[1] - x[1]) * (1 - g)) + \",\" + Math.round(x[2] + (m[2] - x[2]) * (1 - g)) + (a ? \",\" + (x[3] + (m[3] - x[3]) * (1 - g)) : \"\") + \")\") : g = a.input || \"none\";\n        return g;\n      }\n    };\n\n    a.color = function (m) {\n      return new a.Color(m);\n    };\n  });\n  I(H, \"parts/SvgRenderer.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C,\n        A,\n        E = a.addEvent,\n        m = a.animate,\n        g = a.attr,\n        v = a.charts,\n        x = a.color,\n        y = a.css,\n        z = a.createElement,\n        n = a.defined,\n        f = a.deg2rad,\n        h = a.destroyObjectProperties,\n        r = a.doc,\n        e = a.extend,\n        b = a.erase,\n        l = a.hasTouch,\n        c = a.isArray,\n        t = a.isFirefox,\n        F = a.isMS,\n        w = a.isObject,\n        B = a.isString,\n        p = a.isWebKit,\n        d = a.merge,\n        k = a.noop,\n        u = a.objectEach,\n        D = a.pick,\n        G = a.pInt,\n        q = a.removeEvent,\n        K = a.splat,\n        N = a.stop,\n        O = a.svg,\n        L = a.SVG_NS,\n        R = a.symbolSizes,\n        M = a.win;\n\n    C = a.SVGElement = function () {\n      return this;\n    };\n\n    e(C.prototype, {\n      opacity: 1,\n      SVG_NS: L,\n      textProps: \"direction fontSize fontWeight fontFamily fontStyle color lineHeight width textAlign textDecoration textOverflow textOutline cursor\".split(\" \"),\n      init: function (d, q) {\n        this.element = \"span\" === q ? z(q) : r.createElementNS(this.SVG_NS, q);\n        this.renderer = d;\n        a.fireEvent(this, \"afterInit\");\n      },\n      animate: function (d, q, b) {\n        var J = a.animObject(D(q, this.renderer.globalAnimation, !0));\n        D(r.hidden, r.msHidden, r.webkitHidden, !1) && (J.duration = 0);\n        0 !== J.duration ? (b && (J.complete = b), m(this, d, J)) : (this.attr(d, void 0, b), a.objectEach(d, function (a, d) {\n          J.step && J.step.call(this, a, {\n            prop: d,\n            pos: 1\n          });\n        }, this));\n        return this;\n      },\n      complexColor: function (q, b, k) {\n        var J = this.renderer,\n            e,\n            l,\n            t,\n            p,\n            K,\n            h,\n            f,\n            D,\n            r,\n            w,\n            G,\n            L = [],\n            O;\n        a.fireEvent(this.renderer, \"complexColor\", {\n          args: arguments\n        }, function () {\n          q.radialGradient ? l = \"radialGradient\" : q.linearGradient && (l = \"linearGradient\");\n          l && (t = q[l], K = J.gradients, f = q.stops, w = k.radialReference, c(t) && (q[l] = t = {\n            x1: t[0],\n            y1: t[1],\n            x2: t[2],\n            y2: t[3],\n            gradientUnits: \"userSpaceOnUse\"\n          }), \"radialGradient\" === l && w && !n(t.gradientUnits) && (p = t, t = d(t, J.getRadialAttr(w, p), {\n            gradientUnits: \"userSpaceOnUse\"\n          })), u(t, function (a, d) {\n            \"id\" !== d && L.push(d, a);\n          }), u(f, function (a) {\n            L.push(a);\n          }), L = L.join(\",\"), K[L] ? G = K[L].attr(\"id\") : (t.id = G = a.uniqueKey(), K[L] = h = J.createElement(l).attr(t).add(J.defs), h.radAttr = p, h.stops = [], f.forEach(function (d) {\n            0 === d[1].indexOf(\"rgba\") ? (e = a.color(d[1]), D = e.get(\"rgb\"), r = e.get(\"a\")) : (D = d[1], r = 1);\n            d = J.createElement(\"stop\").attr({\n              offset: d[0],\n              \"stop-color\": D,\n              \"stop-opacity\": r\n            }).add(h);\n            h.stops.push(d);\n          })), O = \"url(\" + J.url + \"#\" + G + \")\", k.setAttribute(b, O), k.gradient = L, q.toString = function () {\n            return O;\n          });\n        });\n      },\n      applyTextOutline: function (d) {\n        var q = this.element,\n            b,\n            J,\n            k;\n        -1 !== d.indexOf(\"contrast\") && (d = d.replace(/contrast/g, this.renderer.getContrast(q.style.fill)));\n        d = d.split(\" \");\n        b = d[d.length - 1];\n        (J = d[0]) && \"none\" !== J && a.svg && (this.fakeTS = !0, d = [].slice.call(q.getElementsByTagName(\"tspan\")), this.ySetter = this.xSetter, J = J.replace(/(^[\\d\\.]+)(.*?)$/g, function (a, d, q) {\n          return 2 * d + q;\n        }), this.removeTextOutline(d), k = q.firstChild, d.forEach(function (a, d) {\n          0 === d && (a.setAttribute(\"x\", q.getAttribute(\"x\")), d = q.getAttribute(\"y\"), a.setAttribute(\"y\", d || 0), null === d && q.setAttribute(\"y\", 0));\n          a = a.cloneNode(1);\n          g(a, {\n            \"class\": \"highcharts-text-outline\",\n            fill: b,\n            stroke: b,\n            \"stroke-width\": J,\n            \"stroke-linejoin\": \"round\"\n          });\n          q.insertBefore(a, k);\n        }));\n      },\n      removeTextOutline: function (a) {\n        for (var d = a.length, q; d--;) q = a[d], \"highcharts-text-outline\" === q.getAttribute(\"class\") && b(a, this.element.removeChild(q));\n      },\n      symbolCustomAttribs: \"x y width height r start end innerR anchorX anchorY rounded\".split(\" \"),\n      attr: function (d, q, b, k) {\n        var J,\n            e = this.element,\n            c,\n            l = this,\n            t,\n            p,\n            K = this.symbolCustomAttribs;\n        \"string\" === typeof d && void 0 !== q && (J = d, d = {}, d[J] = q);\n        \"string\" === typeof d ? l = (this[d + \"Getter\"] || this._defaultGetter).call(this, d, e) : (u(d, function (q, b) {\n          t = !1;\n          k || N(this, b);\n          this.symbolName && -1 !== a.inArray(b, K) && (c || (this.symbolAttr(d), c = !0), t = !0);\n          !this.rotation || \"x\" !== b && \"y\" !== b || (this.doTransform = !0);\n          t || (p = this[b + \"Setter\"] || this._defaultSetter, p.call(this, q, b, e), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(b) && this.updateShadows(b, q, p));\n        }, this), this.afterSetters());\n        b && b.call(this);\n        return l;\n      },\n      afterSetters: function () {\n        this.doTransform && (this.updateTransform(), this.doTransform = !1);\n      },\n      updateShadows: function (a, d, q) {\n        for (var b = this.shadows, J = b.length; J--;) q.call(b[J], \"height\" === a ? Math.max(d - (b[J].cutHeight || 0), 0) : \"d\" === a ? this.d : d, a, b[J]);\n      },\n      addClass: function (a, d) {\n        var q = this.attr(\"class\") || \"\";\n        d || (a = (a || \"\").split(/ /g).reduce(function (a, d) {\n          -1 === q.indexOf(d) && a.push(d);\n          return a;\n        }, q ? [q] : []).join(\" \"));\n        a !== q && this.attr(\"class\", a);\n        return this;\n      },\n      hasClass: function (a) {\n        return -1 !== (this.attr(\"class\") || \"\").split(\" \").indexOf(a);\n      },\n      removeClass: function (a) {\n        return this.attr(\"class\", (this.attr(\"class\") || \"\").replace(a, \"\"));\n      },\n      symbolAttr: function (a) {\n        var d = this;\n        \"x y r start end width height innerR anchorX anchorY clockwise\".split(\" \").forEach(function (q) {\n          d[q] = D(a[q], d[q]);\n        });\n        d.attr({\n          d: d.renderer.symbols[d.symbolName](d.x, d.y, d.width, d.height, d)\n        });\n      },\n      clip: function (a) {\n        return this.attr(\"clip-path\", a ? \"url(\" + this.renderer.url + \"#\" + a.id + \")\" : \"none\");\n      },\n      crisp: function (a, d) {\n        var q;\n        d = d || a.strokeWidth || 0;\n        q = Math.round(d) % 2 / 2;\n        a.x = Math.floor(a.x || this.x || 0) + q;\n        a.y = Math.floor(a.y || this.y || 0) + q;\n        a.width = Math.floor((a.width || this.width || 0) - 2 * q);\n        a.height = Math.floor((a.height || this.height || 0) - 2 * q);\n        n(a.strokeWidth) && (a.strokeWidth = d);\n        return a;\n      },\n      css: function (a) {\n        var d = this.styles,\n            q = {},\n            b = this.element,\n            k,\n            J = \"\",\n            c,\n            l = !d,\n            t = [\"textOutline\", \"textOverflow\", \"width\"];\n        a && a.color && (a.fill = a.color);\n        d && u(a, function (a, b) {\n          a !== d[b] && (q[b] = a, l = !0);\n        });\n        l && (d && (a = e(d, q)), a && (null === a.width || \"auto\" === a.width ? delete this.textWidth : \"text\" === b.nodeName.toLowerCase() && a.width && (k = this.textWidth = G(a.width))), this.styles = a, k && !O && this.renderer.forExport && delete a.width, b.namespaceURI === this.SVG_NS ? (c = function (a, d) {\n          return \"-\" + d.toLowerCase();\n        }, u(a, function (a, d) {\n          -1 === t.indexOf(d) && (J += d.replace(/([A-Z])/g, c) + \":\" + a + \";\");\n        }), J && g(b, \"style\", J)) : y(b, a), this.added && (\"text\" === this.element.nodeName && this.renderer.buildText(this), a && a.textOutline && this.applyTextOutline(a.textOutline)));\n        return this;\n      },\n      getStyle: function (a) {\n        return M.getComputedStyle(this.element || this, \"\").getPropertyValue(a);\n      },\n      strokeWidth: function () {\n        if (!this.renderer.styledMode) return this[\"stroke-width\"] || 0;\n        var a = this.getStyle(\"stroke-width\"),\n            d;\n        a.indexOf(\"px\") === a.length - 2 ? a = G(a) : (d = r.createElementNS(L, \"rect\"), g(d, {\n          width: a,\n          \"stroke-width\": 0\n        }), this.element.parentNode.appendChild(d), a = d.getBBox().width, d.parentNode.removeChild(d));\n        return a;\n      },\n      on: function (a, d) {\n        var q = this,\n            b = q.element;\n        l && \"click\" === a ? (b.ontouchstart = function (a) {\n          q.touchEventFired = Date.now();\n          a.preventDefault();\n          d.call(b, a);\n        }, b.onclick = function (a) {\n          (-1 === M.navigator.userAgent.indexOf(\"Android\") || 1100 < Date.now() - (q.touchEventFired || 0)) && d.call(b, a);\n        }) : b[\"on\" + a] = d;\n        return this;\n      },\n      setRadialReference: function (a) {\n        var d = this.renderer.gradients[this.element.gradient];\n        this.element.radialReference = a;\n        d && d.radAttr && d.animate(this.renderer.getRadialAttr(a, d.radAttr));\n        return this;\n      },\n      translate: function (a, d) {\n        return this.attr({\n          translateX: a,\n          translateY: d\n        });\n      },\n      invert: function (a) {\n        this.inverted = a;\n        this.updateTransform();\n        return this;\n      },\n      updateTransform: function () {\n        var a = this.translateX || 0,\n            d = this.translateY || 0,\n            q = this.scaleX,\n            b = this.scaleY,\n            k = this.inverted,\n            e = this.rotation,\n            c = this.matrix,\n            l = this.element;\n        k && (a += this.width, d += this.height);\n        a = [\"translate(\" + a + \",\" + d + \")\"];\n        n(c) && a.push(\"matrix(\" + c.join(\",\") + \")\");\n        k ? a.push(\"rotate(90) scale(-1,1)\") : e && a.push(\"rotate(\" + e + \" \" + D(this.rotationOriginX, l.getAttribute(\"x\"), 0) + \" \" + D(this.rotationOriginY, l.getAttribute(\"y\") || 0) + \")\");\n        (n(q) || n(b)) && a.push(\"scale(\" + D(q, 1) + \" \" + D(b, 1) + \")\");\n        a.length && l.setAttribute(\"transform\", a.join(\" \"));\n      },\n      toFront: function () {\n        var a = this.element;\n        a.parentNode.appendChild(a);\n        return this;\n      },\n      align: function (a, d, q) {\n        var k,\n            e,\n            l,\n            c,\n            t = {};\n        e = this.renderer;\n        l = e.alignedObjects;\n        var u, J;\n\n        if (a) {\n          if (this.alignOptions = a, this.alignByTranslate = d, !q || B(q)) this.alignTo = k = q || \"renderer\", b(l, this), l.push(this), q = null;\n        } else a = this.alignOptions, d = this.alignByTranslate, k = this.alignTo;\n\n        q = D(q, e[k], e);\n        k = a.align;\n        e = a.verticalAlign;\n        l = (q.x || 0) + (a.x || 0);\n        c = (q.y || 0) + (a.y || 0);\n        \"right\" === k ? u = 1 : \"center\" === k && (u = 2);\n        u && (l += (q.width - (a.width || 0)) / u);\n        t[d ? \"translateX\" : \"x\"] = Math.round(l);\n        \"bottom\" === e ? J = 1 : \"middle\" === e && (J = 2);\n        J && (c += (q.height - (a.height || 0)) / J);\n        t[d ? \"translateY\" : \"y\"] = Math.round(c);\n        this[this.placed ? \"animate\" : \"attr\"](t);\n        this.placed = !0;\n        this.alignAttr = t;\n        return this;\n      },\n      getBBox: function (a, d) {\n        var q,\n            b = this.renderer,\n            k,\n            l = this.element,\n            c = this.styles,\n            t,\n            u = this.textStr,\n            J,\n            p = b.cache,\n            K = b.cacheKeys,\n            h = l.namespaceURI === this.SVG_NS,\n            r;\n        d = D(d, this.rotation);\n        k = d * f;\n        t = b.styledMode ? l && C.prototype.getStyle.call(l, \"font-size\") : c && c.fontSize;\n        n(u) && (r = u.toString(), -1 === r.indexOf(\"\\x3c\") && (r = r.replace(/[0-9]/g, \"0\")), r += [\"\", d || 0, t, this.textWidth, c && c.textOverflow].join());\n        r && !a && (q = p[r]);\n\n        if (!q) {\n          if (h || b.forExport) {\n            try {\n              (J = this.fakeTS && function (a) {\n                [].forEach.call(l.querySelectorAll(\".highcharts-text-outline\"), function (d) {\n                  d.style.display = a;\n                });\n              }) && J(\"none\"), q = l.getBBox ? e({}, l.getBBox()) : {\n                width: l.offsetWidth,\n                height: l.offsetHeight\n              }, J && J(\"\");\n            } catch (Z) {\n              \"\";\n            }\n\n            if (!q || 0 > q.width) q = {\n              width: 0,\n              height: 0\n            };\n          } else q = this.htmlGetBBox();\n\n          b.isSVG && (a = q.width, b = q.height, h && (q.height = b = {\n            \"11px,17\": 14,\n            \"13px,20\": 16\n          }[c && c.fontSize + \",\" + Math.round(b)] || b), d && (q.width = Math.abs(b * Math.sin(k)) + Math.abs(a * Math.cos(k)), q.height = Math.abs(b * Math.cos(k)) + Math.abs(a * Math.sin(k))));\n\n          if (r && 0 < q.height) {\n            for (; 250 < K.length;) delete p[K.shift()];\n\n            p[r] || K.push(r);\n            p[r] = q;\n          }\n        }\n\n        return q;\n      },\n      show: function (a) {\n        return this.attr({\n          visibility: a ? \"inherit\" : \"visible\"\n        });\n      },\n      hide: function () {\n        return this.attr({\n          visibility: \"hidden\"\n        });\n      },\n      fadeOut: function (a) {\n        var d = this;\n        d.animate({\n          opacity: 0\n        }, {\n          duration: a || 150,\n          complete: function () {\n            d.attr({\n              y: -9999\n            });\n          }\n        });\n      },\n      add: function (a) {\n        var d = this.renderer,\n            q = this.element,\n            b;\n        a && (this.parentGroup = a);\n        this.parentInverted = a && a.inverted;\n        void 0 !== this.textStr && d.buildText(this);\n        this.added = !0;\n        if (!a || a.handleZ || this.zIndex) b = this.zIndexSetter();\n        b || (a ? a.element : d.box).appendChild(q);\n        if (this.onAdd) this.onAdd();\n        return this;\n      },\n      safeRemoveChild: function (a) {\n        var d = a.parentNode;\n        d && d.removeChild(a);\n      },\n      destroy: function () {\n        var a = this,\n            d = a.element || {},\n            q = a.renderer,\n            k = q.isSVG && \"SPAN\" === d.nodeName && a.parentGroup,\n            e = d.ownerSVGElement,\n            l = a.clipPath;\n        d.onclick = d.onmouseout = d.onmouseover = d.onmousemove = d.point = null;\n        N(a);\n        l && e && ([].forEach.call(e.querySelectorAll(\"[clip-path],[CLIP-PATH]\"), function (a) {\n          -1 < a.getAttribute(\"clip-path\").indexOf(l.element.id) && a.removeAttribute(\"clip-path\");\n        }), a.clipPath = l.destroy());\n\n        if (a.stops) {\n          for (e = 0; e < a.stops.length; e++) a.stops[e] = a.stops[e].destroy();\n\n          a.stops = null;\n        }\n\n        a.safeRemoveChild(d);\n\n        for (q.styledMode || a.destroyShadows(); k && k.div && 0 === k.div.childNodes.length;) d = k.parentGroup, a.safeRemoveChild(k.div), delete k.div, k = d;\n\n        a.alignTo && b(q.alignedObjects, a);\n        u(a, function (d, q) {\n          delete a[q];\n        });\n      },\n      shadow: function (a, d, q) {\n        var b = [],\n            k,\n            e,\n            l = this.element,\n            c,\n            t,\n            u,\n            p;\n        if (!a) this.destroyShadows();else if (!this.shadows) {\n          t = D(a.width, 3);\n          u = (a.opacity || .15) / t;\n          p = this.parentInverted ? \"(-1,-1)\" : \"(\" + D(a.offsetX, 1) + \", \" + D(a.offsetY, 1) + \")\";\n\n          for (k = 1; k <= t; k++) e = l.cloneNode(0), c = 2 * t + 1 - 2 * k, g(e, {\n            stroke: a.color || \"#000000\",\n            \"stroke-opacity\": u * k,\n            \"stroke-width\": c,\n            transform: \"translate\" + p,\n            fill: \"none\"\n          }), e.setAttribute(\"class\", (e.getAttribute(\"class\") || \"\") + \" highcharts-shadow\"), q && (g(e, \"height\", Math.max(g(e, \"height\") - c, 0)), e.cutHeight = c), d ? d.element.appendChild(e) : l.parentNode && l.parentNode.insertBefore(e, l), b.push(e);\n\n          this.shadows = b;\n        }\n        return this;\n      },\n      destroyShadows: function () {\n        (this.shadows || []).forEach(function (a) {\n          this.safeRemoveChild(a);\n        }, this);\n        this.shadows = void 0;\n      },\n      xGetter: function (a) {\n        \"circle\" === this.element.nodeName && (\"x\" === a ? a = \"cx\" : \"y\" === a && (a = \"cy\"));\n        return this._defaultGetter(a);\n      },\n      _defaultGetter: function (a) {\n        a = D(this[a + \"Value\"], this[a], this.element ? this.element.getAttribute(a) : null, 0);\n        /^[\\-0-9\\.]+$/.test(a) && (a = parseFloat(a));\n        return a;\n      },\n      dSetter: function (a, d, q) {\n        a && a.join && (a = a.join(\" \"));\n        /(NaN| {2}|^$)/.test(a) && (a = \"M 0 0\");\n        this[d] !== a && (q.setAttribute(d, a), this[d] = a);\n      },\n      dashstyleSetter: function (a) {\n        var d,\n            q = this[\"stroke-width\"];\n        \"inherit\" === q && (q = 1);\n\n        if (a = a && a.toLowerCase()) {\n          a = a.replace(\"shortdashdotdot\", \"3,1,1,1,1,1,\").replace(\"shortdashdot\", \"3,1,1,1\").replace(\"shortdot\", \"1,1,\").replace(\"shortdash\", \"3,1,\").replace(\"longdash\", \"8,3,\").replace(/dot/g, \"1,3,\").replace(\"dash\", \"4,3,\").replace(/,$/, \"\").split(\",\");\n\n          for (d = a.length; d--;) a[d] = G(a[d]) * q;\n\n          a = a.join(\",\").replace(/NaN/g, \"none\");\n          this.element.setAttribute(\"stroke-dasharray\", a);\n        }\n      },\n      alignSetter: function (a) {\n        var d = {\n          left: \"start\",\n          center: \"middle\",\n          right: \"end\"\n        };\n        d[a] && (this.alignValue = a, this.element.setAttribute(\"text-anchor\", d[a]));\n      },\n      opacitySetter: function (a, d, q) {\n        this[d] = a;\n        q.setAttribute(d, a);\n      },\n      titleSetter: function (a) {\n        var d = this.element.getElementsByTagName(\"title\")[0];\n        d || (d = r.createElementNS(this.SVG_NS, \"title\"), this.element.appendChild(d));\n        d.firstChild && d.removeChild(d.firstChild);\n        d.appendChild(r.createTextNode(String(D(a, \"\")).replace(/<[^>]*>/g, \"\").replace(/&lt;/g, \"\\x3c\").replace(/&gt;/g, \"\\x3e\")));\n      },\n      textSetter: function (a) {\n        a !== this.textStr && (delete this.bBox, delete this.textPxLength, this.textStr = a, this.added && this.renderer.buildText(this));\n      },\n      setTextPath: function (q, b) {\n        var e = this.element,\n            l = {\n          textAnchor: \"text-anchor\"\n        },\n            c,\n            t = !1,\n            u,\n            p = this.textPathWrapper,\n            K = !p;\n        b = d(!0, {\n          enabled: !0,\n          attributes: {\n            dy: -5,\n            startOffset: \"50%\",\n            textAnchor: \"middle\"\n          }\n        }, b);\n        c = b.attributes;\n\n        if (q && b && b.enabled) {\n          this.options && this.options.padding && (c.dx = -this.options.padding);\n          p || (this.textPathWrapper = p = this.renderer.createElement(\"textPath\"), t = !0);\n          u = p.element;\n          (b = q.element.getAttribute(\"id\")) || q.element.setAttribute(\"id\", b = a.uniqueKey());\n          if (K) for (q = e.getElementsByTagName(\"tspan\"); q.length;) q[0].setAttribute(\"y\", 0), u.appendChild(q[0]);\n          t && p.add({\n            element: this.text ? this.text.element : e\n          });\n          u.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", this.renderer.url + \"#\" + b);\n          n(c.dy) && (u.parentNode.setAttribute(\"dy\", c.dy), delete c.dy);\n          n(c.dx) && (u.parentNode.setAttribute(\"dx\", c.dx), delete c.dx);\n          a.objectEach(c, function (a, d) {\n            u.setAttribute(l[d] || d, a);\n          });\n          e.removeAttribute(\"transform\");\n          this.removeTextOutline.call(p, [].slice.call(e.getElementsByTagName(\"tspan\")));\n          this.text && !this.renderer.styledMode && this.attr({\n            fill: \"none\",\n            \"stroke-width\": 0\n          });\n          this.applyTextOutline = this.updateTransform = k;\n        } else p && (delete this.updateTransform, delete this.applyTextOutline, this.destroyTextPath(e, q));\n\n        return this;\n      },\n      destroyTextPath: function (a, d) {\n        var q;\n        d.element.setAttribute(\"id\", \"\");\n\n        for (q = this.textPathWrapper.element.childNodes; q.length;) a.firstChild.appendChild(q[0]);\n\n        a.firstChild.removeChild(this.textPathWrapper.element);\n        delete d.textPathWrapper;\n      },\n      fillSetter: function (a, d, q) {\n        \"string\" === typeof a ? q.setAttribute(d, a) : a && this.complexColor(a, d, q);\n      },\n      visibilitySetter: function (a, d, q) {\n        \"inherit\" === a ? q.removeAttribute(d) : this[d] !== a && q.setAttribute(d, a);\n        this[d] = a;\n      },\n      zIndexSetter: function (a, d) {\n        var q = this.renderer,\n            b = this.parentGroup,\n            k = (b || q).element || q.box,\n            e,\n            l = this.element,\n            c = !1,\n            t,\n            q = k === q.box;\n        e = this.added;\n        var u;\n        n(a) ? (l.setAttribute(\"data-z-index\", a), a = +a, this[d] === a && (e = !1)) : n(this[d]) && l.removeAttribute(\"data-z-index\");\n        this[d] = a;\n\n        if (e) {\n          (a = this.zIndex) && b && (b.handleZ = !0);\n          d = k.childNodes;\n\n          for (u = d.length - 1; 0 <= u && !c; u--) if (b = d[u], e = b.getAttribute(\"data-z-index\"), t = !n(e), b !== l) if (0 > a && t && !q && !u) k.insertBefore(l, d[u]), c = !0;else if (G(e) <= a || t && (!n(a) || 0 <= a)) k.insertBefore(l, d[u + 1] || null), c = !0;\n\n          c || (k.insertBefore(l, d[q ? 3 : 0] || null), c = !0);\n        }\n\n        return c;\n      },\n      _defaultSetter: function (a, d, q) {\n        q.setAttribute(d, a);\n      }\n    });\n    C.prototype.yGetter = C.prototype.xGetter;\n\n    C.prototype.translateXSetter = C.prototype.translateYSetter = C.prototype.rotationSetter = C.prototype.verticalAlignSetter = C.prototype.rotationOriginXSetter = C.prototype.rotationOriginYSetter = C.prototype.scaleXSetter = C.prototype.scaleYSetter = C.prototype.matrixSetter = function (a, d) {\n      this[d] = a;\n      this.doTransform = !0;\n    };\n\n    C.prototype[\"stroke-widthSetter\"] = C.prototype.strokeSetter = function (a, d, q) {\n      this[d] = a;\n      this.stroke && this[\"stroke-width\"] ? (C.prototype.fillSetter.call(this, this.stroke, \"stroke\", q), q.setAttribute(\"stroke-width\", this[\"stroke-width\"]), this.hasStroke = !0) : \"stroke-width\" === d && 0 === a && this.hasStroke && (q.removeAttribute(\"stroke\"), this.hasStroke = !1);\n    };\n\n    A = a.SVGRenderer = function () {\n      this.init.apply(this, arguments);\n    };\n\n    e(A.prototype, {\n      Element: C,\n      SVG_NS: L,\n      init: function (a, d, q, b, k, e, l) {\n        var c;\n        c = this.createElement(\"svg\").attr({\n          version: \"1.1\",\n          \"class\": \"highcharts-root\"\n        });\n        l || c.css(this.getStyle(b));\n        b = c.element;\n        a.appendChild(b);\n        g(a, \"dir\", \"ltr\");\n        -1 === a.innerHTML.indexOf(\"xmlns\") && g(b, \"xmlns\", this.SVG_NS);\n        this.isSVG = !0;\n        this.box = b;\n        this.boxWrapper = c;\n        this.alignedObjects = [];\n        this.url = (t || p) && r.getElementsByTagName(\"base\").length ? M.location.href.split(\"#\")[0].replace(/<[^>]*>/g, \"\").replace(/([\\('\\)])/g, \"\\\\$1\").replace(/ /g, \"%20\") : \"\";\n        this.createElement(\"desc\").add().element.appendChild(r.createTextNode(\"Created with Highcharts 7.1.2\"));\n        this.defs = this.createElement(\"defs\").add();\n        this.allowHTML = e;\n        this.forExport = k;\n        this.styledMode = l;\n        this.gradients = {};\n        this.cache = {};\n        this.cacheKeys = [];\n        this.imgCount = 0;\n        this.setSize(d, q, !1);\n        var u;\n        t && a.getBoundingClientRect && (d = function () {\n          y(a, {\n            left: 0,\n            top: 0\n          });\n          u = a.getBoundingClientRect();\n          y(a, {\n            left: Math.ceil(u.left) - u.left + \"px\",\n            top: Math.ceil(u.top) - u.top + \"px\"\n          });\n        }, d(), this.unSubPixelFix = E(M, \"resize\", d));\n      },\n      definition: function (a) {\n        function d(a, b) {\n          var k;\n          K(a).forEach(function (a) {\n            var e = q.createElement(a.tagName),\n                c = {};\n            u(a, function (a, d) {\n              \"tagName\" !== d && \"children\" !== d && \"textContent\" !== d && (c[d] = a);\n            });\n            e.attr(c);\n            e.add(b || q.defs);\n            a.textContent && e.element.appendChild(r.createTextNode(a.textContent));\n            d(a.children || [], e);\n            k = e;\n          });\n          return k;\n        }\n\n        var q = this;\n        return d(a);\n      },\n      getStyle: function (a) {\n        return this.style = e({\n          fontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Arial, Helvetica, sans-serif',\n          fontSize: \"12px\"\n        }, a);\n      },\n      setStyle: function (a) {\n        this.boxWrapper.css(this.getStyle(a));\n      },\n      isHidden: function () {\n        return !this.boxWrapper.getBBox().width;\n      },\n      destroy: function () {\n        var a = this.defs;\n        this.box = null;\n        this.boxWrapper = this.boxWrapper.destroy();\n        h(this.gradients || {});\n        this.gradients = null;\n        a && (this.defs = a.destroy());\n        this.unSubPixelFix && this.unSubPixelFix();\n        return this.alignedObjects = null;\n      },\n      createElement: function (a) {\n        var d = new this.Element();\n        d.init(this, a);\n        return d;\n      },\n      draw: k,\n      getRadialAttr: function (a, d) {\n        return {\n          cx: a[0] - a[2] / 2 + d.cx * a[2],\n          cy: a[1] - a[2] / 2 + d.cy * a[2],\n          r: d.r * a[2]\n        };\n      },\n      truncate: function (a, d, q, b, k, e, c) {\n        var l = this,\n            u = a.rotation,\n            t,\n            p = b ? 1 : 0,\n            K = (q || b).length,\n            h = K,\n            f = [],\n            D = function (a) {\n          d.firstChild && d.removeChild(d.firstChild);\n          a && d.appendChild(r.createTextNode(a));\n        },\n            w = function (e, u) {\n          u = u || e;\n          if (void 0 === f[u]) if (d.getSubStringLength) try {\n            f[u] = k + d.getSubStringLength(0, b ? u + 1 : u);\n          } catch (ea) {\n            \"\";\n          } else l.getSpanWidth && (D(c(q || b, e)), f[u] = k + l.getSpanWidth(a, d));\n          return f[u];\n        },\n            n,\n            L;\n\n        a.rotation = 0;\n        n = w(d.textContent.length);\n\n        if (L = k + n > e) {\n          for (; p <= K;) h = Math.ceil((p + K) / 2), b && (t = c(b, h)), n = w(h, t && t.length - 1), p === K ? p = K + 1 : n > e ? K = h - 1 : p = h;\n\n          0 === K ? D(\"\") : q && K === q.length - 1 || D(t || c(q || b, h));\n        }\n\n        b && b.splice(0, h);\n        a.actualWidth = n;\n        a.rotation = u;\n        return L;\n      },\n      escapes: {\n        \"\\x26\": \"\\x26amp;\",\n        \"\\x3c\": \"\\x26lt;\",\n        \"\\x3e\": \"\\x26gt;\",\n        \"'\": \"\\x26#39;\",\n        '\"': \"\\x26quot;\"\n      },\n      buildText: function (a) {\n        var d = a.element,\n            q = this,\n            b = q.forExport,\n            k = D(a.textStr, \"\").toString(),\n            e = -1 !== k.indexOf(\"\\x3c\"),\n            c = d.childNodes,\n            l,\n            t = g(d, \"x\"),\n            p = a.styles,\n            K = a.textWidth,\n            h = p && p.lineHeight,\n            f = p && p.textOutline,\n            w = p && \"ellipsis\" === p.textOverflow,\n            n = p && \"nowrap\" === p.whiteSpace,\n            J = p && p.fontSize,\n            F,\n            N,\n            R = c.length,\n            p = K && !a.added && this.box,\n            B = function (a) {\n          var b;\n          q.styledMode || (b = /(px|em)$/.test(a && a.style.fontSize) ? a.style.fontSize : J || q.style.fontSize || 12);\n          return h ? G(h) : q.fontMetrics(b, a.getAttribute(\"style\") ? a : d).h;\n        },\n            m = function (a, d) {\n          u(q.escapes, function (q, b) {\n            d && -1 !== d.indexOf(q) || (a = a.toString().replace(new RegExp(q, \"g\"), b));\n          });\n          return a;\n        },\n            M = function (a, d) {\n          var q;\n          q = a.indexOf(\"\\x3c\");\n          a = a.substring(q, a.indexOf(\"\\x3e\") - q);\n          q = a.indexOf(d + \"\\x3d\");\n          if (-1 !== q && (q = q + d.length + 1, d = a.charAt(q), '\"' === d || \"'\" === d)) return a = a.substring(q + 1), a.substring(0, a.indexOf(d));\n        };\n\n        F = [k, w, n, h, f, J, K].join();\n\n        if (F !== a.textCache) {\n          for (a.textCache = F; R--;) d.removeChild(c[R]);\n\n          e || f || w || K || -1 !== k.indexOf(\" \") ? (p && p.appendChild(d), e ? (k = q.styledMode ? k.replace(/<(b|strong)>/g, '\\x3cspan class\\x3d\"highcharts-strong\"\\x3e').replace(/<(i|em)>/g, '\\x3cspan class\\x3d\"highcharts-emphasized\"\\x3e') : k.replace(/<(b|strong)>/g, '\\x3cspan style\\x3d\"font-weight:bold\"\\x3e').replace(/<(i|em)>/g, '\\x3cspan style\\x3d\"font-style:italic\"\\x3e'), k = k.replace(/<a/g, \"\\x3cspan\").replace(/<\\/(b|strong|i|em|a)>/g, \"\\x3c/span\\x3e\").split(/<br.*?>/g)) : k = [k], k = k.filter(function (a) {\n            return \"\" !== a;\n          }), k.forEach(function (k, e) {\n            var c,\n                u = 0,\n                p = 0;\n            k = k.replace(/^\\s+|\\s+$/g, \"\").replace(/<span/g, \"|||\\x3cspan\").replace(/<\\/span>/g, \"\\x3c/span\\x3e|||\");\n            c = k.split(\"|||\");\n            c.forEach(function (k) {\n              if (\"\" !== k || 1 === c.length) {\n                var h = {},\n                    f = r.createElementNS(q.SVG_NS, \"tspan\"),\n                    D,\n                    G;\n                (D = M(k, \"class\")) && g(f, \"class\", D);\n                if (D = M(k, \"style\")) D = D.replace(/(;| |^)color([ :])/, \"$1fill$2\"), g(f, \"style\", D);\n                (G = M(k, \"href\")) && !b && (g(f, \"onclick\", 'location.href\\x3d\"' + G + '\"'), g(f, \"class\", \"highcharts-anchor\"), q.styledMode || y(f, {\n                  cursor: \"pointer\"\n                }));\n                k = m(k.replace(/<[a-zA-Z\\/](.|\\n)*?>/g, \"\") || \" \");\n\n                if (\" \" !== k) {\n                  f.appendChild(r.createTextNode(k));\n                  u ? h.dx = 0 : e && null !== t && (h.x = t);\n                  g(f, h);\n                  d.appendChild(f);\n                  !u && N && (!O && b && y(f, {\n                    display: \"block\"\n                  }), g(f, \"dy\", B(f)));\n\n                  if (K) {\n                    var F = k.replace(/([^\\^])-/g, \"$1- \").split(\" \"),\n                        h = !n && (1 < c.length || e || 1 < F.length);\n                    G = 0;\n                    var R = B(f);\n                    if (w) l = q.truncate(a, f, k, void 0, 0, Math.max(0, K - parseInt(J || 12, 10)), function (a, d) {\n                      return a.substring(0, d) + \"\\u2026\";\n                    });else if (h) for (; F.length;) F.length && !n && 0 < G && (f = r.createElementNS(L, \"tspan\"), g(f, {\n                      dy: R,\n                      x: t\n                    }), D && g(f, \"style\", D), f.appendChild(r.createTextNode(F.join(\" \").replace(/- /g, \"-\"))), d.appendChild(f)), q.truncate(a, f, null, F, 0 === G ? p : 0, K, function (a, d) {\n                      return F.slice(0, d).join(\" \").replace(/- /g, \"-\");\n                    }), p = a.actualWidth, G++;\n                  }\n\n                  u++;\n                }\n              }\n            });\n            N = N || d.childNodes.length;\n          }), w && l && a.attr(\"title\", m(a.textStr, [\"\\x26lt;\", \"\\x26gt;\"])), p && p.removeChild(d), f && a.applyTextOutline && a.applyTextOutline(f)) : d.appendChild(r.createTextNode(m(k)));\n        }\n      },\n      getContrast: function (a) {\n        a = x(a).rgba;\n        a[0] *= 1;\n        a[1] *= 1.2;\n        a[2] *= .5;\n        return 459 < a[0] + a[1] + a[2] ? \"#000000\" : \"#FFFFFF\";\n      },\n      button: function (a, q, b, k, c, l, u, t, p, K) {\n        var h = this.label(a, q, b, p, null, null, K, null, \"button\"),\n            f = 0,\n            D = this.styledMode;\n        h.attr(d({\n          padding: 8,\n          r: 2\n        }, c));\n\n        if (!D) {\n          var r, w, n, G;\n          c = d({\n            fill: \"#f7f7f7\",\n            stroke: \"#cccccc\",\n            \"stroke-width\": 1,\n            style: {\n              color: \"#333333\",\n              cursor: \"pointer\",\n              fontWeight: \"normal\"\n            }\n          }, c);\n          r = c.style;\n          delete c.style;\n          l = d(c, {\n            fill: \"#e6e6e6\"\n          }, l);\n          w = l.style;\n          delete l.style;\n          u = d(c, {\n            fill: \"#e6ebf5\",\n            style: {\n              color: \"#000000\",\n              fontWeight: \"bold\"\n            }\n          }, u);\n          n = u.style;\n          delete u.style;\n          t = d(c, {\n            style: {\n              color: \"#cccccc\"\n            }\n          }, t);\n          G = t.style;\n          delete t.style;\n        }\n\n        E(h.element, F ? \"mouseover\" : \"mouseenter\", function () {\n          3 !== f && h.setState(1);\n        });\n        E(h.element, F ? \"mouseout\" : \"mouseleave\", function () {\n          3 !== f && h.setState(f);\n        });\n\n        h.setState = function (a) {\n          1 !== a && (h.state = f = a);\n          h.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass(\"highcharts-button-\" + [\"normal\", \"hover\", \"pressed\", \"disabled\"][a || 0]);\n          D || h.attr([c, l, u, t][a || 0]).css([r, w, n, G][a || 0]);\n        };\n\n        D || h.attr(c).css(e({\n          cursor: \"default\"\n        }, r));\n        return h.on(\"click\", function (a) {\n          3 !== f && k.call(h, a);\n        });\n      },\n      crispLine: function (a, d) {\n        a[1] === a[4] && (a[1] = a[4] = Math.round(a[1]) - d % 2 / 2);\n        a[2] === a[5] && (a[2] = a[5] = Math.round(a[2]) + d % 2 / 2);\n        return a;\n      },\n      path: function (a) {\n        var d = this.styledMode ? {} : {\n          fill: \"none\"\n        };\n        c(a) ? d.d = a : w(a) && e(d, a);\n        return this.createElement(\"path\").attr(d);\n      },\n      circle: function (a, d, q) {\n        a = w(a) ? a : void 0 === a ? {} : {\n          x: a,\n          y: d,\n          r: q\n        };\n        d = this.createElement(\"circle\");\n\n        d.xSetter = d.ySetter = function (a, d, q) {\n          q.setAttribute(\"c\" + d, a);\n        };\n\n        return d.attr(a);\n      },\n      arc: function (a, d, q, b, k, e) {\n        w(a) ? (b = a, d = b.y, q = b.r, a = b.x) : b = {\n          innerR: b,\n          start: k,\n          end: e\n        };\n        a = this.symbol(\"arc\", a, d, q, q, b);\n        a.r = q;\n        return a;\n      },\n      rect: function (a, d, q, b, k, e) {\n        k = w(a) ? a.r : k;\n        var c = this.createElement(\"rect\");\n        a = w(a) ? a : void 0 === a ? {} : {\n          x: a,\n          y: d,\n          width: Math.max(q, 0),\n          height: Math.max(b, 0)\n        };\n        this.styledMode || (void 0 !== e && (a.strokeWidth = e, a = c.crisp(a)), a.fill = \"none\");\n        k && (a.r = k);\n\n        c.rSetter = function (a, d, q) {\n          c.r = a;\n          g(q, {\n            rx: a,\n            ry: a\n          });\n        };\n\n        c.rGetter = function () {\n          return c.r;\n        };\n\n        return c.attr(a);\n      },\n      setSize: function (a, d, q) {\n        var b = this.alignedObjects,\n            k = b.length;\n        this.width = a;\n        this.height = d;\n\n        for (this.boxWrapper.animate({\n          width: a,\n          height: d\n        }, {\n          step: function () {\n            this.attr({\n              viewBox: \"0 0 \" + this.attr(\"width\") + \" \" + this.attr(\"height\")\n            });\n          },\n          duration: D(q, !0) ? void 0 : 0\n        }); k--;) b[k].align();\n      },\n      g: function (a) {\n        var d = this.createElement(\"g\");\n        return a ? d.attr({\n          \"class\": \"highcharts-\" + a\n        }) : d;\n      },\n      image: function (a, d, q, b, k, c) {\n        var l = {\n          preserveAspectRatio: \"none\"\n        },\n            u,\n            t = function (a, d) {\n          a.setAttributeNS ? a.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", d) : a.setAttribute(\"hc-svg-href\", d);\n        },\n            p = function (d) {\n          t(u.element, a);\n          c.call(u, d);\n        };\n\n        1 < arguments.length && e(l, {\n          x: d,\n          y: q,\n          width: b,\n          height: k\n        });\n        u = this.createElement(\"image\").attr(l);\n        c ? (t(u.element, \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw\\x3d\\x3d\"), l = new M.Image(), E(l, \"load\", p), l.src = a, l.complete && p({})) : t(u.element, a);\n        return u;\n      },\n      symbol: function (a, d, q, b, k, c) {\n        var l = this,\n            u,\n            t = /^url\\((.*?)\\)$/,\n            p = t.test(a),\n            K = !p && (this.symbols[a] ? a : \"circle\"),\n            h = K && this.symbols[K],\n            f = n(d) && h && h.call(this.symbols, Math.round(d), Math.round(q), b, k, c),\n            w,\n            G;\n        h ? (u = this.path(f), l.styledMode || u.attr(\"fill\", \"none\"), e(u, {\n          symbolName: K,\n          x: d,\n          y: q,\n          width: b,\n          height: k\n        }), c && e(u, c)) : p && (w = a.match(t)[1], u = this.image(w), u.imgwidth = D(R[w] && R[w].width, c && c.width), u.imgheight = D(R[w] && R[w].height, c && c.height), G = function () {\n          u.attr({\n            width: u.width,\n            height: u.height\n          });\n        }, [\"width\", \"height\"].forEach(function (a) {\n          u[a + \"Setter\"] = function (a, d) {\n            var q = {},\n                b = this[\"img\" + d],\n                k = \"width\" === d ? \"translateX\" : \"translateY\";\n            this[d] = a;\n            n(b) && (c && \"within\" === c.backgroundSize && this.width && this.height && (b = Math.round(b * Math.min(this.width / this.imgwidth, this.height / this.imgheight))), this.element && this.element.setAttribute(d, b), this.alignByTranslate || (q[k] = ((this[d] || 0) - b) / 2, this.attr(q)));\n          };\n        }), n(d) && u.attr({\n          x: d,\n          y: q\n        }), u.isImg = !0, n(u.imgwidth) && n(u.imgheight) ? G() : (u.attr({\n          width: 0,\n          height: 0\n        }), z(\"img\", {\n          onload: function () {\n            var a = v[l.chartIndex];\n            0 === this.width && (y(this, {\n              position: \"absolute\",\n              top: \"-999em\"\n            }), r.body.appendChild(this));\n            R[w] = {\n              width: this.width,\n              height: this.height\n            };\n            u.imgwidth = this.width;\n            u.imgheight = this.height;\n            u.element && G();\n            this.parentNode && this.parentNode.removeChild(this);\n            l.imgCount--;\n            if (!l.imgCount && a && a.onload) a.onload();\n          },\n          src: w\n        }), this.imgCount++));\n        return u;\n      },\n      symbols: {\n        circle: function (a, d, q, b) {\n          return this.arc(a + q / 2, d + b / 2, q / 2, b / 2, {\n            start: .5 * Math.PI,\n            end: 2.5 * Math.PI,\n            open: !1\n          });\n        },\n        square: function (a, d, q, b) {\n          return [\"M\", a, d, \"L\", a + q, d, a + q, d + b, a, d + b, \"Z\"];\n        },\n        triangle: function (a, d, q, b) {\n          return [\"M\", a + q / 2, d, \"L\", a + q, d + b, a, d + b, \"Z\"];\n        },\n        \"triangle-down\": function (a, d, q, b) {\n          return [\"M\", a, d, \"L\", a + q, d, a + q / 2, d + b, \"Z\"];\n        },\n        diamond: function (a, d, q, b) {\n          return [\"M\", a + q / 2, d, \"L\", a + q, d + b / 2, a + q / 2, d + b, a, d + b / 2, \"Z\"];\n        },\n        arc: function (a, d, q, b, k) {\n          var e = k.start,\n              c = k.r || q,\n              u = k.r || b || q,\n              l = k.end - .001;\n          q = k.innerR;\n          b = D(k.open, .001 > Math.abs(k.end - k.start - 2 * Math.PI));\n          var t = Math.cos(e),\n              p = Math.sin(e),\n              K = Math.cos(l),\n              l = Math.sin(l),\n              e = .001 > k.end - e - Math.PI ? 0 : 1;\n          k = [\"M\", a + c * t, d + u * p, \"A\", c, u, 0, e, D(k.clockwise, 1), a + c * K, d + u * l];\n          n(q) && k.push(b ? \"M\" : \"L\", a + q * K, d + q * l, \"A\", q, q, 0, e, 0, a + q * t, d + q * p);\n          k.push(b ? \"\" : \"Z\");\n          return k;\n        },\n        callout: function (a, d, q, b, k) {\n          var e = Math.min(k && k.r || 0, q, b),\n              c = e + 6,\n              u = k && k.anchorX;\n          k = k && k.anchorY;\n          var l;\n          l = [\"M\", a + e, d, \"L\", a + q - e, d, \"C\", a + q, d, a + q, d, a + q, d + e, \"L\", a + q, d + b - e, \"C\", a + q, d + b, a + q, d + b, a + q - e, d + b, \"L\", a + e, d + b, \"C\", a, d + b, a, d + b, a, d + b - e, \"L\", a, d + e, \"C\", a, d, a, d, a + e, d];\n          u && u > q ? k > d + c && k < d + b - c ? l.splice(13, 3, \"L\", a + q, k - 6, a + q + 6, k, a + q, k + 6, a + q, d + b - e) : l.splice(13, 3, \"L\", a + q, b / 2, u, k, a + q, b / 2, a + q, d + b - e) : u && 0 > u ? k > d + c && k < d + b - c ? l.splice(33, 3, \"L\", a, k + 6, a - 6, k, a, k - 6, a, d + e) : l.splice(33, 3, \"L\", a, b / 2, u, k, a, b / 2, a, d + e) : k && k > b && u > a + c && u < a + q - c ? l.splice(23, 3, \"L\", u + 6, d + b, u, d + b + 6, u - 6, d + b, a + e, d + b) : k && 0 > k && u > a + c && u < a + q - c && l.splice(3, 3, \"L\", u - 6, d, u, d - 6, u + 6, d, q - e, d);\n          return l;\n        }\n      },\n      clipRect: function (d, q, b, k) {\n        var e = a.uniqueKey() + \"-\",\n            c = this.createElement(\"clipPath\").attr({\n          id: e\n        }).add(this.defs);\n        d = this.rect(d, q, b, k, 0).add(c);\n        d.id = e;\n        d.clipPath = c;\n        d.count = 0;\n        return d;\n      },\n      text: function (a, d, q, b) {\n        var k = {};\n        if (b && (this.allowHTML || !this.forExport)) return this.html(a, d, q);\n        k.x = Math.round(d || 0);\n        q && (k.y = Math.round(q));\n        n(a) && (k.text = a);\n        a = this.createElement(\"text\").attr(k);\n        b || (a.xSetter = function (a, d, q) {\n          var b = q.getElementsByTagName(\"tspan\"),\n              k,\n              e = q.getAttribute(d),\n              c;\n\n          for (c = 0; c < b.length; c++) k = b[c], k.getAttribute(d) === e && k.setAttribute(d, a);\n\n          q.setAttribute(d, a);\n        });\n        return a;\n      },\n      fontMetrics: function (a, d) {\n        a = !this.styledMode && /px/.test(a) || !M.getComputedStyle ? a || d && d.style && d.style.fontSize || this.style && this.style.fontSize : d && C.prototype.getStyle.call(d, \"font-size\");\n        a = /px/.test(a) ? G(a) : 12;\n        d = 24 > a ? a + 3 : Math.round(1.2 * a);\n        return {\n          h: d,\n          b: Math.round(.8 * d),\n          f: a\n        };\n      },\n      rotCorr: function (a, d, q) {\n        var b = a;\n        d && q && (b = Math.max(b * Math.cos(d * f), 4));\n        return {\n          x: -a / 3 * Math.sin(d * f),\n          y: b\n        };\n      },\n      label: function (b, k, c, u, l, t, p, K, h) {\n        var f = this,\n            D = f.styledMode,\n            w = f.g(\"button\" !== h && \"label\"),\n            r = w.text = f.text(\"\", 0, 0, p).attr({\n          zIndex: 1\n        }),\n            G,\n            L,\n            O = 0,\n            F = 3,\n            g = 0,\n            N,\n            R,\n            B,\n            m,\n            J,\n            M = {},\n            z,\n            v,\n            x = /^url\\((.*?)\\)$/.test(u),\n            y = D || x,\n            da = function () {\n          return D ? G.strokeWidth() % 2 / 2 : (z ? parseInt(z, 10) : 0) % 2 / 2;\n        },\n            ba,\n            P,\n            A;\n\n        h && w.addClass(\"highcharts-\" + h);\n\n        ba = function () {\n          var a = r.element.style,\n              d = {};\n          L = (void 0 === N || void 0 === R || J) && n(r.textStr) && r.getBBox();\n          w.width = (N || L.width || 0) + 2 * F + g;\n          w.height = (R || L.height || 0) + 2 * F;\n          v = F + Math.min(f.fontMetrics(a && a.fontSize, r).b, L ? L.height : Infinity);\n          y && (G || (w.box = G = f.symbols[u] || x ? f.symbol(u) : f.rect(), G.addClass((\"button\" === h ? \"\" : \"highcharts-label-box\") + (h ? \" highcharts-\" + h + \"-box\" : \"\")), G.add(w), a = da(), d.x = a, d.y = (K ? -v : 0) + a), d.width = Math.round(w.width), d.height = Math.round(w.height), G.attr(e(d, M)), M = {});\n        };\n\n        P = function () {\n          var a = g + F,\n              d;\n          d = K ? 0 : v;\n          n(N) && L && (\"center\" === J || \"right\" === J) && (a += {\n            center: .5,\n            right: 1\n          }[J] * (N - L.width));\n          if (a !== r.x || d !== r.y) r.attr(\"x\", a), r.hasBoxWidthChanged && (L = r.getBBox(!0), ba()), void 0 !== d && r.attr(\"y\", d);\n          r.x = a;\n          r.y = d;\n        };\n\n        A = function (a, d) {\n          G ? G.attr(a, d) : M[a] = d;\n        };\n\n        w.onAdd = function () {\n          r.add(w);\n          w.attr({\n            text: b || 0 === b ? b : \"\",\n            x: k,\n            y: c\n          });\n          G && n(l) && w.attr({\n            anchorX: l,\n            anchorY: t\n          });\n        };\n\n        w.widthSetter = function (d) {\n          N = a.isNumber(d) ? d : null;\n        };\n\n        w.heightSetter = function (a) {\n          R = a;\n        };\n\n        w[\"text-alignSetter\"] = function (a) {\n          J = a;\n        };\n\n        w.paddingSetter = function (a) {\n          n(a) && a !== F && (F = w.padding = a, P());\n        };\n\n        w.paddingLeftSetter = function (a) {\n          n(a) && a !== g && (g = a, P());\n        };\n\n        w.alignSetter = function (a) {\n          a = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[a];\n          a !== O && (O = a, L && w.attr({\n            x: B\n          }));\n        };\n\n        w.textSetter = function (a) {\n          void 0 !== a && r.attr({\n            text: a\n          });\n          ba();\n          P();\n        };\n\n        w[\"stroke-widthSetter\"] = function (a, d) {\n          a && (y = !0);\n          z = this[\"stroke-width\"] = a;\n          A(d, a);\n        };\n\n        D ? w.rSetter = function (a, d) {\n          A(d, a);\n        } : w.strokeSetter = w.fillSetter = w.rSetter = function (a, d) {\n          \"r\" !== d && (\"fill\" === d && a && (y = !0), w[d] = a);\n          A(d, a);\n        };\n\n        w.anchorXSetter = function (a, d) {\n          l = w.anchorX = a;\n          A(d, Math.round(a) - da() - B);\n        };\n\n        w.anchorYSetter = function (a, d) {\n          t = w.anchorY = a;\n          A(d, a - m);\n        };\n\n        w.xSetter = function (a) {\n          w.x = a;\n          O && (a -= O * ((N || L.width) + 2 * F), w[\"forceAnimate:x\"] = !0);\n          B = Math.round(a);\n          w.attr(\"translateX\", B);\n        };\n\n        w.ySetter = function (a) {\n          m = w.y = Math.round(a);\n          w.attr(\"translateY\", m);\n        };\n\n        var S = w.css;\n        p = {\n          css: function (a) {\n            if (a) {\n              var q = {};\n              a = d(a);\n              w.textProps.forEach(function (d) {\n                void 0 !== a[d] && (q[d] = a[d], delete a[d]);\n              });\n              r.css(q);\n              \"width\" in q && ba();\n              \"fontSize\" in q && (ba(), P());\n            }\n\n            return S.call(w, a);\n          },\n          getBBox: function () {\n            return {\n              width: L.width + 2 * F,\n              height: L.height + 2 * F,\n              x: L.x - F,\n              y: L.y - F\n            };\n          },\n          destroy: function () {\n            q(w.element, \"mouseenter\");\n            q(w.element, \"mouseleave\");\n            r && (r = r.destroy());\n            G && (G = G.destroy());\n            C.prototype.destroy.call(w);\n            w = f = ba = P = A = null;\n          }\n        };\n        D || (p.shadow = function (a) {\n          a && (ba(), G && G.shadow(a));\n          return w;\n        });\n        return e(w, p);\n      }\n    });\n    a.Renderer = A;\n  });\n  I(H, \"parts/Html.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.attr,\n        A = a.createElement,\n        E = a.css,\n        m = a.defined,\n        g = a.extend,\n        v = a.isFirefox,\n        x = a.isMS,\n        y = a.isWebKit,\n        z = a.pick,\n        n = a.pInt,\n        f = a.SVGElement,\n        h = a.SVGRenderer,\n        r = a.win;\n    g(f.prototype, {\n      htmlCss: function (a) {\n        var b = \"SPAN\" === this.element.tagName && a && \"width\" in a,\n            e = z(b && a.width, void 0),\n            c;\n        b && (delete a.width, this.textWidth = e, c = !0);\n        a && \"ellipsis\" === a.textOverflow && (a.whiteSpace = \"nowrap\", a.overflow = \"hidden\");\n        this.styles = g(this.styles, a);\n        E(this.element, a);\n        c && this.htmlUpdateTransform();\n        return this;\n      },\n      htmlGetBBox: function () {\n        var a = this.element;\n        return {\n          x: a.offsetLeft,\n          y: a.offsetTop,\n          width: a.offsetWidth,\n          height: a.offsetHeight\n        };\n      },\n      htmlUpdateTransform: function () {\n        if (this.added) {\n          var a = this.renderer,\n              b = this.element,\n              l = this.translateX || 0,\n              c = this.translateY || 0,\n              t = this.x || 0,\n              h = this.y || 0,\n              f = this.textAlign || \"left\",\n              r = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[f],\n              p = this.styles,\n              d = p && p.whiteSpace;\n          E(b, {\n            marginLeft: l,\n            marginTop: c\n          });\n          !a.styledMode && this.shadows && this.shadows.forEach(function (a) {\n            E(a, {\n              marginLeft: l + 1,\n              marginTop: c + 1\n            });\n          });\n          this.inverted && [].forEach.call(b.childNodes, function (d) {\n            a.invertChild(d, b);\n          });\n\n          if (\"SPAN\" === b.tagName) {\n            var p = this.rotation,\n                k = this.textWidth && n(this.textWidth),\n                u = [p, f, b.innerHTML, this.textWidth, this.textAlign].join(),\n                D;\n            (D = k !== this.oldTextWidth) && !(D = k > this.oldTextWidth) && ((D = this.textPxLength) || (E(b, {\n              width: \"\",\n              whiteSpace: d || \"nowrap\"\n            }), D = b.offsetWidth), D = D > k);\n            D && (/[ \\-]/.test(b.textContent || b.innerText) || \"ellipsis\" === b.style.textOverflow) ? (E(b, {\n              width: k + \"px\",\n              display: \"block\",\n              whiteSpace: d || \"normal\"\n            }), this.oldTextWidth = k, this.hasBoxWidthChanged = !0) : this.hasBoxWidthChanged = !1;\n            u !== this.cTT && (d = a.fontMetrics(b.style.fontSize, b).b, !m(p) || p === (this.oldRotation || 0) && f === this.oldAlign || this.setSpanRotation(p, r, d), this.getSpanCorrection(!m(p) && this.textPxLength || b.offsetWidth, d, r, p, f));\n            E(b, {\n              left: t + (this.xCorr || 0) + \"px\",\n              top: h + (this.yCorr || 0) + \"px\"\n            });\n            this.cTT = u;\n            this.oldRotation = p;\n            this.oldAlign = f;\n          }\n        } else this.alignOnAdd = !0;\n      },\n      setSpanRotation: function (a, b, l) {\n        var c = {},\n            e = this.renderer.getTransformKey();\n        c[e] = c.transform = \"rotate(\" + a + \"deg)\";\n        c[e + (v ? \"Origin\" : \"-origin\")] = c.transformOrigin = 100 * b + \"% \" + l + \"px\";\n        E(this.element, c);\n      },\n      getSpanCorrection: function (a, b, l) {\n        this.xCorr = -a * l;\n        this.yCorr = -b;\n      }\n    });\n    g(h.prototype, {\n      getTransformKey: function () {\n        return x && !/Edge/.test(r.navigator.userAgent) ? \"-ms-transform\" : y ? \"-webkit-transform\" : v ? \"MozTransform\" : r.opera ? \"-o-transform\" : \"\";\n      },\n      html: function (e, b, l) {\n        var c = this.createElement(\"span\"),\n            t = c.element,\n            h = c.renderer,\n            w = h.isSVG,\n            r = function (a, b) {\n          [\"opacity\", \"visibility\"].forEach(function (d) {\n            a[d + \"Setter\"] = function (k, c, q) {\n              var e = a.div ? a.div.style : b;\n              f.prototype[d + \"Setter\"].call(this, k, c, q);\n              e && (e[c] = k);\n            };\n          });\n          a.addedSetters = !0;\n        },\n            p = a.charts[h.chartIndex],\n            p = p && p.styledMode;\n\n        c.textSetter = function (a) {\n          a !== t.innerHTML && (delete this.bBox, delete this.oldTextWidth);\n          this.textStr = a;\n          t.innerHTML = z(a, \"\");\n          c.doTransform = !0;\n        };\n\n        w && r(c, c.element.style);\n\n        c.xSetter = c.ySetter = c.alignSetter = c.rotationSetter = function (a, b) {\n          \"align\" === b && (b = \"textAlign\");\n          c[b] = a;\n          c.doTransform = !0;\n        };\n\n        c.afterSetters = function () {\n          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);\n        };\n\n        c.attr({\n          text: e,\n          x: Math.round(b),\n          y: Math.round(l)\n        }).css({\n          position: \"absolute\"\n        });\n        p || c.css({\n          fontFamily: this.style.fontFamily,\n          fontSize: this.style.fontSize\n        });\n        t.style.whiteSpace = \"nowrap\";\n        c.css = c.htmlCss;\n        w && (c.add = function (a) {\n          var d,\n              b = h.box.parentNode,\n              e = [];\n\n          if (this.parentGroup = a) {\n            if (d = a.div, !d) {\n              for (; a;) e.push(a), a = a.parentGroup;\n\n              e.reverse().forEach(function (a) {\n                function q(d, q) {\n                  a[q] = d;\n                  \"translateX\" === q ? k.left = d + \"px\" : k.top = d + \"px\";\n                  a.doTransform = !0;\n                }\n\n                var k,\n                    u = C(a.element, \"class\");\n                u && (u = {\n                  className: u\n                });\n                d = a.div = a.div || A(\"div\", u, {\n                  position: \"absolute\",\n                  left: (a.translateX || 0) + \"px\",\n                  top: (a.translateY || 0) + \"px\",\n                  display: a.display,\n                  opacity: a.opacity,\n                  pointerEvents: a.styles && a.styles.pointerEvents\n                }, d || b);\n                k = d.style;\n                g(a, {\n                  classSetter: function (a) {\n                    return function (d) {\n                      this.element.setAttribute(\"class\", d);\n                      a.className = d;\n                    };\n                  }(d),\n                  on: function () {\n                    e[0].div && c.on.apply({\n                      element: e[0].div\n                    }, arguments);\n                    return a;\n                  },\n                  translateXSetter: q,\n                  translateYSetter: q\n                });\n                a.addedSetters || r(a);\n              });\n            }\n          } else d = b;\n\n          d.appendChild(t);\n          c.added = !0;\n          c.alignOnAdd && c.htmlUpdateTransform();\n          return c;\n        });\n        return c;\n      }\n    });\n  });\n  I(H, \"parts/Time.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.defined,\n        A = a.extend,\n        E = a.merge,\n        m = a.pick,\n        g = a.timeUnits,\n        v = a.win;\n\n    a.Time = function (a) {\n      this.update(a, !1);\n    };\n\n    a.Time.prototype = {\n      defaultOptions: {},\n      update: function (a) {\n        var g = m(a && a.useUTC, !0),\n            z = this;\n        this.options = a = E(!0, this.options || {}, a);\n        this.Date = a.Date || v.Date || Date;\n        this.timezoneOffset = (this.useUTC = g) && a.timezoneOffset;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        (this.variableTimezone = !(g && !a.getTimezoneOffset && !a.timezone)) || this.timezoneOffset ? (this.get = function (a, f) {\n          var h = f.getTime(),\n              r = h - z.getTimezoneOffset(f);\n          f.setTime(r);\n          a = f[\"getUTC\" + a]();\n          f.setTime(h);\n          return a;\n        }, this.set = function (a, f, h) {\n          var r;\n          if (\"Milliseconds\" === a || \"Seconds\" === a || \"Minutes\" === a && 0 === f.getTimezoneOffset() % 60) f[\"set\" + a](h);else r = z.getTimezoneOffset(f), r = f.getTime() - r, f.setTime(r), f[\"setUTC\" + a](h), a = z.getTimezoneOffset(f), r = f.getTime() + a, f.setTime(r);\n        }) : g ? (this.get = function (a, f) {\n          return f[\"getUTC\" + a]();\n        }, this.set = function (a, f, h) {\n          return f[\"setUTC\" + a](h);\n        }) : (this.get = function (a, f) {\n          return f[\"get\" + a]();\n        }, this.set = function (a, f, h) {\n          return f[\"set\" + a](h);\n        });\n      },\n      makeTime: function (g, v, z, n, f, h) {\n        var r, e, b;\n        this.useUTC ? (r = this.Date.UTC.apply(0, arguments), e = this.getTimezoneOffset(r), r += e, b = this.getTimezoneOffset(r), e !== b ? r += b - e : e - 36E5 !== this.getTimezoneOffset(r - 36E5) || a.isSafari || (r -= 36E5)) : r = new this.Date(g, v, m(z, 1), m(n, 0), m(f, 0), m(h, 0)).getTime();\n        return r;\n      },\n      timezoneOffsetFunction: function () {\n        var g = this,\n            m = this.options,\n            z = v.moment;\n        if (!this.useUTC) return function (a) {\n          return 6E4 * new Date(a).getTimezoneOffset();\n        };\n\n        if (m.timezone) {\n          if (z) return function (a) {\n            return 6E4 * -z.tz(a, m.timezone).utcOffset();\n          };\n          a.error(25);\n        }\n\n        return this.useUTC && m.getTimezoneOffset ? function (a) {\n          return 6E4 * m.getTimezoneOffset(a);\n        } : function () {\n          return 6E4 * (g.timezoneOffset || 0);\n        };\n      },\n      dateFormat: function (g, m, v) {\n        if (!a.defined(m) || isNaN(m)) return a.defaultOptions.lang.invalidDate || \"\";\n        g = a.pick(g, \"%Y-%m-%d %H:%M:%S\");\n        var n = this,\n            f = new this.Date(m),\n            h = this.get(\"Hours\", f),\n            r = this.get(\"Day\", f),\n            e = this.get(\"Date\", f),\n            b = this.get(\"Month\", f),\n            l = this.get(\"FullYear\", f),\n            c = a.defaultOptions.lang,\n            t = c.weekdays,\n            F = c.shortWeekdays,\n            w = a.pad,\n            f = a.extend({\n          a: F ? F[r] : t[r].substr(0, 3),\n          A: t[r],\n          d: w(e),\n          e: w(e, 2, \" \"),\n          w: r,\n          b: c.shortMonths[b],\n          B: c.months[b],\n          m: w(b + 1),\n          o: b + 1,\n          y: l.toString().substr(2, 2),\n          Y: l,\n          H: w(h),\n          k: h,\n          I: w(h % 12 || 12),\n          l: h % 12 || 12,\n          M: w(n.get(\"Minutes\", f)),\n          p: 12 > h ? \"AM\" : \"PM\",\n          P: 12 > h ? \"am\" : \"pm\",\n          S: w(f.getSeconds()),\n          L: w(Math.floor(m % 1E3), 3)\n        }, a.dateFormats);\n        a.objectEach(f, function (a, b) {\n          for (; -1 !== g.indexOf(\"%\" + b);) g = g.replace(\"%\" + b, \"function\" === typeof a ? a.call(n, m) : a);\n        });\n        return v ? g.substr(0, 1).toUpperCase() + g.substr(1) : g;\n      },\n      resolveDTLFormat: function (g) {\n        return a.isObject(g, !0) ? g : (g = a.splat(g), {\n          main: g[0],\n          from: g[1],\n          to: g[2]\n        });\n      },\n      getTimeTicks: function (a, v, z, n) {\n        var f = this,\n            h = [],\n            r,\n            e = {},\n            b;\n        r = new f.Date(v);\n        var l = a.unitRange,\n            c = a.count || 1,\n            t;\n        n = m(n, 1);\n\n        if (C(v)) {\n          f.set(\"Milliseconds\", r, l >= g.second ? 0 : c * Math.floor(f.get(\"Milliseconds\", r) / c));\n          l >= g.second && f.set(\"Seconds\", r, l >= g.minute ? 0 : c * Math.floor(f.get(\"Seconds\", r) / c));\n          l >= g.minute && f.set(\"Minutes\", r, l >= g.hour ? 0 : c * Math.floor(f.get(\"Minutes\", r) / c));\n          l >= g.hour && f.set(\"Hours\", r, l >= g.day ? 0 : c * Math.floor(f.get(\"Hours\", r) / c));\n          l >= g.day && f.set(\"Date\", r, l >= g.month ? 1 : Math.max(1, c * Math.floor(f.get(\"Date\", r) / c)));\n          l >= g.month && (f.set(\"Month\", r, l >= g.year ? 0 : c * Math.floor(f.get(\"Month\", r) / c)), b = f.get(\"FullYear\", r));\n          l >= g.year && f.set(\"FullYear\", r, b - b % c);\n          l === g.week && (b = f.get(\"Day\", r), f.set(\"Date\", r, f.get(\"Date\", r) - b + n + (b < n ? -7 : 0)));\n          b = f.get(\"FullYear\", r);\n          n = f.get(\"Month\", r);\n          var F = f.get(\"Date\", r),\n              w = f.get(\"Hours\", r);\n          v = r.getTime();\n          f.variableTimezone && (t = z - v > 4 * g.month || f.getTimezoneOffset(v) !== f.getTimezoneOffset(z));\n          v = r.getTime();\n\n          for (r = 1; v < z;) h.push(v), v = l === g.year ? f.makeTime(b + r * c, 0) : l === g.month ? f.makeTime(b, n + r * c) : !t || l !== g.day && l !== g.week ? t && l === g.hour && 1 < c ? f.makeTime(b, n, F, w + r * c) : v + l * c : f.makeTime(b, n, F + r * c * (l === g.day ? 1 : 7)), r++;\n\n          h.push(v);\n          l <= g.hour && 1E4 > h.length && h.forEach(function (a) {\n            0 === a % 18E5 && \"000000000\" === f.dateFormat(\"%H%M%S%L\", a) && (e[a] = \"day\");\n          });\n        }\n\n        h.info = A(a, {\n          higherRanks: e,\n          totalRange: l * c\n        });\n        return h;\n      }\n    };\n  });\n  I(H, \"parts/Options.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.color,\n        A = a.merge;\n    a.defaultOptions = {\n      colors: \"#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1\".split(\" \"),\n      symbols: [\"circle\", \"diamond\", \"square\", \"triangle\", \"triangle-down\"],\n      lang: {\n        loading: \"Loading...\",\n        months: \"January February March April May June July August September October November December\".split(\" \"),\n        shortMonths: \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"),\n        weekdays: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n        decimalPoint: \".\",\n        numericSymbols: \"kMGTPE\".split(\"\"),\n        resetZoom: \"Reset zoom\",\n        resetZoomTitle: \"Reset zoom level 1:1\",\n        thousandsSep: \" \"\n      },\n      global: {},\n      time: a.Time.prototype.defaultOptions,\n      chart: {\n        styledMode: !1,\n        borderRadius: 0,\n        colorCount: 10,\n        defaultSeriesType: \"line\",\n        ignoreHiddenSeries: !0,\n        spacing: [10, 10, 15, 10],\n        resetZoomButton: {\n          theme: {\n            zIndex: 6\n          },\n          position: {\n            align: \"right\",\n            x: -10,\n            y: 10\n          }\n        },\n        width: null,\n        height: null,\n        borderColor: \"#335cad\",\n        backgroundColor: \"#ffffff\",\n        plotBorderColor: \"#cccccc\"\n      },\n      title: {\n        text: \"Chart title\",\n        align: \"center\",\n        margin: 15,\n        widthAdjust: -44\n      },\n      subtitle: {\n        text: \"\",\n        align: \"center\",\n        widthAdjust: -44\n      },\n      plotOptions: {},\n      labels: {\n        style: {\n          position: \"absolute\",\n          color: \"#333333\"\n        }\n      },\n      legend: {\n        enabled: !0,\n        align: \"center\",\n        alignColumns: !0,\n        layout: \"horizontal\",\n        labelFormatter: function () {\n          return this.name;\n        },\n        borderColor: \"#999999\",\n        borderRadius: 0,\n        navigation: {\n          activeColor: \"#003399\",\n          inactiveColor: \"#cccccc\"\n        },\n        itemStyle: {\n          color: \"#333333\",\n          cursor: \"pointer\",\n          fontSize: \"12px\",\n          fontWeight: \"bold\",\n          textOverflow: \"ellipsis\"\n        },\n        itemHoverStyle: {\n          color: \"#000000\"\n        },\n        itemHiddenStyle: {\n          color: \"#cccccc\"\n        },\n        shadow: !1,\n        itemCheckboxStyle: {\n          position: \"absolute\",\n          width: \"13px\",\n          height: \"13px\"\n        },\n        squareSymbol: !0,\n        symbolPadding: 5,\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0,\n        title: {\n          style: {\n            fontWeight: \"bold\"\n          }\n        }\n      },\n      loading: {\n        labelStyle: {\n          fontWeight: \"bold\",\n          position: \"relative\",\n          top: \"45%\"\n        },\n        style: {\n          position: \"absolute\",\n          backgroundColor: \"#ffffff\",\n          opacity: .5,\n          textAlign: \"center\"\n        }\n      },\n      tooltip: {\n        enabled: !0,\n        animation: a.svg,\n        borderRadius: 3,\n        dateTimeLabelFormats: {\n          millisecond: \"%A, %b %e, %H:%M:%S.%L\",\n          second: \"%A, %b %e, %H:%M:%S\",\n          minute: \"%A, %b %e, %H:%M\",\n          hour: \"%A, %b %e, %H:%M\",\n          day: \"%A, %b %e, %Y\",\n          week: \"Week from %A, %b %e, %Y\",\n          month: \"%B %Y\",\n          year: \"%Y\"\n        },\n        footerFormat: \"\",\n        padding: 8,\n        snap: a.isTouchDevice ? 25 : 10,\n        headerFormat: '\\x3cspan style\\x3d\"font-size: 10px\"\\x3e{point.key}\\x3c/span\\x3e\\x3cbr/\\x3e',\n        pointFormat: '\\x3cspan style\\x3d\"color:{point.color}\"\\x3e\\u25cf\\x3c/span\\x3e {series.name}: \\x3cb\\x3e{point.y}\\x3c/b\\x3e\\x3cbr/\\x3e',\n        backgroundColor: C(\"#f7f7f7\").setOpacity(.85).get(),\n        borderWidth: 1,\n        shadow: !0,\n        style: {\n          color: \"#333333\",\n          cursor: \"default\",\n          fontSize: \"12px\",\n          pointerEvents: \"none\",\n          whiteSpace: \"nowrap\"\n        }\n      },\n      credits: {\n        enabled: !0,\n        href: \"https://www.highcharts.com?credits\",\n        position: {\n          align: \"right\",\n          x: -10,\n          verticalAlign: \"bottom\",\n          y: -5\n        },\n        style: {\n          cursor: \"pointer\",\n          color: \"#999999\",\n          fontSize: \"9px\"\n        },\n        text: \"Highcharts.com\"\n      }\n    };\n\n    a.setOptions = function (C) {\n      a.defaultOptions = A(!0, a.defaultOptions, C);\n      a.time.update(A(a.defaultOptions.global, a.defaultOptions.time), !1);\n      return a.defaultOptions;\n    };\n\n    a.getOptions = function () {\n      return a.defaultOptions;\n    };\n\n    a.defaultPlotOptions = a.defaultOptions.plotOptions;\n    a.time = new a.Time(A(a.defaultOptions.global, a.defaultOptions.time));\n\n    a.dateFormat = function (A, m, g) {\n      return a.time.dateFormat(A, m, g);\n    };\n\n    \"\";\n  });\n  I(H, \"parts/Tick.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.correctFloat,\n        A = a.defined,\n        E = a.destroyObjectProperties,\n        m = a.fireEvent,\n        g = a.isNumber,\n        v = a.merge,\n        x = a.pick,\n        y = a.deg2rad;\n\n    a.Tick = function (a, n, f, h, r) {\n      this.axis = a;\n      this.pos = n;\n      this.type = f || \"\";\n      this.isNewLabel = this.isNew = !0;\n      this.parameters = r || {};\n      this.tickmarkOffset = this.parameters.tickmarkOffset;\n      this.options = this.parameters.options;\n      f || h || this.addLabel();\n    };\n\n    a.Tick.prototype = {\n      addLabel: function () {\n        var g = this,\n            n = g.axis,\n            f = n.options,\n            h = n.chart,\n            r = n.categories,\n            e = n.names,\n            b = g.pos,\n            l = x(g.options && g.options.labels, f.labels),\n            c = n.tickPositions,\n            t = b === c[0],\n            F = b === c[c.length - 1],\n            r = this.parameters.category || (r ? x(r[b], e[b], b) : b),\n            w = g.label,\n            c = c.info,\n            B,\n            p,\n            d,\n            k;\n        n.isDatetimeAxis && c && (p = h.time.resolveDTLFormat(f.dateTimeLabelFormats[!f.grid && c.higherRanks[b] || c.unitName]), B = p.main);\n        g.isFirst = t;\n        g.isLast = F;\n        g.formatCtx = {\n          axis: n,\n          chart: h,\n          isFirst: t,\n          isLast: F,\n          dateTimeLabelFormat: B,\n          tickPositionInfo: c,\n          value: n.isLog ? C(n.lin2log(r)) : r,\n          pos: b\n        };\n        f = n.labelFormatter.call(g.formatCtx, this.formatCtx);\n        if (k = p && p.list) g.shortenLabel = function () {\n          for (d = 0; d < k.length; d++) if (w.attr({\n            text: n.labelFormatter.call(a.extend(g.formatCtx, {\n              dateTimeLabelFormat: k[d]\n            }))\n          }), w.getBBox().width < n.getSlotWidth(g) - 2 * x(l.padding, 5)) return;\n\n          w.attr({\n            text: \"\"\n          });\n        };\n        if (A(w)) w && w.textStr !== f && (!w.textWidth || l.style && l.style.width || w.styles.width || w.css({\n          width: null\n        }), w.attr({\n          text: f\n        }), w.textPxLength = w.getBBox().width);else {\n          if (g.label = w = A(f) && l.enabled ? h.renderer.text(f, 0, 0, l.useHTML).add(n.labelGroup) : null) h.styledMode || w.css(v(l.style)), w.textPxLength = w.getBBox().width;\n          g.rotation = 0;\n        }\n      },\n      getLabelSize: function () {\n        return this.label ? this.label.getBBox()[this.axis.horiz ? \"height\" : \"width\"] : 0;\n      },\n      handleOverflow: function (a) {\n        var n = this.axis,\n            f = n.options.labels,\n            h = a.x,\n            r = n.chart.chartWidth,\n            e = n.chart.spacing,\n            b = x(n.labelLeft, Math.min(n.pos, e[3])),\n            e = x(n.labelRight, Math.max(n.isRadial ? 0 : n.pos + n.len, r - e[1])),\n            l = this.label,\n            c = this.rotation,\n            t = {\n          left: 0,\n          center: .5,\n          right: 1\n        }[n.labelAlign || l.attr(\"align\")],\n            g = l.getBBox().width,\n            w = n.getSlotWidth(this),\n            B = w,\n            p = 1,\n            d,\n            k = {};\n        if (c || \"justify\" !== x(f.overflow, \"justify\")) 0 > c && h - t * g < b ? d = Math.round(h / Math.cos(c * y) - b) : 0 < c && h + t * g > e && (d = Math.round((r - h) / Math.cos(c * y)));else if (r = h + (1 - t) * g, h - t * g < b ? B = a.x + B * (1 - t) - b : r > e && (B = e - a.x + B * t, p = -1), B = Math.min(w, B), B < w && \"center\" === n.labelAlign && (a.x += p * (w - B - t * (w - Math.min(g, B)))), g > B || n.autoRotation && (l.styles || {}).width) d = B;\n        d && (this.shortenLabel ? this.shortenLabel() : (k.width = Math.floor(d), (f.style || {}).textOverflow || (k.textOverflow = \"ellipsis\"), l.css(k)));\n      },\n      getPosition: function (g, n, f, h) {\n        var r = this.axis,\n            e = r.chart,\n            b = h && e.oldChartHeight || e.chartHeight;\n        g = {\n          x: g ? a.correctFloat(r.translate(n + f, null, null, h) + r.transB) : r.left + r.offset + (r.opposite ? (h && e.oldChartWidth || e.chartWidth) - r.right - r.left : 0),\n          y: g ? b - r.bottom + r.offset - (r.opposite ? r.height : 0) : a.correctFloat(b - r.translate(n + f, null, null, h) - r.transB)\n        };\n        g.y = Math.max(Math.min(g.y, 1E5), -1E5);\n        m(this, \"afterGetPosition\", {\n          pos: g\n        });\n        return g;\n      },\n      getLabelPosition: function (a, n, f, h, r, e, b, l) {\n        var c = this.axis,\n            t = c.transA,\n            g = c.reversed,\n            w = c.staggerLines,\n            B = c.tickRotCorr || {\n          x: 0,\n          y: 0\n        },\n            p = r.y,\n            d = h || c.reserveSpaceDefault ? 0 : -c.labelOffset * (\"center\" === c.labelAlign ? .5 : 1),\n            k = {};\n        A(p) || (p = 0 === c.side ? f.rotation ? -8 : -f.getBBox().height : 2 === c.side ? B.y + 8 : Math.cos(f.rotation * y) * (B.y - f.getBBox(!1, 0).height / 2));\n        a = a + r.x + d + B.x - (e && h ? e * t * (g ? -1 : 1) : 0);\n        n = n + p - (e && !h ? e * t * (g ? 1 : -1) : 0);\n        w && (f = b / (l || 1) % w, c.opposite && (f = w - f - 1), n += c.labelOffset / w * f);\n        k.x = a;\n        k.y = Math.round(n);\n        m(this, \"afterGetLabelPosition\", {\n          pos: k,\n          tickmarkOffset: e,\n          index: b\n        });\n        return k;\n      },\n      getMarkPath: function (a, n, f, h, r, e) {\n        return e.crispLine([\"M\", a, n, \"L\", a + (r ? 0 : -f), n + (r ? f : 0)], h);\n      },\n      renderGridLine: function (a, n, f) {\n        var h = this.axis,\n            r = h.options,\n            e = this.gridLine,\n            b = {},\n            l = this.pos,\n            c = this.type,\n            t = x(this.tickmarkOffset, h.tickmarkOffset),\n            g = h.chart.renderer,\n            w = c ? c + \"Grid\" : \"grid\",\n            B = r[w + \"LineWidth\"],\n            p = r[w + \"LineColor\"],\n            r = r[w + \"LineDashStyle\"];\n        e || (h.chart.styledMode || (b.stroke = p, b[\"stroke-width\"] = B, r && (b.dashstyle = r)), c || (b.zIndex = 1), a && (n = 0), this.gridLine = e = g.path().attr(b).addClass(\"highcharts-\" + (c ? c + \"-\" : \"\") + \"grid-line\").add(h.gridGroup));\n        if (e && (f = h.getPlotLinePath({\n          value: l + t,\n          lineWidth: e.strokeWidth() * f,\n          force: \"pass\",\n          old: a\n        }))) e[a || this.isNew ? \"attr\" : \"animate\"]({\n          d: f,\n          opacity: n\n        });\n      },\n      renderMark: function (a, n, f) {\n        var h = this.axis,\n            r = h.options,\n            e = h.chart.renderer,\n            b = this.type,\n            l = b ? b + \"Tick\" : \"tick\",\n            c = h.tickSize(l),\n            t = this.mark,\n            g = !t,\n            w = a.x;\n        a = a.y;\n        var B = x(r[l + \"Width\"], !b && h.isXAxis ? 1 : 0),\n            r = r[l + \"Color\"];\n        c && (h.opposite && (c[0] = -c[0]), g && (this.mark = t = e.path().addClass(\"highcharts-\" + (b ? b + \"-\" : \"\") + \"tick\").add(h.axisGroup), h.chart.styledMode || t.attr({\n          stroke: r,\n          \"stroke-width\": B\n        })), t[g ? \"attr\" : \"animate\"]({\n          d: this.getMarkPath(w, a, c[0], t.strokeWidth() * f, h.horiz, e),\n          opacity: n\n        }));\n      },\n      renderLabel: function (a, n, f, h) {\n        var r = this.axis,\n            e = r.horiz,\n            b = r.options,\n            l = this.label,\n            c = b.labels,\n            t = c.step,\n            r = x(this.tickmarkOffset, r.tickmarkOffset),\n            F = !0,\n            w = a.x;\n        a = a.y;\n        l && g(w) && (l.xy = a = this.getLabelPosition(w, a, l, e, c, r, h, t), this.isFirst && !this.isLast && !x(b.showFirstLabel, 1) || this.isLast && !this.isFirst && !x(b.showLastLabel, 1) ? F = !1 : !e || c.step || c.rotation || n || 0 === f || this.handleOverflow(a), t && h % t && (F = !1), F && g(a.y) ? (a.opacity = f, l[this.isNewLabel ? \"attr\" : \"animate\"](a), this.isNewLabel = !1) : (l.attr(\"y\", -9999), this.isNewLabel = !0));\n      },\n      render: function (g, n, f) {\n        var h = this.axis,\n            r = h.horiz,\n            e = this.pos,\n            b = x(this.tickmarkOffset, h.tickmarkOffset),\n            e = this.getPosition(r, e, b, n),\n            b = e.x,\n            l = e.y,\n            h = r && b === h.pos + h.len || !r && l === h.pos ? -1 : 1;\n        f = x(f, 1);\n        this.isActive = !0;\n        this.renderGridLine(n, f, h);\n        this.renderMark(e, f, h);\n        this.renderLabel(e, n, f, g);\n        this.isNew = !1;\n        a.fireEvent(this, \"afterRender\");\n      },\n      destroy: function () {\n        E(this, this.axis);\n      }\n    };\n  });\n  I(H, \"parts/Axis.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.addEvent,\n        A = a.animObject,\n        E = a.arrayMax,\n        m = a.arrayMin,\n        g = a.color,\n        v = a.correctFloat,\n        x = a.defaultOptions,\n        y = a.defined,\n        z = a.deg2rad,\n        n = a.destroyObjectProperties,\n        f = a.extend,\n        h = a.fireEvent,\n        r = a.format,\n        e = a.getMagnitude,\n        b = a.isArray,\n        l = a.isNumber,\n        c = a.isString,\n        t = a.merge,\n        F = a.normalizeTickInterval,\n        w = a.objectEach,\n        B = a.pick,\n        p = a.removeEvent,\n        d = a.seriesTypes,\n        k = a.splat,\n        u = a.syncTimeout,\n        D = a.Tick,\n        G = function () {\n      this.init.apply(this, arguments);\n    };\n\n    a.extend(G.prototype, {\n      defaultOptions: {\n        dateTimeLabelFormats: {\n          millisecond: {\n            main: \"%H:%M:%S.%L\",\n            range: !1\n          },\n          second: {\n            main: \"%H:%M:%S\",\n            range: !1\n          },\n          minute: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          hour: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          day: {\n            main: \"%e. %b\"\n          },\n          week: {\n            main: \"%e. %b\"\n          },\n          month: {\n            main: \"%b '%y\"\n          },\n          year: {\n            main: \"%Y\"\n          }\n        },\n        endOnTick: !1,\n        labels: {\n          enabled: !0,\n          indentation: 10,\n          x: 0,\n          style: {\n            color: \"#666666\",\n            cursor: \"default\",\n            fontSize: \"11px\"\n          }\n        },\n        maxPadding: .01,\n        minorTickLength: 2,\n        minorTickPosition: \"outside\",\n        minPadding: .01,\n        showEmpty: !0,\n        startOfWeek: 1,\n        startOnTick: !1,\n        tickLength: 10,\n        tickPixelInterval: 100,\n        tickmarkPlacement: \"between\",\n        tickPosition: \"outside\",\n        title: {\n          align: \"middle\",\n          style: {\n            color: \"#666666\"\n          }\n        },\n        type: \"linear\",\n        minorGridLineColor: \"#f2f2f2\",\n        minorGridLineWidth: 1,\n        minorTickColor: \"#999999\",\n        lineColor: \"#ccd6eb\",\n        lineWidth: 1,\n        gridLineColor: \"#e6e6e6\",\n        tickColor: \"#ccd6eb\"\n      },\n      defaultYAxisOptions: {\n        endOnTick: !0,\n        maxPadding: .05,\n        minPadding: .05,\n        tickPixelInterval: 72,\n        showLastLabel: !0,\n        labels: {\n          x: -8\n        },\n        startOnTick: !0,\n        title: {\n          rotation: 270,\n          text: \"Values\"\n        },\n        stackLabels: {\n          allowOverlap: !1,\n          enabled: !1,\n          formatter: function () {\n            return a.numberFormat(this.total, -1);\n          },\n          style: {\n            color: \"#000000\",\n            fontSize: \"11px\",\n            fontWeight: \"bold\",\n            textOutline: \"1px contrast\"\n          }\n        },\n        gridLineWidth: 1,\n        lineWidth: 0\n      },\n      defaultLeftAxisOptions: {\n        labels: {\n          x: -15\n        },\n        title: {\n          rotation: 270\n        }\n      },\n      defaultRightAxisOptions: {\n        labels: {\n          x: 15\n        },\n        title: {\n          rotation: 90\n        }\n      },\n      defaultBottomAxisOptions: {\n        labels: {\n          autoRotation: [-45],\n          x: 0\n        },\n        margin: 15,\n        title: {\n          rotation: 0\n        }\n      },\n      defaultTopAxisOptions: {\n        labels: {\n          autoRotation: [-45],\n          x: 0\n        },\n        margin: 15,\n        title: {\n          rotation: 0\n        }\n      },\n      init: function (d, b) {\n        var q = b.isX,\n            c = this;\n        c.chart = d;\n        c.horiz = d.inverted && !c.isZAxis ? !q : q;\n        c.isXAxis = q;\n        c.coll = c.coll || (q ? \"xAxis\" : \"yAxis\");\n        h(this, \"init\", {\n          userOptions: b\n        });\n        c.opposite = b.opposite;\n        c.side = b.side || (c.horiz ? c.opposite ? 0 : 2 : c.opposite ? 1 : 3);\n        c.setOptions(b);\n        var e = this.options,\n            u = e.type;\n        c.labelFormatter = e.labels.formatter || c.defaultLabelFormatter;\n        c.userOptions = b;\n        c.minPixelPadding = 0;\n        c.reversed = e.reversed;\n        c.visible = !1 !== e.visible;\n        c.zoomEnabled = !1 !== e.zoomEnabled;\n        c.hasNames = \"category\" === u || !0 === e.categories;\n        c.categories = e.categories || c.hasNames;\n        c.names || (c.names = [], c.names.keys = {});\n        c.plotLinesAndBandsGroups = {};\n        c.isLog = \"logarithmic\" === u;\n        c.isDatetimeAxis = \"datetime\" === u;\n        c.positiveValuesOnly = c.isLog && !c.allowNegativeLog;\n        c.isLinked = y(e.linkedTo);\n        c.ticks = {};\n        c.labelEdge = [];\n        c.minorTicks = {};\n        c.plotLinesAndBands = [];\n        c.alternateBands = {};\n        c.len = 0;\n        c.minRange = c.userMinRange = e.minRange || e.maxZoom;\n        c.range = e.range;\n        c.offset = e.offset || 0;\n        c.stacks = {};\n        c.oldStacks = {};\n        c.stacksTouched = 0;\n        c.max = null;\n        c.min = null;\n        c.crosshair = B(e.crosshair, k(d.options.tooltip.crosshairs)[q ? 0 : 1], !1);\n        b = c.options.events;\n        -1 === d.axes.indexOf(c) && (q ? d.axes.splice(d.xAxis.length, 0, c) : d.axes.push(c), d[c.coll].push(c));\n        c.series = c.series || [];\n        d.inverted && !c.isZAxis && q && void 0 === c.reversed && (c.reversed = !0);\n        w(b, function (d, q) {\n          a.isFunction(d) && C(c, q, d);\n        });\n        c.lin2log = e.linearToLogConverter || c.lin2log;\n        c.isLog && (c.val2lin = c.log2lin, c.lin2val = c.lin2log);\n        h(this, \"afterInit\");\n      },\n      setOptions: function (a) {\n        this.options = t(this.defaultOptions, \"yAxis\" === this.coll && this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], t(x[this.coll], a));\n        h(this, \"afterSetOptions\", {\n          userOptions: a\n        });\n      },\n      defaultLabelFormatter: function () {\n        var d = this.axis,\n            b = this.value,\n            c = d.chart.time,\n            k = d.categories,\n            e = this.dateTimeLabelFormat,\n            u = x.lang,\n            l = u.numericSymbols,\n            u = u.numericSymbolMagnitude || 1E3,\n            t = l && l.length,\n            p,\n            h = d.options.labels.format,\n            d = d.isLog ? Math.abs(b) : d.tickInterval;\n        if (h) p = r(h, this, c);else if (k) p = b;else if (e) p = c.dateFormat(e, b);else if (t && 1E3 <= d) for (; t-- && void 0 === p;) c = Math.pow(u, t + 1), d >= c && 0 === 10 * b % c && null !== l[t] && 0 !== b && (p = a.numberFormat(b / c, -1) + l[t]);\n        void 0 === p && (p = 1E4 <= Math.abs(b) ? a.numberFormat(b, -1) : a.numberFormat(b, -1, void 0, \"\"));\n        return p;\n      },\n      getSeriesExtremes: function () {\n        var a = this,\n            d = a.chart,\n            b;\n        h(this, \"getSeriesExtremes\", null, function () {\n          a.hasVisibleSeries = !1;\n          a.dataMin = a.dataMax = a.threshold = null;\n          a.softThreshold = !a.isXAxis;\n          a.buildStacks && a.buildStacks();\n          a.series.forEach(function (q) {\n            if (q.visible || !d.options.chart.ignoreHiddenSeries) {\n              var c = q.options,\n                  k = c.threshold,\n                  e,\n                  u;\n              a.hasVisibleSeries = !0;\n              a.positiveValuesOnly && 0 >= k && (k = null);\n              if (a.isXAxis) c = q.xData, c.length && (b = q.getXExtremes(c), e = b.min, u = b.max, l(e) || e instanceof Date || (c = c.filter(l), b = q.getXExtremes(c), e = b.min, u = b.max), c.length && (a.dataMin = Math.min(B(a.dataMin, e), e), a.dataMax = Math.max(B(a.dataMax, u), u)));else if (q.getExtremes(), u = q.dataMax, e = q.dataMin, y(e) && y(u) && (a.dataMin = Math.min(B(a.dataMin, e), e), a.dataMax = Math.max(B(a.dataMax, u), u)), y(k) && (a.threshold = k), !c.softThreshold || a.positiveValuesOnly) a.softThreshold = !1;\n            }\n          });\n        });\n        h(this, \"afterGetSeriesExtremes\");\n      },\n      translate: function (a, d, b, c, k, e) {\n        var q = this.linkedParent || this,\n            u = 1,\n            t = 0,\n            p = c ? q.oldTransA : q.transA;\n        c = c ? q.oldMin : q.min;\n        var K = q.minPixelPadding;\n        k = (q.isOrdinal || q.isBroken || q.isLog && k) && q.lin2val;\n        p || (p = q.transA);\n        b && (u *= -1, t = q.len);\n        q.reversed && (u *= -1, t -= u * (q.sector || q.len));\n        d ? (a = (a * u + t - K) / p + c, k && (a = q.lin2val(a))) : (k && (a = q.val2lin(a)), a = l(c) ? u * (a - c) * p + t + u * K + (l(e) ? p * e : 0) : void 0);\n        return a;\n      },\n      toPixels: function (a, d) {\n        return this.translate(a, !1, !this.horiz, null, !0) + (d ? 0 : this.pos);\n      },\n      toValue: function (a, d) {\n        return this.translate(a - (d ? 0 : this.pos), !0, !this.horiz, null, !0);\n      },\n      getPlotLinePath: function (a) {\n        var d = this,\n            q = d.chart,\n            b = d.left,\n            c = d.top,\n            k = a.old,\n            e = a.value,\n            u = a.translatedValue,\n            t = a.lineWidth,\n            p = a.force,\n            f,\n            w,\n            r,\n            D,\n            G = k && q.oldChartHeight || q.chartHeight,\n            n = k && q.oldChartWidth || q.chartWidth,\n            g,\n            F = d.transB,\n            m = function (a, d, q) {\n          if (\"pass\" !== p && a < d || a > q) p ? a = Math.min(Math.max(d, a), q) : g = !0;\n          return a;\n        };\n\n        a = {\n          value: e,\n          lineWidth: t,\n          old: k,\n          force: p,\n          acrossPanes: a.acrossPanes,\n          translatedValue: u\n        };\n        h(this, \"getPlotLinePath\", a, function (a) {\n          u = B(u, d.translate(e, null, null, k));\n          u = Math.min(Math.max(-1E5, u), 1E5);\n          f = r = Math.round(u + F);\n          w = D = Math.round(G - u - F);\n          l(u) ? d.horiz ? (w = c, D = G - d.bottom, f = r = m(f, b, b + d.width)) : (f = b, r = n - d.right, w = D = m(w, c, c + d.height)) : (g = !0, p = !1);\n          a.path = g && !p ? null : q.renderer.crispLine([\"M\", f, w, \"L\", r, D], t || 1);\n        });\n        return a.path;\n      },\n      getLinearTickPositions: function (a, d, b) {\n        var q,\n            c = v(Math.floor(d / a) * a);\n        b = v(Math.ceil(b / a) * a);\n        var k = [],\n            e;\n        v(c + a) === c && (e = 20);\n        if (this.single) return [d];\n\n        for (d = c; d <= b;) {\n          k.push(d);\n          d = v(d + a, e);\n          if (d === q) break;\n          q = d;\n        }\n\n        return k;\n      },\n      getMinorTickInterval: function () {\n        var a = this.options;\n        return !0 === a.minorTicks ? B(a.minorTickInterval, \"auto\") : !1 === a.minorTicks ? null : a.minorTickInterval;\n      },\n      getMinorTickPositions: function () {\n        var a = this,\n            d = a.options,\n            b = a.tickPositions,\n            c = a.minorTickInterval,\n            k = [],\n            e = a.pointRangePadding || 0,\n            u = a.min - e,\n            e = a.max + e,\n            l = e - u;\n        if (l && l / c < a.len / 3) if (a.isLog) this.paddedTicks.forEach(function (d, q, b) {\n          q && k.push.apply(k, a.getLogTickPositions(c, b[q - 1], b[q], !0));\n        });else if (a.isDatetimeAxis && \"auto\" === this.getMinorTickInterval()) k = k.concat(a.getTimeTicks(a.normalizeTimeTickInterval(c), u, e, d.startOfWeek));else for (d = u + (b[0] - u) % c; d <= e && d !== k[0]; d += c) k.push(d);\n        0 !== k.length && a.trimTicks(k);\n        return k;\n      },\n      adjustForMinRange: function () {\n        var a = this.options,\n            d = this.min,\n            b = this.max,\n            c,\n            k,\n            e,\n            u,\n            l,\n            t,\n            p,\n            h;\n        this.isXAxis && void 0 === this.minRange && !this.isLog && (y(a.min) || y(a.max) ? this.minRange = null : (this.series.forEach(function (a) {\n          t = a.xData;\n\n          for (u = p = a.xIncrement ? 1 : t.length - 1; 0 < u; u--) if (l = t[u] - t[u - 1], void 0 === e || l < e) e = l;\n        }), this.minRange = Math.min(5 * e, this.dataMax - this.dataMin)));\n        b - d < this.minRange && (k = this.dataMax - this.dataMin >= this.minRange, h = this.minRange, c = (h - b + d) / 2, c = [d - c, B(a.min, d - c)], k && (c[2] = this.isLog ? this.log2lin(this.dataMin) : this.dataMin), d = E(c), b = [d + h, B(a.max, d + h)], k && (b[2] = this.isLog ? this.log2lin(this.dataMax) : this.dataMax), b = m(b), b - d < h && (c[0] = b - h, c[1] = B(a.min, b - h), d = E(c)));\n        this.min = d;\n        this.max = b;\n      },\n      getClosest: function () {\n        var a;\n        this.categories ? a = 1 : this.series.forEach(function (d) {\n          var b = d.closestPointRange,\n              q = d.visible || !d.chart.options.chart.ignoreHiddenSeries;\n          !d.noSharedTooltip && y(b) && q && (a = y(a) ? Math.min(a, b) : b);\n        });\n        return a;\n      },\n      nameToX: function (a) {\n        var d = b(this.categories),\n            q = d ? this.categories : this.names,\n            c = a.options.x,\n            k;\n        a.series.requireSorting = !1;\n        y(c) || (c = !1 === this.options.uniqueNames ? a.series.autoIncrement() : d ? q.indexOf(a.name) : B(q.keys[a.name], -1));\n        -1 === c ? d || (k = q.length) : k = c;\n        void 0 !== k && (this.names[k] = a.name, this.names.keys[a.name] = k);\n        return k;\n      },\n      updateNames: function () {\n        var a = this,\n            d = this.names;\n        0 < d.length && (Object.keys(d.keys).forEach(function (a) {\n          delete d.keys[a];\n        }), d.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (d) {\n          d.xIncrement = null;\n          if (!d.points || d.isDirtyData) a.max = Math.max(a.max, d.xData.length - 1), d.processData(), d.generatePoints();\n          d.data.forEach(function (b, q) {\n            var c;\n            b && b.options && void 0 !== b.name && (c = a.nameToX(b), void 0 !== c && c !== b.x && (b.x = c, d.xData[q] = c));\n          });\n        }));\n      },\n      setAxisTranslation: function (a) {\n        var b = this,\n            q = b.max - b.min,\n            k = b.axisPointRange || 0,\n            e,\n            u = 0,\n            l = 0,\n            t = b.linkedParent,\n            p = !!b.categories,\n            f = b.transA,\n            w = b.isXAxis;\n        if (w || p || k) e = b.getClosest(), t ? (u = t.minPointOffset, l = t.pointRangePadding) : b.series.forEach(function (a) {\n          var q = p ? 1 : w ? B(a.options.pointRange, e, 0) : b.axisPointRange || 0,\n              t = a.options.pointPlacement;\n          k = Math.max(k, q);\n          if (!b.single || p) a = d.xrange && a instanceof d.xrange ? !w : w, u = Math.max(u, a && c(t) ? 0 : q / 2), l = Math.max(l, a && \"on\" === t ? 0 : q);\n        }), t = b.ordinalSlope && e ? b.ordinalSlope / e : 1, b.minPointOffset = u *= t, b.pointRangePadding = l *= t, b.pointRange = Math.min(k, q), w && (b.closestPointRange = e);\n        a && (b.oldTransA = f);\n        b.translationSlope = b.transA = f = b.staticScale || b.len / (q + l || 1);\n        b.transB = b.horiz ? b.left : b.bottom;\n        b.minPixelPadding = f * u;\n        h(this, \"afterSetAxisTranslation\");\n      },\n      minFromRange: function () {\n        return this.max - this.range;\n      },\n      setTickInterval: function (d) {\n        var b = this,\n            q = b.chart,\n            c = b.options,\n            k = b.isLog,\n            u = b.isDatetimeAxis,\n            t = b.isXAxis,\n            p = b.isLinked,\n            f = c.maxPadding,\n            w = c.minPadding,\n            r,\n            D = c.tickInterval,\n            G = c.tickPixelInterval,\n            n = b.categories,\n            g = l(b.threshold) ? b.threshold : null,\n            m = b.softThreshold,\n            x,\n            z,\n            A;\n        u || n || p || this.getTickAmount();\n        z = B(b.userMin, c.min);\n        A = B(b.userMax, c.max);\n        p ? (b.linkedParent = q[b.coll][c.linkedTo], r = b.linkedParent.getExtremes(), b.min = B(r.min, r.dataMin), b.max = B(r.max, r.dataMax), c.type !== b.linkedParent.options.type && a.error(11, 1, q)) : (!m && y(g) && (b.dataMin >= g ? (r = g, w = 0) : b.dataMax <= g && (x = g, f = 0)), b.min = B(z, r, b.dataMin), b.max = B(A, x, b.dataMax));\n        k && (b.positiveValuesOnly && !d && 0 >= Math.min(b.min, B(b.dataMin, b.min)) && a.error(10, 1, q), b.min = v(b.log2lin(b.min), 15), b.max = v(b.log2lin(b.max), 15));\n        b.range && y(b.max) && (b.userMin = b.min = z = Math.max(b.dataMin, b.minFromRange()), b.userMax = A = b.max, b.range = null);\n        h(b, \"foundExtremes\");\n        b.beforePadding && b.beforePadding();\n        b.adjustForMinRange();\n        !(n || b.axisPointRange || b.usePercentage || p) && y(b.min) && y(b.max) && (q = b.max - b.min) && (!y(z) && w && (b.min -= q * w), !y(A) && f && (b.max += q * f));\n        l(c.softMin) && !l(b.userMin) && c.softMin < b.min && (b.min = z = c.softMin);\n        l(c.softMax) && !l(b.userMax) && c.softMax > b.max && (b.max = A = c.softMax);\n        l(c.floor) && (b.min = Math.min(Math.max(b.min, c.floor), Number.MAX_VALUE));\n        l(c.ceiling) && (b.max = Math.max(Math.min(b.max, c.ceiling), B(b.userMax, -Number.MAX_VALUE)));\n        m && y(b.dataMin) && (g = g || 0, !y(z) && b.min < g && b.dataMin >= g ? b.min = b.options.minRange ? Math.min(g, b.max - b.minRange) : g : !y(A) && b.max > g && b.dataMax <= g && (b.max = b.options.minRange ? Math.max(g, b.min + b.minRange) : g));\n        b.tickInterval = b.min === b.max || void 0 === b.min || void 0 === b.max ? 1 : p && !D && G === b.linkedParent.options.tickPixelInterval ? D = b.linkedParent.tickInterval : B(D, this.tickAmount ? (b.max - b.min) / Math.max(this.tickAmount - 1, 1) : void 0, n ? 1 : (b.max - b.min) * G / Math.max(b.len, G));\n        t && !d && b.series.forEach(function (a) {\n          a.processData(b.min !== b.oldMin || b.max !== b.oldMax);\n        });\n        b.setAxisTranslation(!0);\n        b.beforeSetTickPositions && b.beforeSetTickPositions();\n        b.postProcessTickInterval && (b.tickInterval = b.postProcessTickInterval(b.tickInterval));\n        b.pointRange && !D && (b.tickInterval = Math.max(b.pointRange, b.tickInterval));\n        d = B(c.minTickInterval, b.isDatetimeAxis && b.closestPointRange);\n        !D && b.tickInterval < d && (b.tickInterval = d);\n        u || k || D || (b.tickInterval = F(b.tickInterval, null, e(b.tickInterval), B(c.allowDecimals, !(.5 < b.tickInterval && 5 > b.tickInterval && 1E3 < b.max && 9999 > b.max)), !!this.tickAmount));\n        this.tickAmount || (b.tickInterval = b.unsquish());\n        this.setTickPositions();\n      },\n      setTickPositions: function () {\n        var d = this.options,\n            b,\n            c = d.tickPositions;\n        b = this.getMinorTickInterval();\n        var k = d.tickPositioner,\n            e = d.startOnTick,\n            u = d.endOnTick;\n        this.tickmarkOffset = this.categories && \"between\" === d.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;\n        this.minorTickInterval = \"auto\" === b && this.tickInterval ? this.tickInterval / 5 : b;\n        this.single = this.min === this.max && y(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== d.allowDecimals);\n        this.tickPositions = b = c && c.slice();\n        !b && (!this.ordinalPositions && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200) ? (b = [this.min, this.max], a.error(19, !1, this.chart)) : b = this.isDatetimeAxis ? this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval, d.units), this.min, this.max, d.startOfWeek, this.ordinalPositions, this.closestPointRange, !0) : this.isLog ? this.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max), b.length > this.len && (b = [b[0], b.pop()], b[0] === b[1] && (b.length = 1)), this.tickPositions = b, k && (k = k.apply(this, [this.min, this.max]))) && (this.tickPositions = b = k);\n        this.paddedTicks = b.slice(0);\n        this.trimTicks(b, e, u);\n        this.isLinked || (this.single && 2 > b.length && !this.categories && (this.min -= .5, this.max += .5), c || k || this.adjustTickAmount());\n        h(this, \"afterSetTickPositions\");\n      },\n      trimTicks: function (a, d, b) {\n        var q = a[0],\n            c = a[a.length - 1],\n            k = this.minPointOffset || 0;\n        h(this, \"trimTicks\");\n\n        if (!this.isLinked) {\n          if (d && -Infinity !== q) this.min = q;else for (; this.min - k > a[0];) a.shift();\n          if (b) this.max = c;else for (; this.max + k < a[a.length - 1];) a.pop();\n          0 === a.length && y(q) && !this.options.tickPositions && a.push((c + q) / 2);\n        }\n      },\n      alignToOthers: function () {\n        var a = {},\n            d,\n            b = this.options;\n        !1 === this.chart.options.chart.alignTicks || !1 === b.alignTicks || !1 === b.startOnTick || !1 === b.endOnTick || this.isLog || this.chart[this.coll].forEach(function (b) {\n          var q = b.options,\n              q = [b.horiz ? q.left : q.top, q.width, q.height, q.pane].join();\n          b.series.length && (a[q] ? d = !0 : a[q] = 1);\n        });\n        return d;\n      },\n      getTickAmount: function () {\n        var a = this.options,\n            d = a.tickAmount,\n            b = a.tickPixelInterval;\n        !y(a.tickInterval) && this.len < b && !this.isRadial && !this.isLog && a.startOnTick && a.endOnTick && (d = 2);\n        !d && this.alignToOthers() && (d = Math.ceil(this.len / b) + 1);\n        4 > d && (this.finalTickAmt = d, d = 5);\n        this.tickAmount = d;\n      },\n      adjustTickAmount: function () {\n        var a = this.options,\n            d = this.tickInterval,\n            b = this.tickPositions,\n            c = this.tickAmount,\n            k = this.finalTickAmt,\n            e = b && b.length,\n            u = B(this.threshold, this.softThreshold ? 0 : null),\n            l;\n\n        if (this.hasData()) {\n          if (e < c) {\n            for (l = this.min; b.length < c;) b.length % 2 || l === u ? b.push(v(b[b.length - 1] + d)) : b.unshift(v(b[0] - d));\n\n            this.transA *= (e - 1) / (c - 1);\n            this.min = a.startOnTick ? b[0] : Math.min(this.min, b[0]);\n            this.max = a.endOnTick ? b[b.length - 1] : Math.max(this.max, b[b.length - 1]);\n          } else e > c && (this.tickInterval *= 2, this.setTickPositions());\n\n          if (y(k)) {\n            for (d = a = b.length; d--;) (3 === k && 1 === d % 2 || 2 >= k && 0 < d && d < a - 1) && b.splice(d, 1);\n\n            this.finalTickAmt = void 0;\n          }\n        }\n      },\n      setScale: function () {\n        var a = this.series.some(function (a) {\n          return a.isDirtyData || a.isDirty || a.xAxis.isDirty;\n        }),\n            d;\n        this.oldMin = this.min;\n        this.oldMax = this.max;\n        this.oldAxisLength = this.len;\n        this.setAxisSize();\n        (d = this.len !== this.oldAxisLength) || a || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax || this.alignToOthers() ? (this.resetStacks && this.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.oldUserMin = this.userMin, this.oldUserMax = this.userMax, this.isDirty || (this.isDirty = d || this.min !== this.oldMin || this.max !== this.oldMax)) : this.cleanStacks && this.cleanStacks();\n        h(this, \"afterSetScale\");\n      },\n      setExtremes: function (a, d, b, c, k) {\n        var q = this,\n            e = q.chart;\n        b = B(b, !0);\n        q.series.forEach(function (a) {\n          delete a.kdTree;\n        });\n        k = f(k, {\n          min: a,\n          max: d\n        });\n        h(q, \"setExtremes\", k, function () {\n          q.userMin = a;\n          q.userMax = d;\n          q.eventArgs = k;\n          b && e.redraw(c);\n        });\n      },\n      zoom: function (a, d) {\n        var b = this.dataMin,\n            q = this.dataMax,\n            c = this.options,\n            k = Math.min(b, B(c.min, b)),\n            e = Math.max(q, B(c.max, q));\n        a = {\n          newMin: a,\n          newMax: d\n        };\n        h(this, \"zoom\", a, function (a) {\n          var d = a.newMin,\n              c = a.newMax;\n          if (d !== this.min || c !== this.max) this.allowZoomOutside || (y(b) && (d < k && (d = k), d > e && (d = e)), y(q) && (c < k && (c = k), c > e && (c = e))), this.displayBtn = void 0 !== d || void 0 !== c, this.setExtremes(d, c, !1, void 0, {\n            trigger: \"zoom\"\n          });\n          a.zoomed = !0;\n        });\n        return a.zoomed;\n      },\n      setAxisSize: function () {\n        var d = this.chart,\n            b = this.options,\n            c = b.offsets || [0, 0, 0, 0],\n            k = this.horiz,\n            e = this.width = Math.round(a.relativeLength(B(b.width, d.plotWidth - c[3] + c[1]), d.plotWidth)),\n            u = this.height = Math.round(a.relativeLength(B(b.height, d.plotHeight - c[0] + c[2]), d.plotHeight)),\n            l = this.top = Math.round(a.relativeLength(B(b.top, d.plotTop + c[0]), d.plotHeight, d.plotTop)),\n            b = this.left = Math.round(a.relativeLength(B(b.left, d.plotLeft + c[3]), d.plotWidth, d.plotLeft));\n        this.bottom = d.chartHeight - u - l;\n        this.right = d.chartWidth - e - b;\n        this.len = Math.max(k ? e : u, 0);\n        this.pos = k ? b : l;\n      },\n      getExtremes: function () {\n        var a = this.isLog;\n        return {\n          min: a ? v(this.lin2log(this.min)) : this.min,\n          max: a ? v(this.lin2log(this.max)) : this.max,\n          dataMin: this.dataMin,\n          dataMax: this.dataMax,\n          userMin: this.userMin,\n          userMax: this.userMax\n        };\n      },\n      getThreshold: function (a) {\n        var d = this.isLog,\n            b = d ? this.lin2log(this.min) : this.min,\n            d = d ? this.lin2log(this.max) : this.max;\n        null === a || -Infinity === a ? a = b : Infinity === a ? a = d : b > a ? a = b : d < a && (a = d);\n        return this.translate(a, 0, 1, 0, 1);\n      },\n      autoLabelAlign: function (a) {\n        var d = (B(a, 0) - 90 * this.side + 720) % 360;\n        a = {\n          align: \"center\"\n        };\n        h(this, \"autoLabelAlign\", a, function (a) {\n          15 < d && 165 > d ? a.align = \"right\" : 195 < d && 345 > d && (a.align = \"left\");\n        });\n        return a.align;\n      },\n      tickSize: function (a) {\n        var d = this.options,\n            b = d[a + \"Length\"],\n            c = B(d[a + \"Width\"], \"tick\" === a && this.isXAxis && !this.categories ? 1 : 0),\n            q;\n        c && b && (\"inside\" === d[a + \"Position\"] && (b = -b), q = [b, c]);\n        a = {\n          tickSize: q\n        };\n        h(this, \"afterTickSize\", a);\n        return a.tickSize;\n      },\n      labelMetrics: function () {\n        var a = this.tickPositions && this.tickPositions[0] || 0;\n        return this.chart.renderer.fontMetrics(this.options.labels.style && this.options.labels.style.fontSize, this.ticks[a] && this.ticks[a].label);\n      },\n      unsquish: function () {\n        var a = this.options.labels,\n            d = this.horiz,\n            b = this.tickInterval,\n            c = b,\n            k = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / b),\n            e,\n            u = a.rotation,\n            l = this.labelMetrics(),\n            t,\n            p = Number.MAX_VALUE,\n            h,\n            f = this.max - this.min,\n            w = function (a) {\n          var d = a / (k || 1),\n              d = 1 < d ? Math.ceil(d) : 1;\n          d * b > f && Infinity !== a && Infinity !== k && (d = Math.ceil(f / b));\n          return v(d * b);\n        };\n\n        d ? (h = !a.staggerLines && !a.step && (y(u) ? [u] : k < B(a.autoRotationLimit, 80) && a.autoRotation)) && h.forEach(function (a) {\n          var d;\n          if (a === u || a && -90 <= a && 90 >= a) t = w(Math.abs(l.h / Math.sin(z * a))), d = t + Math.abs(a / 360), d < p && (p = d, e = a, c = t);\n        }) : a.step || (c = w(l.h));\n        this.autoRotation = h;\n        this.labelRotation = B(e, u);\n        return c;\n      },\n      getSlotWidth: function (a) {\n        var d = this.chart,\n            b = this.horiz,\n            c = this.options.labels,\n            k = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n            q = d.margin[3];\n        return a && a.slotWidth || b && 2 > (c.step || 0) && !c.rotation && (this.staggerLines || 1) * this.len / k || !b && (c.style && parseInt(c.style.width, 10) || q && q - d.spacing[3] || .33 * d.chartWidth);\n      },\n      renderUnsquish: function () {\n        var a = this.chart,\n            d = a.renderer,\n            b = this.tickPositions,\n            k = this.ticks,\n            e = this.options.labels,\n            u = e && e.style || {},\n            l = this.horiz,\n            t = this.getSlotWidth(),\n            p = Math.max(1, Math.round(t - 2 * (e.padding || 5))),\n            h = {},\n            f = this.labelMetrics(),\n            w = e.style && e.style.textOverflow,\n            r,\n            D,\n            G = 0,\n            g;\n        c(e.rotation) || (h.rotation = e.rotation || 0);\n        b.forEach(function (a) {\n          (a = k[a]) && a.label && a.label.textPxLength > G && (G = a.label.textPxLength);\n        });\n        this.maxLabelLength = G;\n        if (this.autoRotation) G > p && G > f.h ? h.rotation = this.labelRotation : this.labelRotation = 0;else if (t && (r = p, !w)) for (D = \"clip\", p = b.length; !l && p--;) if (g = b[p], g = k[g].label) g.styles && \"ellipsis\" === g.styles.textOverflow ? g.css({\n          textOverflow: \"clip\"\n        }) : g.textPxLength > t && g.css({\n          width: t + \"px\"\n        }), g.getBBox().height > this.len / b.length - (f.h - f.f) && (g.specificTextOverflow = \"ellipsis\");\n        h.rotation && (r = G > .5 * a.chartHeight ? .33 * a.chartHeight : G, w || (D = \"ellipsis\"));\n        if (this.labelAlign = e.align || this.autoLabelAlign(this.labelRotation)) h.align = this.labelAlign;\n        b.forEach(function (a) {\n          var d = (a = k[a]) && a.label,\n              b = u.width,\n              c = {};\n          d && (d.attr(h), a.shortenLabel ? a.shortenLabel() : r && !b && \"nowrap\" !== u.whiteSpace && (r < d.textPxLength || \"SPAN\" === d.element.tagName) ? (c.width = r, w || (c.textOverflow = d.specificTextOverflow || D), d.css(c)) : d.styles && d.styles.width && !c.width && !b && d.css({\n            width: null\n          }), delete d.specificTextOverflow, a.rotation = h.rotation);\n        }, this);\n        this.tickRotCorr = d.rotCorr(f.b, this.labelRotation || 0, 0 !== this.side);\n      },\n      hasData: function () {\n        return this.series.some(function (a) {\n          return a.hasData();\n        }) || this.options.showEmpty && y(this.min) && y(this.max);\n      },\n      addTitle: function (a) {\n        var d = this.chart.renderer,\n            b = this.horiz,\n            c = this.opposite,\n            k = this.options.title,\n            q,\n            e = this.chart.styledMode;\n        this.axisTitle || ((q = k.textAlign) || (q = (b ? {\n          low: \"left\",\n          middle: \"center\",\n          high: \"right\"\n        } : {\n          low: c ? \"right\" : \"left\",\n          middle: \"center\",\n          high: c ? \"left\" : \"right\"\n        })[k.align]), this.axisTitle = d.text(k.text, 0, 0, k.useHTML).attr({\n          zIndex: 7,\n          rotation: k.rotation || 0,\n          align: q\n        }).addClass(\"highcharts-axis-title\"), e || this.axisTitle.css(t(k.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);\n        e || k.style.width || this.isRadial || this.axisTitle.css({\n          width: this.len\n        });\n        this.axisTitle[a ? \"show\" : \"hide\"](!0);\n      },\n      generateTick: function (a) {\n        var d = this.ticks;\n        d[a] ? d[a].addLabel() : d[a] = new D(this, a);\n      },\n      getOffset: function () {\n        var a = this,\n            d = a.chart,\n            b = d.renderer,\n            c = a.options,\n            k = a.tickPositions,\n            e = a.ticks,\n            u = a.horiz,\n            l = a.side,\n            t = d.inverted && !a.isZAxis ? [1, 0, 3, 2][l] : l,\n            p,\n            f,\n            r = 0,\n            D,\n            G = 0,\n            g = c.title,\n            n = c.labels,\n            F = 0,\n            m = d.axisOffset,\n            d = d.clipOffset,\n            v = [-1, 1, 1, -1][l],\n            x = c.className,\n            z = a.axisParent;\n        p = a.hasData();\n        a.showAxis = f = p || B(c.showEmpty, !0);\n        a.staggerLines = a.horiz && n.staggerLines;\n        a.axisGroup || (a.gridGroup = b.g(\"grid\").attr({\n          zIndex: c.gridZIndex || 1\n        }).addClass(\"highcharts-\" + this.coll.toLowerCase() + \"-grid \" + (x || \"\")).add(z), a.axisGroup = b.g(\"axis\").attr({\n          zIndex: c.zIndex || 2\n        }).addClass(\"highcharts-\" + this.coll.toLowerCase() + \" \" + (x || \"\")).add(z), a.labelGroup = b.g(\"axis-labels\").attr({\n          zIndex: n.zIndex || 7\n        }).addClass(\"highcharts-\" + a.coll.toLowerCase() + \"-labels \" + (x || \"\")).add(z));\n        p || a.isLinked ? (k.forEach(function (d, b) {\n          a.generateTick(d, b);\n        }), a.renderUnsquish(), a.reserveSpaceDefault = 0 === l || 2 === l || {\n          1: \"left\",\n          3: \"right\"\n        }[l] === a.labelAlign, B(n.reserveSpace, \"center\" === a.labelAlign ? !0 : null, a.reserveSpaceDefault) && k.forEach(function (a) {\n          F = Math.max(e[a].getLabelSize(), F);\n        }), a.staggerLines && (F *= a.staggerLines), a.labelOffset = F * (a.opposite ? -1 : 1)) : w(e, function (a, d) {\n          a.destroy();\n          delete e[d];\n        });\n        g && g.text && !1 !== g.enabled && (a.addTitle(f), f && !1 !== g.reserveSpace && (a.titleOffset = r = a.axisTitle.getBBox()[u ? \"height\" : \"width\"], D = g.offset, G = y(D) ? 0 : B(g.margin, u ? 5 : 10)));\n        a.renderLine();\n        a.offset = v * B(c.offset, m[l] ? m[l] + (c.margin || 0) : 0);\n        a.tickRotCorr = a.tickRotCorr || {\n          x: 0,\n          y: 0\n        };\n        b = 0 === l ? -a.labelMetrics().h : 2 === l ? a.tickRotCorr.y : 0;\n        G = Math.abs(F) + G;\n        F && (G = G - b + v * (u ? B(n.y, a.tickRotCorr.y + 8 * v) : n.x));\n        a.axisTitleMargin = B(D, G);\n        a.getMaxLabelDimensions && (a.maxLabelDimensions = a.getMaxLabelDimensions(e, k));\n        u = this.tickSize(\"tick\");\n        m[l] = Math.max(m[l], a.axisTitleMargin + r + v * a.offset, G, k && k.length && u ? u[0] + v * a.offset : 0);\n        c = c.offset ? 0 : 2 * Math.floor(a.axisLine.strokeWidth() / 2);\n        d[t] = Math.max(d[t], c);\n        h(this, \"afterGetOffset\");\n      },\n      getLinePath: function (a) {\n        var d = this.chart,\n            b = this.opposite,\n            c = this.offset,\n            k = this.horiz,\n            e = this.left + (b ? this.width : 0) + c,\n            c = d.chartHeight - this.bottom - (b ? this.height : 0) + c;\n        b && (a *= -1);\n        return d.renderer.crispLine([\"M\", k ? this.left : e, k ? c : this.top, \"L\", k ? d.chartWidth - this.right : e, k ? c : d.chartHeight - this.bottom], a);\n      },\n      renderLine: function () {\n        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass(\"highcharts-axis-line\").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({\n          stroke: this.options.lineColor,\n          \"stroke-width\": this.options.lineWidth,\n          zIndex: 7\n        }));\n      },\n      getTitlePosition: function () {\n        var a = this.horiz,\n            d = this.left,\n            b = this.top,\n            c = this.len,\n            k = this.options.title,\n            e = a ? d : b,\n            u = this.opposite,\n            l = this.offset,\n            t = k.x || 0,\n            p = k.y || 0,\n            f = this.axisTitle,\n            w = this.chart.renderer.fontMetrics(k.style && k.style.fontSize, f),\n            f = Math.max(f.getBBox(null, 0).height - w.h - 1, 0),\n            c = {\n          low: e + (a ? 0 : c),\n          middle: e + c / 2,\n          high: e + (a ? c : 0)\n        }[k.align],\n            d = (a ? b + this.height : d) + (a ? 1 : -1) * (u ? -1 : 1) * this.axisTitleMargin + [-f, f, w.f, -f][this.side],\n            a = {\n          x: a ? c + t : d + (u ? this.width : 0) + l + t,\n          y: a ? d + p - (u ? this.height : 0) + l : c + p\n        };\n        h(this, \"afterGetTitlePosition\", {\n          titlePosition: a\n        });\n        return a;\n      },\n      renderMinorTick: function (a) {\n        var d = this.chart.hasRendered && l(this.oldMin),\n            b = this.minorTicks;\n        b[a] || (b[a] = new D(this, a, \"minor\"));\n        d && b[a].isNew && b[a].render(null, !0);\n        b[a].render(null, !1, 1);\n      },\n      renderTick: function (a, d) {\n        var b = this.isLinked,\n            c = this.ticks,\n            k = this.chart.hasRendered && l(this.oldMin);\n        if (!b || a >= this.min && a <= this.max) c[a] || (c[a] = new D(this, a)), k && c[a].isNew && c[a].render(d, !0, -1), c[a].render(d);\n      },\n      render: function () {\n        var d = this,\n            b = d.chart,\n            c = d.options,\n            k = d.isLog,\n            e = d.isLinked,\n            t = d.tickPositions,\n            p = d.axisTitle,\n            f = d.ticks,\n            r = d.minorTicks,\n            G = d.alternateBands,\n            g = c.stackLabels,\n            n = c.alternateGridColor,\n            F = d.tickmarkOffset,\n            B = d.axisLine,\n            m = d.showAxis,\n            v = A(b.renderer.globalAnimation),\n            x,\n            z;\n        d.labelEdge.length = 0;\n        d.overlap = !1;\n        [f, r, G].forEach(function (a) {\n          w(a, function (a) {\n            a.isActive = !1;\n          });\n        });\n        if (d.hasData() || e) d.minorTickInterval && !d.categories && d.getMinorTickPositions().forEach(function (a) {\n          d.renderMinorTick(a);\n        }), t.length && (t.forEach(function (a, b) {\n          d.renderTick(a, b);\n        }), F && (0 === d.min || d.single) && (f[-1] || (f[-1] = new D(d, -1, null, !0)), f[-1].render(-1))), n && t.forEach(function (c, e) {\n          z = void 0 !== t[e + 1] ? t[e + 1] + F : d.max - F;\n          0 === e % 2 && c < d.max && z <= d.max + (b.polar ? -F : F) && (G[c] || (G[c] = new a.PlotLineOrBand(d)), x = c + F, G[c].options = {\n            from: k ? d.lin2log(x) : x,\n            to: k ? d.lin2log(z) : z,\n            color: n\n          }, G[c].render(), G[c].isActive = !0);\n        }), d._addedPlotLB || ((c.plotLines || []).concat(c.plotBands || []).forEach(function (a) {\n          d.addPlotBandOrLine(a);\n        }), d._addedPlotLB = !0);\n        [f, r, G].forEach(function (a) {\n          var d,\n              c = [],\n              k = v.duration;\n          w(a, function (a, d) {\n            a.isActive || (a.render(d, !1, 0), a.isActive = !1, c.push(d));\n          });\n          u(function () {\n            for (d = c.length; d--;) a[c[d]] && !a[c[d]].isActive && (a[c[d]].destroy(), delete a[c[d]]);\n          }, a !== G && b.hasRendered && k ? k : 0);\n        });\n        B && (B[B.isPlaced ? \"animate\" : \"attr\"]({\n          d: this.getLinePath(B.strokeWidth())\n        }), B.isPlaced = !0, B[m ? \"show\" : \"hide\"](!0));\n        p && m && (c = d.getTitlePosition(), l(c.y) ? (p[p.isNew ? \"attr\" : \"animate\"](c), p.isNew = !1) : (p.attr(\"y\", -9999), p.isNew = !0));\n        g && g.enabled && d.renderStackTotals();\n        d.isDirty = !1;\n        h(this, \"afterRender\");\n      },\n      redraw: function () {\n        this.visible && (this.render(), this.plotLinesAndBands.forEach(function (a) {\n          a.render();\n        }));\n        this.series.forEach(function (a) {\n          a.isDirty = !0;\n        });\n      },\n      keepProps: \"extKey hcEvents names series userMax userMin\".split(\" \"),\n      destroy: function (a) {\n        var d = this,\n            b = d.stacks,\n            c = d.plotLinesAndBands,\n            k;\n        h(this, \"destroy\", {\n          keepEvents: a\n        });\n        a || p(d);\n        w(b, function (a, d) {\n          n(a);\n          b[d] = null;\n        });\n        [d.ticks, d.minorTicks, d.alternateBands].forEach(function (a) {\n          n(a);\n        });\n        if (c) for (a = c.length; a--;) c[a].destroy();\n        \"stackTotalGroup axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar\".split(\" \").forEach(function (a) {\n          d[a] && (d[a] = d[a].destroy());\n        });\n\n        for (k in d.plotLinesAndBandsGroups) d.plotLinesAndBandsGroups[k] = d.plotLinesAndBandsGroups[k].destroy();\n\n        w(d, function (a, b) {\n          -1 === d.keepProps.indexOf(b) && delete d[b];\n        });\n      },\n      drawCrosshair: function (a, d) {\n        var b,\n            c = this.crosshair,\n            k = B(c.snap, !0),\n            e,\n            u = this.cross;\n        h(this, \"drawCrosshair\", {\n          e: a,\n          point: d\n        });\n        a || (a = this.cross && this.cross.e);\n\n        if (this.crosshair && !1 !== (y(d) || !k)) {\n          k ? y(d) && (e = B(d.crosshairPos, this.isXAxis ? d.plotX : this.len - d.plotY)) : e = a && (this.horiz ? a.chartX - this.pos : this.len - a.chartY + this.pos);\n          y(e) && (b = this.getPlotLinePath({\n            value: d && (this.isXAxis ? d.x : B(d.stackY, d.y)),\n            translatedValue: e\n          }) || null);\n\n          if (!y(b)) {\n            this.hideCrosshair();\n            return;\n          }\n\n          k = this.categories && !this.isRadial;\n          u || (this.cross = u = this.chart.renderer.path().addClass(\"highcharts-crosshair highcharts-crosshair-\" + (k ? \"category \" : \"thin \") + c.className).attr({\n            zIndex: B(c.zIndex, 2)\n          }).add(), this.chart.styledMode || (u.attr({\n            stroke: c.color || (k ? g(\"#ccd6eb\").setOpacity(.25).get() : \"#cccccc\"),\n            \"stroke-width\": B(c.width, 1)\n          }).css({\n            \"pointer-events\": \"none\"\n          }), c.dashStyle && u.attr({\n            dashstyle: c.dashStyle\n          })));\n          u.show().attr({\n            d: b\n          });\n          k && !c.width && u.attr({\n            \"stroke-width\": this.transA\n          });\n          this.cross.e = a;\n        } else this.hideCrosshair();\n\n        h(this, \"afterDrawCrosshair\", {\n          e: a,\n          point: d\n        });\n      },\n      hideCrosshair: function () {\n        this.cross && this.cross.hide();\n        h(this, \"afterHideCrosshair\");\n      }\n    });\n    return a.Axis = G;\n  });\n  I(H, \"parts/DateTimeAxis.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.Axis,\n        A = a.getMagnitude,\n        E = a.normalizeTickInterval,\n        m = a.timeUnits;\n\n    C.prototype.getTimeTicks = function () {\n      return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);\n    };\n\n    C.prototype.normalizeTimeTickInterval = function (a, v) {\n      var g = v || [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2]], [\"week\", [1, 2]], [\"month\", [1, 2, 3, 4, 6]], [\"year\", null]];\n      v = g[g.length - 1];\n      var y = m[v[0]],\n          z = v[1],\n          n;\n\n      for (n = 0; n < g.length && !(v = g[n], y = m[v[0]], z = v[1], g[n + 1] && a <= (y * z[z.length - 1] + m[g[n + 1][0]]) / 2); n++);\n\n      y === m.year && a < 5 * y && (z = [1, 2, 5]);\n      a = E(a / y, z, \"year\" === v[0] ? Math.max(A(a / y), 1) : 1);\n      return {\n        unitRange: y,\n        count: a,\n        unitName: v[0]\n      };\n    };\n  });\n  I(H, \"parts/LogarithmicAxis.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.Axis,\n        A = a.getMagnitude,\n        E = a.normalizeTickInterval,\n        m = a.pick;\n\n    C.prototype.getLogTickPositions = function (a, v, x, y) {\n      var g = this.options,\n          n = this.len,\n          f = [];\n      y || (this._minorAutoInterval = null);\n      if (.5 <= a) a = Math.round(a), f = this.getLinearTickPositions(a, v, x);else if (.08 <= a) for (var n = Math.floor(v), h, r, e, b, l, g = .3 < a ? [1, 2, 4] : .15 < a ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; n < x + 1 && !l; n++) for (r = g.length, h = 0; h < r && !l; h++) e = this.log2lin(this.lin2log(n) * g[h]), e > v && (!y || b <= x) && void 0 !== b && f.push(b), b > x && (l = !0), b = e;else v = this.lin2log(v), x = this.lin2log(x), a = y ? this.getMinorTickInterval() : g.tickInterval, a = m(\"auto\" === a ? null : a, this._minorAutoInterval, g.tickPixelInterval / (y ? 5 : 1) * (x - v) / ((y ? n / this.tickPositions.length : n) || 1)), a = E(a, null, A(a)), f = this.getLinearTickPositions(a, v, x).map(this.log2lin), y || (this._minorAutoInterval = a / 5);\n      y || (this.tickInterval = a);\n      return f;\n    };\n\n    C.prototype.log2lin = function (a) {\n      return Math.log(a) / Math.LN10;\n    };\n\n    C.prototype.lin2log = function (a) {\n      return Math.pow(10, a);\n    };\n  });\n  I(H, \"parts/PlotLineOrBand.js\", [H[\"parts/Globals.js\"], H[\"parts/Axis.js\"]], function (a, C) {\n    var A = a.arrayMax,\n        E = a.arrayMin,\n        m = a.defined,\n        g = a.destroyObjectProperties,\n        v = a.erase,\n        x = a.merge,\n        y = a.pick;\n\n    a.PlotLineOrBand = function (a, n) {\n      this.axis = a;\n      n && (this.options = n, this.id = n.id);\n    };\n\n    a.PlotLineOrBand.prototype = {\n      render: function () {\n        a.fireEvent(this, \"render\");\n        var g = this,\n            n = g.axis,\n            f = n.horiz,\n            h = g.options,\n            r = h.label,\n            e = g.label,\n            b = h.to,\n            l = h.from,\n            c = h.value,\n            t = m(l) && m(b),\n            F = m(c),\n            w = g.svgElem,\n            B = !w,\n            p = [],\n            d = h.color,\n            k = y(h.zIndex, 0),\n            u = h.events,\n            p = {\n          \"class\": \"highcharts-plot-\" + (t ? \"band \" : \"line \") + (h.className || \"\")\n        },\n            D = {},\n            G = n.chart.renderer,\n            q = t ? \"bands\" : \"lines\";\n        n.isLog && (l = n.log2lin(l), b = n.log2lin(b), c = n.log2lin(c));\n        n.chart.styledMode || (F ? (p.stroke = d, p[\"stroke-width\"] = h.width, h.dashStyle && (p.dashstyle = h.dashStyle)) : t && (d && (p.fill = d), h.borderWidth && (p.stroke = h.borderColor, p[\"stroke-width\"] = h.borderWidth)));\n        D.zIndex = k;\n        q += \"-\" + k;\n        (d = n.plotLinesAndBandsGroups[q]) || (n.plotLinesAndBandsGroups[q] = d = G.g(\"plot-\" + q).attr(D).add());\n        B && (g.svgElem = w = G.path().attr(p).add(d));\n        if (F) p = n.getPlotLinePath({\n          value: c,\n          lineWidth: w.strokeWidth(),\n          acrossPanes: h.acrossPanes\n        });else if (t) p = n.getPlotBandPath(l, b, h);else return;\n        (B || !w.d) && p && p.length ? (w.attr({\n          d: p\n        }), u && a.objectEach(u, function (a, d) {\n          w.on(d, function (a) {\n            u[d].apply(g, [a]);\n          });\n        })) : w && (p ? (w.show(!0), w.animate({\n          d: p\n        })) : w.d && (w.hide(), e && (g.label = e = e.destroy())));\n        r && m(r.text) && p && p.length && 0 < n.width && 0 < n.height && !p.isFlat ? (r = x({\n          align: f && t && \"center\",\n          x: f ? !t && 4 : 10,\n          verticalAlign: !f && t && \"middle\",\n          y: f ? t ? 16 : 10 : t ? 6 : -4,\n          rotation: f && !t && 90\n        }, r), this.renderLabel(r, p, t, k)) : e && e.hide();\n        return g;\n      },\n      renderLabel: function (a, g, f, h) {\n        var r = this.label,\n            e = this.axis.chart.renderer;\n        r || (r = {\n          align: a.textAlign || a.align,\n          rotation: a.rotation,\n          \"class\": \"highcharts-plot-\" + (f ? \"band\" : \"line\") + \"-label \" + (a.className || \"\")\n        }, r.zIndex = h, this.label = r = e.text(a.text, 0, 0, a.useHTML).attr(r).add(), this.axis.chart.styledMode || r.css(a.style));\n        h = g.xBounds || [g[1], g[4], f ? g[6] : g[1]];\n        g = g.yBounds || [g[2], g[5], f ? g[7] : g[2]];\n        f = E(h);\n        e = E(g);\n        r.align(a, !1, {\n          x: f,\n          y: e,\n          width: A(h) - f,\n          height: A(g) - e\n        });\n        r.show(!0);\n      },\n      destroy: function () {\n        v(this.axis.plotLinesAndBands, this);\n        delete this.axis;\n        g(this);\n      }\n    };\n    a.extend(C.prototype, {\n      getPlotBandPath: function (a, g) {\n        var f = this.getPlotLinePath({\n          value: g,\n          force: !0,\n          acrossPanes: this.options.acrossPanes\n        }),\n            h = this.getPlotLinePath({\n          value: a,\n          force: !0,\n          acrossPanes: this.options.acrossPanes\n        }),\n            r = [],\n            e = this.horiz,\n            b = 1,\n            l;\n        a = a < this.min && g < this.min || a > this.max && g > this.max;\n        if (h && f) for (a && (l = h.toString() === f.toString(), b = 0), a = 0; a < h.length; a += 6) e && f[a + 1] === h[a + 1] ? (f[a + 1] += b, f[a + 4] += b) : e || f[a + 2] !== h[a + 2] || (f[a + 2] += b, f[a + 5] += b), r.push(\"M\", h[a + 1], h[a + 2], \"L\", h[a + 4], h[a + 5], f[a + 4], f[a + 5], f[a + 1], f[a + 2], \"z\"), r.isFlat = l;\n        return r;\n      },\n      addPlotBand: function (a) {\n        return this.addPlotBandOrLine(a, \"plotBands\");\n      },\n      addPlotLine: function (a) {\n        return this.addPlotBandOrLine(a, \"plotLines\");\n      },\n      addPlotBandOrLine: function (g, n) {\n        var f = new a.PlotLineOrBand(this, g).render(),\n            h = this.userOptions;\n        f && (n && (h[n] = h[n] || [], h[n].push(g)), this.plotLinesAndBands.push(f));\n        return f;\n      },\n      removePlotBandOrLine: function (a) {\n        for (var g = this.plotLinesAndBands, f = this.options, h = this.userOptions, r = g.length; r--;) g[r].id === a && g[r].destroy();\n\n        [f.plotLines || [], h.plotLines || [], f.plotBands || [], h.plotBands || []].forEach(function (e) {\n          for (r = e.length; r--;) e[r].id === a && v(e, e[r]);\n        });\n      },\n      removePlotBand: function (a) {\n        this.removePlotBandOrLine(a);\n      },\n      removePlotLine: function (a) {\n        this.removePlotBandOrLine(a);\n      }\n    });\n  });\n  I(H, \"parts/Tooltip.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.doc,\n        A = a.extend,\n        E = a.format,\n        m = a.isNumber,\n        g = a.merge,\n        v = a.pick,\n        x = a.splat,\n        y = a.syncTimeout,\n        z = a.timeUnits;\n\n    a.Tooltip = function () {\n      this.init.apply(this, arguments);\n    };\n\n    a.Tooltip.prototype = {\n      init: function (a, f) {\n        this.chart = a;\n        this.options = f;\n        this.crosshairs = [];\n        this.now = {\n          x: 0,\n          y: 0\n        };\n        this.isHidden = !0;\n        this.split = f.split && !a.inverted;\n        this.shared = f.shared || this.split;\n        this.outside = v(f.outside, !(!a.scrollablePixelsX && !a.scrollablePixelsY)) && !this.split;\n      },\n      cleanSplit: function (a) {\n        this.chart.series.forEach(function (f) {\n          var h = f && f.tt;\n          h && (!h.isActive || a ? f.tt = h.destroy() : h.isActive = !1);\n        });\n      },\n      applyFilter: function () {\n        var a = this.chart;\n        a.renderer.definition({\n          tagName: \"filter\",\n          id: \"drop-shadow-\" + a.index,\n          opacity: .5,\n          children: [{\n            tagName: \"feGaussianBlur\",\n            \"in\": \"SourceAlpha\",\n            stdDeviation: 1\n          }, {\n            tagName: \"feOffset\",\n            dx: 1,\n            dy: 1\n          }, {\n            tagName: \"feComponentTransfer\",\n            children: [{\n              tagName: \"feFuncA\",\n              type: \"linear\",\n              slope: .3\n            }]\n          }, {\n            tagName: \"feMerge\",\n            children: [{\n              tagName: \"feMergeNode\"\n            }, {\n              tagName: \"feMergeNode\",\n              \"in\": \"SourceGraphic\"\n            }]\n          }]\n        });\n        a.renderer.definition({\n          tagName: \"style\",\n          textContent: \".highcharts-tooltip-\" + a.index + \"{filter:url(#drop-shadow-\" + a.index + \")}\"\n        });\n      },\n      getLabel: function () {\n        var g = this,\n            f = this.chart.renderer,\n            h = this.chart.styledMode,\n            r = this.options,\n            e,\n            b;\n        this.label || (this.outside && (this.container = e = a.doc.createElement(\"div\"), e.className = \"highcharts-tooltip-container\", a.css(e, {\n          position: \"absolute\",\n          top: \"1px\",\n          pointerEvents: r.style && r.style.pointerEvents,\n          zIndex: 3\n        }), a.doc.body.appendChild(e), this.renderer = f = new a.Renderer(e, 0, 0)), this.split ? this.label = f.g(\"tooltip\") : (this.label = f.label(\"\", 0, 0, r.shape || \"callout\", null, null, r.useHTML, null, \"tooltip\").attr({\n          padding: r.padding,\n          r: r.borderRadius\n        }), h || this.label.attr({\n          fill: r.backgroundColor,\n          \"stroke-width\": r.borderWidth\n        }).css(r.style).shadow(r.shadow)), h && (this.applyFilter(), this.label.addClass(\"highcharts-tooltip-\" + this.chart.index)), this.outside && (b = {\n          x: this.label.xSetter,\n          y: this.label.ySetter\n        }, this.label.xSetter = function (a, c) {\n          b[c].call(this.label, g.distance);\n          e.style.left = a + \"px\";\n        }, this.label.ySetter = function (a, c) {\n          b[c].call(this.label, g.distance);\n          e.style.top = a + \"px\";\n        }), this.label.attr({\n          zIndex: 8\n        }).add());\n        return this.label;\n      },\n      update: function (a) {\n        this.destroy();\n        g(!0, this.chart.options.tooltip.userOptions, a);\n        this.init(this.chart, g(!0, this.options, a));\n      },\n      destroy: function () {\n        this.label && (this.label = this.label.destroy());\n        this.split && this.tt && (this.cleanSplit(this.chart, !0), this.tt = this.tt.destroy());\n        this.renderer && (this.renderer = this.renderer.destroy(), a.discardElement(this.container));\n        a.clearTimeout(this.hideTimer);\n        a.clearTimeout(this.tooltipTimeout);\n      },\n      move: function (g, f, h, r) {\n        var e = this,\n            b = e.now,\n            l = !1 !== e.options.animation && !e.isHidden && (1 < Math.abs(g - b.x) || 1 < Math.abs(f - b.y)),\n            c = e.followPointer || 1 < e.len;\n        A(b, {\n          x: l ? (2 * b.x + g) / 3 : g,\n          y: l ? (b.y + f) / 2 : f,\n          anchorX: c ? void 0 : l ? (2 * b.anchorX + h) / 3 : h,\n          anchorY: c ? void 0 : l ? (b.anchorY + r) / 2 : r\n        });\n        e.getLabel().attr(b);\n        l && (a.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {\n          e && e.move(g, f, h, r);\n        }, 32));\n      },\n      hide: function (g) {\n        var f = this;\n        a.clearTimeout(this.hideTimer);\n        g = v(g, this.options.hideDelay, 500);\n        this.isHidden || (this.hideTimer = y(function () {\n          f.getLabel()[g ? \"fadeOut\" : \"hide\"]();\n          f.isHidden = !0;\n        }, g));\n      },\n      getAnchor: function (a, f) {\n        var h = this.chart,\n            r = h.pointer,\n            e = h.inverted,\n            b = h.plotTop,\n            l = h.plotLeft,\n            c = 0,\n            t = 0,\n            g,\n            w;\n        a = x(a);\n        this.followPointer && f ? (void 0 === f.chartX && (f = r.normalize(f)), a = [f.chartX - h.plotLeft, f.chartY - b]) : a[0].tooltipPos ? a = a[0].tooltipPos : (a.forEach(function (a) {\n          g = a.series.yAxis;\n          w = a.series.xAxis;\n          c += a.plotX + (!e && w ? w.left - l : 0);\n          t += (a.plotLow ? (a.plotLow + a.plotHigh) / 2 : a.plotY) + (!e && g ? g.top - b : 0);\n        }), c /= a.length, t /= a.length, a = [e ? h.plotWidth - t : c, this.shared && !e && 1 < a.length && f ? f.chartY - b : e ? h.plotHeight - c : t]);\n        return a.map(Math.round);\n      },\n      getPosition: function (a, f, h) {\n        var r = this.chart,\n            e = this.distance,\n            b = {},\n            l = r.inverted && h.h || 0,\n            c,\n            t = this.outside,\n            g = t ? C.documentElement.clientWidth - 2 * e : r.chartWidth,\n            w = t ? Math.max(C.body.scrollHeight, C.documentElement.scrollHeight, C.body.offsetHeight, C.documentElement.offsetHeight, C.documentElement.clientHeight) : r.chartHeight,\n            n = r.pointer.chartPosition,\n            p = [\"y\", w, f, (t ? n.top - e : 0) + h.plotY + r.plotTop, t ? 0 : r.plotTop, t ? w : r.plotTop + r.plotHeight],\n            d = [\"x\", g, a, (t ? n.left - e : 0) + h.plotX + r.plotLeft, t ? 0 : r.plotLeft, t ? g : r.plotLeft + r.plotWidth],\n            k = !this.followPointer && v(h.ttBelow, !r.inverted === !!h.negative),\n            u = function (a, d, c, u, q, t) {\n          var p = c < u - e,\n              h = u + e + c < d,\n              f = u - e - c;\n          u += e;\n          if (k && h) b[a] = u;else if (!k && p) b[a] = f;else if (p) b[a] = Math.min(t - c, 0 > f - l ? f : f - l);else if (h) b[a] = Math.max(q, u + l + c > d ? u : u + l);else return !1;\n        },\n            D = function (a, d, c, k) {\n          var u;\n          k < e || k > d - e ? u = !1 : b[a] = k < c / 2 ? 1 : k > d - c / 2 ? d - c - 2 : k - c / 2;\n          return u;\n        },\n            G = function (a) {\n          var b = p;\n          p = d;\n          d = b;\n          c = a;\n        },\n            q = function () {\n          !1 !== u.apply(0, p) ? !1 !== D.apply(0, d) || c || (G(!0), q()) : c ? b.x = b.y = 0 : (G(!0), q());\n        };\n\n        (r.inverted || 1 < this.len) && G();\n        q();\n        return b;\n      },\n      defaultFormatter: function (a) {\n        var f = this.points || x(this),\n            h;\n        h = [a.tooltipFooterHeaderFormatter(f[0])];\n        h = h.concat(a.bodyFormatter(f));\n        h.push(a.tooltipFooterHeaderFormatter(f[0], !0));\n        return h;\n      },\n      refresh: function (g, f) {\n        var h = this.chart,\n            r = this.options,\n            e,\n            b = g,\n            l,\n            c = {},\n            t,\n            n = [];\n        t = r.formatter || this.defaultFormatter;\n        var c = this.shared,\n            w = h.styledMode,\n            B = [];\n        r.enabled && (a.clearTimeout(this.hideTimer), this.followPointer = x(b)[0].series.tooltipOptions.followPointer, l = this.getAnchor(b, f), f = l[0], e = l[1], !c || b.series && b.series.noSharedTooltip ? c = b.getLabelConfig() : (B = h.pointer.getActiveSeries(b), h.series.forEach(function (a) {\n          (a.options.inactiveOtherPoints || -1 === B.indexOf(a)) && a.setState(\"inactive\", !0);\n        }), b.forEach(function (a) {\n          a.setState(\"hover\");\n          n.push(a.getLabelConfig());\n        }), c = {\n          x: b[0].category,\n          y: b[0].y\n        }, c.points = n, b = b[0]), this.len = n.length, t = t.call(c, this), c = b.series, this.distance = v(c.tooltipOptions.distance, 16), !1 === t ? this.hide() : (h = this.getLabel(), this.isHidden && h.attr({\n          opacity: 1\n        }).show(), this.split ? this.renderSplit(t, x(g)) : (r.style.width && !w || h.css({\n          width: this.chart.spacingBox.width\n        }), h.attr({\n          text: t && t.join ? t.join(\"\") : t\n        }), h.removeClass(/highcharts-color-[\\d]+/g).addClass(\"highcharts-color-\" + v(b.colorIndex, c.colorIndex)), w || h.attr({\n          stroke: r.borderColor || b.color || c.color || \"#666666\"\n        }), this.updatePosition({\n          plotX: f,\n          plotY: e,\n          negative: b.negative,\n          ttBelow: b.ttBelow,\n          h: l[2] || 0\n        })), this.isHidden = !1), a.fireEvent(this, \"refresh\"));\n      },\n      renderSplit: function (g, f) {\n        var h = this,\n            r = [],\n            e = this.chart,\n            b = e.renderer,\n            l = !0,\n            c = this.options,\n            t = 0,\n            n,\n            w = this.getLabel(),\n            B = e.plotTop;\n        a.isString(g) && (g = [!1, g]);\n        g.slice(0, f.length + 1).forEach(function (a, d) {\n          if (!1 !== a && \"\" !== a) {\n            d = f[d - 1] || {\n              isHeader: !0,\n              plotX: f[0].plotX,\n              plotY: e.plotHeight\n            };\n            var k = d.series || h,\n                u = k.tt,\n                p = d.series || {},\n                g = \"highcharts-color-\" + v(d.colorIndex, p.colorIndex, \"none\");\n            u || (u = {\n              padding: c.padding,\n              r: c.borderRadius\n            }, e.styledMode || (u.fill = c.backgroundColor, u[\"stroke-width\"] = c.borderWidth), k.tt = u = b.label(null, null, null, (d.isHeader ? c.headerShape : c.shape) || \"callout\", null, null, c.useHTML).addClass(\"highcharts-tooltip-box \" + g).attr(u).add(w));\n            u.isActive = !0;\n            u.attr({\n              text: a\n            });\n            e.styledMode || u.css(c.style).shadow(c.shadow).attr({\n              stroke: c.borderColor || d.color || p.color || \"#333333\"\n            });\n            a = u.getBBox();\n            p = a.width + u.strokeWidth();\n            d.isHeader ? (t = a.height, e.xAxis[0].opposite && (n = !0, B -= t), p = Math.max(0, Math.min(d.plotX + e.plotLeft - p / 2, e.chartWidth + (e.scrollablePixelsX ? e.scrollablePixelsX - e.marginRight : 0) - p))) : p = d.plotX + e.plotLeft - v(c.distance, 16) - p;\n            0 > p && (l = !1);\n            a = (d.series && d.series.yAxis && d.series.yAxis.pos) + (d.plotY || 0);\n            a -= B;\n            d.isHeader && (a = n ? -t : e.plotHeight + t);\n            r.push({\n              target: a,\n              rank: d.isHeader ? 1 : 0,\n              size: k.tt.getBBox().height + 1,\n              point: d,\n              x: p,\n              tt: u\n            });\n          }\n        });\n        this.cleanSplit();\n        c.positioner && r.forEach(function (a) {\n          var d = c.positioner.call(h, a.tt.getBBox().width, a.size, a.point);\n          a.x = d.x;\n          a.align = 0;\n          a.target = d.y;\n          a.rank = v(d.rank, a.rank);\n        });\n        a.distribute(r, e.plotHeight + t);\n        r.forEach(function (a) {\n          var d = a.point,\n              b = d.series;\n          a.tt.attr({\n            visibility: void 0 === a.pos ? \"hidden\" : \"inherit\",\n            x: l || d.isHeader || c.positioner ? a.x : d.plotX + e.plotLeft + h.distance,\n            y: a.pos + B,\n            anchorX: d.isHeader ? d.plotX + e.plotLeft : d.plotX + b.xAxis.pos,\n            anchorY: d.isHeader ? e.plotTop + e.plotHeight / 2 : d.plotY + b.yAxis.pos\n          });\n        });\n      },\n      updatePosition: function (a) {\n        var f = this.chart,\n            h = this.getLabel(),\n            r = (this.options.positioner || this.getPosition).call(this, h.width, h.height, a),\n            e = a.plotX + f.plotLeft;\n        a = a.plotY + f.plotTop;\n        var b;\n        this.outside && (b = (this.options.borderWidth || 0) + 2 * this.distance, this.renderer.setSize(h.width + b, h.height + b, !1), e += f.pointer.chartPosition.left - r.x, a += f.pointer.chartPosition.top - r.y);\n        this.move(Math.round(r.x), Math.round(r.y || 0), e, a);\n      },\n      getDateFormat: function (a, f, h, r) {\n        var e = this.chart.time,\n            b = e.dateFormat(\"%m-%d %H:%M:%S.%L\", f),\n            l,\n            c,\n            t = {\n          millisecond: 15,\n          second: 12,\n          minute: 9,\n          hour: 6,\n          day: 3\n        },\n            g = \"millisecond\";\n\n        for (c in z) {\n          if (a === z.week && +e.dateFormat(\"%w\", f) === h && \"00:00:00.000\" === b.substr(6)) {\n            c = \"week\";\n            break;\n          }\n\n          if (z[c] > a) {\n            c = g;\n            break;\n          }\n\n          if (t[c] && b.substr(t[c]) !== \"01-01 00:00:00.000\".substr(t[c])) break;\n          \"week\" !== c && (g = c);\n        }\n\n        c && (l = e.resolveDTLFormat(r[c]).main);\n        return l;\n      },\n      getXDateFormat: function (a, f, h) {\n        f = f.dateTimeLabelFormats;\n        var r = h && h.closestPointRange;\n        return (r ? this.getDateFormat(r, a.x, h.options.startOfWeek, f) : f.day) || f.year;\n      },\n      tooltipFooterHeaderFormatter: function (g, f) {\n        var h = f ? \"footer\" : \"header\",\n            r = g.series,\n            e = r.tooltipOptions,\n            b = e.xDateFormat,\n            l = r.xAxis,\n            c = l && \"datetime\" === l.options.type && m(g.key),\n            t = e[h + \"Format\"];\n        f = {\n          isFooter: f,\n          labelConfig: g\n        };\n        a.fireEvent(this, \"headerFormatter\", f, function (a) {\n          c && !b && (b = this.getXDateFormat(g, e, l));\n          c && b && (g.point && g.point.tooltipDateKeys || [\"key\"]).forEach(function (a) {\n            t = t.replace(\"{point.\" + a + \"}\", \"{point.\" + a + \":\" + b + \"}\");\n          });\n          r.chart.styledMode && (t = this.styledModeFormat(t));\n          a.text = E(t, {\n            point: g,\n            series: r\n          }, this.chart.time);\n        });\n        return f.text;\n      },\n      bodyFormatter: function (a) {\n        return a.map(function (a) {\n          var h = a.series.tooltipOptions;\n          return (h[(a.point.formatPrefix || \"point\") + \"Formatter\"] || a.point.tooltipFormatter).call(a.point, h[(a.point.formatPrefix || \"point\") + \"Format\"] || \"\");\n        });\n      },\n      styledModeFormat: function (a) {\n        return a.replace('style\\x3d\"font-size: 10px\"', 'class\\x3d\"highcharts-header\"').replace(/style=\"color:{(point|series)\\.color}\"/g, 'class\\x3d\"highcharts-color-{$1.colorIndex}\"');\n      }\n    };\n  });\n  I(H, \"parts/Pointer.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.addEvent,\n        A = a.attr,\n        E = a.charts,\n        m = a.color,\n        g = a.css,\n        v = a.defined,\n        x = a.extend,\n        y = a.find,\n        z = a.fireEvent,\n        n = a.isNumber,\n        f = a.isObject,\n        h = a.offset,\n        r = a.pick,\n        e = a.splat,\n        b = a.Tooltip;\n\n    a.Pointer = function (a, b) {\n      this.init(a, b);\n    };\n\n    a.Pointer.prototype = {\n      init: function (a, c) {\n        this.options = c;\n        this.chart = a;\n        this.runChartClick = c.chart.events && !!c.chart.events.click;\n        this.pinchDown = [];\n        this.lastValidTouch = {};\n        b && (a.tooltip = new b(a, c.tooltip), this.followTouchMove = r(c.tooltip.followTouchMove, !0));\n        this.setDOMEvents();\n      },\n      zoomOption: function (a) {\n        var b = this.chart,\n            e = b.options.chart,\n            l = e.zoomType || \"\",\n            b = b.inverted;\n        /touch/.test(a.type) && (l = r(e.pinchType, l));\n        this.zoomX = a = /x/.test(l);\n        this.zoomY = l = /y/.test(l);\n        this.zoomHor = a && !b || l && b;\n        this.zoomVert = l && !b || a && b;\n        this.hasZoom = a || l;\n      },\n      normalize: function (a, b) {\n        var c;\n        c = a.touches ? a.touches.length ? a.touches.item(0) : a.changedTouches[0] : a;\n        b || (this.chartPosition = b = h(this.chart.container));\n        return x(a, {\n          chartX: Math.round(c.pageX - b.left),\n          chartY: Math.round(c.pageY - b.top)\n        });\n      },\n      getCoordinates: function (a) {\n        var b = {\n          xAxis: [],\n          yAxis: []\n        };\n        this.chart.axes.forEach(function (c) {\n          b[c.isXAxis ? \"xAxis\" : \"yAxis\"].push({\n            axis: c,\n            value: c.toValue(a[c.horiz ? \"chartX\" : \"chartY\"])\n          });\n        });\n        return b;\n      },\n      findNearestKDPoint: function (a, b, e) {\n        var c;\n        a.forEach(function (a) {\n          var l = !(a.noSharedTooltip && b) && 0 > a.options.findNearestPointBy.indexOf(\"y\");\n          a = a.searchPoint(e, l);\n          if ((l = f(a, !0)) && !(l = !f(c, !0))) var l = c.distX - a.distX,\n              t = c.dist - a.dist,\n              d = (a.series.group && a.series.group.zIndex) - (c.series.group && c.series.group.zIndex),\n              l = 0 < (0 !== l && b ? l : 0 !== t ? t : 0 !== d ? d : c.series.index > a.series.index ? -1 : 1);\n          l && (c = a);\n        });\n        return c;\n      },\n      getPointFromEvent: function (a) {\n        a = a.target;\n\n        for (var b; a && !b;) b = a.point, a = a.parentNode;\n\n        return b;\n      },\n      getChartCoordinatesFromPoint: function (a, b) {\n        var c = a.series,\n            e = c.xAxis,\n            c = c.yAxis,\n            l = r(a.clientX, a.plotX),\n            h = a.shapeArgs;\n        if (e && c) return b ? {\n          chartX: e.len + e.pos - l,\n          chartY: c.len + c.pos - a.plotY\n        } : {\n          chartX: l + e.pos,\n          chartY: a.plotY + c.pos\n        };\n        if (h && h.x && h.y) return {\n          chartX: h.x,\n          chartY: h.y\n        };\n      },\n      getHoverData: function (a, b, e, h, w, g) {\n        var c,\n            d = [];\n        h = !(!h || !a);\n        var k = b && !b.stickyTracking ? [b] : e.filter(function (a) {\n          return a.visible && !(!w && a.directTouch) && r(a.options.enableMouseTracking, !0) && a.stickyTracking;\n        });\n        b = (c = h ? a : this.findNearestKDPoint(k, w, g)) && c.series;\n        c && (w && !b.noSharedTooltip ? (k = e.filter(function (a) {\n          return a.visible && !(!w && a.directTouch) && r(a.options.enableMouseTracking, !0) && !a.noSharedTooltip;\n        }), k.forEach(function (a) {\n          var b = y(a.points, function (a) {\n            return a.x === c.x && !a.isNull;\n          });\n          f(b) && (a.chart.isBoosting && (b = a.getPoint(b)), d.push(b));\n        })) : d.push(c));\n        return {\n          hoverPoint: c,\n          hoverSeries: b,\n          hoverPoints: d\n        };\n      },\n      runPointActions: function (b, c) {\n        var e = this.chart,\n            l = e.tooltip && e.tooltip.options.enabled ? e.tooltip : void 0,\n            h = l ? l.shared : !1,\n            f = c || e.hoverPoint,\n            p = f && f.series || e.hoverSeries,\n            p = this.getHoverData(f, p, e.series, \"touchmove\" !== b.type && (!!c || p && p.directTouch && this.isDirectTouch), h, b),\n            d = [],\n            k,\n            f = p.hoverPoint;\n        k = p.hoverPoints;\n        c = (p = p.hoverSeries) && p.tooltipOptions.followPointer;\n        h = h && p && !p.noSharedTooltip;\n\n        if (f && (f !== e.hoverPoint || l && l.isHidden)) {\n          (e.hoverPoints || []).forEach(function (a) {\n            -1 === k.indexOf(a) && a.setState();\n          });\n          if (e.hoverSeries !== p) p.onMouseOver();\n          d = this.getActiveSeries(k);\n          e.series.forEach(function (a) {\n            (a.options.inactiveOtherPoints || -1 === d.indexOf(a)) && a.setState(\"inactive\", !0);\n          });\n          (k || []).forEach(function (a) {\n            a.setState(\"hover\");\n          });\n          e.hoverPoint && e.hoverPoint.firePointEvent(\"mouseOut\");\n          if (!f.series) return;\n          f.firePointEvent(\"mouseOver\");\n          e.hoverPoints = k;\n          e.hoverPoint = f;\n          l && l.refresh(h ? k : f, b);\n        } else c && l && !l.isHidden && (f = l.getAnchor([{}], b), l.updatePosition({\n          plotX: f[0],\n          plotY: f[1]\n        }));\n\n        this.unDocMouseMove || (this.unDocMouseMove = C(e.container.ownerDocument, \"mousemove\", function (d) {\n          var b = E[a.hoverChartIndex];\n          if (b) b.pointer.onDocumentMouseMove(d);\n        }));\n        e.axes.forEach(function (d) {\n          var c = r(d.crosshair.snap, !0),\n              e = c ? a.find(k, function (a) {\n            return a.series[d.coll] === d;\n          }) : void 0;\n          e || !c ? d.drawCrosshair(b, e) : d.hideCrosshair();\n        });\n      },\n      getActiveSeries: function (a) {\n        var b = [],\n            e;\n        (a || []).forEach(function (a) {\n          e = a.series;\n          b.push(e);\n          e.linkedParent && b.push(e.linkedParent);\n          e.linkedSeries && (b = b.concat(e.linkedSeries));\n          e.navigatorSeries && b.push(e.navigatorSeries);\n        });\n        return b;\n      },\n      reset: function (a, b) {\n        var c = this.chart,\n            l = c.hoverSeries,\n            h = c.hoverPoint,\n            f = c.hoverPoints,\n            p = c.tooltip,\n            d = p && p.shared ? f : h;\n        a && d && e(d).forEach(function (d) {\n          d.series.isCartesian && void 0 === d.plotX && (a = !1);\n        });\n        if (a) p && d && e(d).length && (p.refresh(d), p.shared && f ? f.forEach(function (a) {\n          a.setState(a.state, !0);\n          a.series.isCartesian && (a.series.xAxis.crosshair && a.series.xAxis.drawCrosshair(null, a), a.series.yAxis.crosshair && a.series.yAxis.drawCrosshair(null, a));\n        }) : h && (h.setState(h.state, !0), c.axes.forEach(function (a) {\n          a.crosshair && a.drawCrosshair(null, h);\n        })));else {\n          if (h) h.onMouseOut();\n          f && f.forEach(function (a) {\n            a.setState();\n          });\n          if (l) l.onMouseOut();\n          p && p.hide(b);\n          this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());\n          c.axes.forEach(function (a) {\n            a.hideCrosshair();\n          });\n          this.hoverX = c.hoverPoints = c.hoverPoint = null;\n        }\n      },\n      scaleGroups: function (a, b) {\n        var c = this.chart,\n            e;\n        c.series.forEach(function (l) {\n          e = a || l.getPlotBox();\n          l.xAxis && l.xAxis.zoomEnabled && l.group && (l.group.attr(e), l.markerGroup && (l.markerGroup.attr(e), l.markerGroup.clip(b ? c.clipRect : null)), l.dataLabelsGroup && l.dataLabelsGroup.attr(e));\n        });\n        c.clipRect.attr(b || c.clipBox);\n      },\n      dragStart: function (a) {\n        var b = this.chart;\n        b.mouseIsDown = a.type;\n        b.cancelClick = !1;\n        b.mouseDownX = this.mouseDownX = a.chartX;\n        b.mouseDownY = this.mouseDownY = a.chartY;\n      },\n      drag: function (a) {\n        var b = this.chart,\n            e = b.options.chart,\n            l = a.chartX,\n            h = a.chartY,\n            f = this.zoomHor,\n            p = this.zoomVert,\n            d = b.plotLeft,\n            k = b.plotTop,\n            u = b.plotWidth,\n            g = b.plotHeight,\n            r,\n            q = this.selectionMarker,\n            n = this.mouseDownX,\n            v = this.mouseDownY,\n            x = e.panKey && a[e.panKey + \"Key\"];\n        q && q.touch || (l < d ? l = d : l > d + u && (l = d + u), h < k ? h = k : h > k + g && (h = k + g), this.hasDragged = Math.sqrt(Math.pow(n - l, 2) + Math.pow(v - h, 2)), 10 < this.hasDragged && (r = b.isInsidePlot(n - d, v - k), b.hasCartesianSeries && (this.zoomX || this.zoomY) && r && !x && !q && (this.selectionMarker = q = b.renderer.rect(d, k, f ? 1 : u, p ? 1 : g, 0).attr({\n          \"class\": \"highcharts-selection-marker\",\n          zIndex: 7\n        }).add(), b.styledMode || q.attr({\n          fill: e.selectionMarkerFill || m(\"#335cad\").setOpacity(.25).get()\n        })), q && f && (l -= n, q.attr({\n          width: Math.abs(l),\n          x: (0 < l ? 0 : l) + n\n        })), q && p && (l = h - v, q.attr({\n          height: Math.abs(l),\n          y: (0 < l ? 0 : l) + v\n        })), r && !q && e.panning && b.pan(a, e.panning)));\n      },\n      drop: function (a) {\n        var b = this,\n            e = this.chart,\n            l = this.hasPinched;\n\n        if (this.selectionMarker) {\n          var h = {\n            originalEvent: a,\n            xAxis: [],\n            yAxis: []\n          },\n              f = this.selectionMarker,\n              p = f.attr ? f.attr(\"x\") : f.x,\n              d = f.attr ? f.attr(\"y\") : f.y,\n              k = f.attr ? f.attr(\"width\") : f.width,\n              u = f.attr ? f.attr(\"height\") : f.height,\n              r;\n          if (this.hasDragged || l) e.axes.forEach(function (c) {\n            if (c.zoomEnabled && v(c.min) && (l || b[{\n              xAxis: \"zoomX\",\n              yAxis: \"zoomY\"\n            }[c.coll]])) {\n              var e = c.horiz,\n                  t = \"touchend\" === a.type ? c.minPixelPadding : 0,\n                  f = c.toValue((e ? p : d) + t),\n                  e = c.toValue((e ? p + k : d + u) - t);\n              h[c.coll].push({\n                axis: c,\n                min: Math.min(f, e),\n                max: Math.max(f, e)\n              });\n              r = !0;\n            }\n          }), r && z(e, \"selection\", h, function (a) {\n            e.zoom(x(a, l ? {\n              animation: !1\n            } : null));\n          });\n          n(e.index) && (this.selectionMarker = this.selectionMarker.destroy());\n          l && this.scaleGroups();\n        }\n\n        e && n(e.index) && (g(e.container, {\n          cursor: e._cursor\n        }), e.cancelClick = 10 < this.hasDragged, e.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);\n      },\n      onContainerMouseDown: function (a) {\n        a = this.normalize(a);\n        2 !== a.button && (this.zoomOption(a), a.preventDefault && a.preventDefault(), this.dragStart(a));\n      },\n      onDocumentMouseUp: function (b) {\n        E[a.hoverChartIndex] && E[a.hoverChartIndex].pointer.drop(b);\n      },\n      onDocumentMouseMove: function (a) {\n        var b = this.chart,\n            e = this.chartPosition;\n        a = this.normalize(a, e);\n        !e || this.inClass(a.target, \"highcharts-tracker\") || b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) || this.reset();\n      },\n      onContainerMouseLeave: function (b) {\n        var c = E[a.hoverChartIndex];\n        c && (b.relatedTarget || b.toElement) && (c.pointer.reset(), c.pointer.chartPosition = null);\n      },\n      onContainerMouseMove: function (b) {\n        var c = this.chart;\n        v(a.hoverChartIndex) && E[a.hoverChartIndex] && E[a.hoverChartIndex].mouseIsDown || (a.hoverChartIndex = c.index);\n        b = this.normalize(b);\n        b.preventDefault || (b.returnValue = !1);\n        \"mousedown\" === c.mouseIsDown && this.drag(b);\n        !this.inClass(b.target, \"highcharts-tracker\") && !c.isInsidePlot(b.chartX - c.plotLeft, b.chartY - c.plotTop) || c.openMenu || this.runPointActions(b);\n      },\n      inClass: function (a, b) {\n        for (var c; a;) {\n          if (c = A(a, \"class\")) {\n            if (-1 !== c.indexOf(b)) return !0;\n            if (-1 !== c.indexOf(\"highcharts-container\")) return !1;\n          }\n\n          a = a.parentNode;\n        }\n      },\n      onTrackerMouseOut: function (a) {\n        var b = this.chart.hoverSeries;\n        a = a.relatedTarget || a.toElement;\n        this.isDirectTouch = !1;\n        if (!(!b || !a || b.stickyTracking || this.inClass(a, \"highcharts-tooltip\") || this.inClass(a, \"highcharts-series-\" + b.index) && this.inClass(a, \"highcharts-tracker\"))) b.onMouseOut();\n      },\n      onContainerClick: function (a) {\n        var b = this.chart,\n            e = b.hoverPoint,\n            l = b.plotLeft,\n            f = b.plotTop;\n        a = this.normalize(a);\n        b.cancelClick || (e && this.inClass(a.target, \"highcharts-tracker\") ? (z(e.series, \"click\", x(a, {\n          point: e\n        })), b.hoverPoint && e.firePointEvent(\"click\", a)) : (x(a, this.getCoordinates(a)), b.isInsidePlot(a.chartX - l, a.chartY - f) && z(b, \"click\", a)));\n      },\n      setDOMEvents: function () {\n        var b = this,\n            c = b.chart.container,\n            e = c.ownerDocument;\n\n        c.onmousedown = function (a) {\n          b.onContainerMouseDown(a);\n        };\n\n        c.onmousemove = function (a) {\n          b.onContainerMouseMove(a);\n        };\n\n        c.onclick = function (a) {\n          b.onContainerClick(a);\n        };\n\n        this.unbindContainerMouseLeave = C(c, \"mouseleave\", b.onContainerMouseLeave);\n        a.unbindDocumentMouseUp || (a.unbindDocumentMouseUp = C(e, \"mouseup\", b.onDocumentMouseUp));\n        a.hasTouch && (c.ontouchstart = function (a) {\n          b.onContainerTouchStart(a);\n        }, c.ontouchmove = function (a) {\n          b.onContainerTouchMove(a);\n        }, a.unbindDocumentTouchEnd || (a.unbindDocumentTouchEnd = C(e, \"touchend\", b.onDocumentTouchEnd)));\n      },\n      destroy: function () {\n        var b = this;\n        b.unDocMouseMove && b.unDocMouseMove();\n        this.unbindContainerMouseLeave();\n        a.chartCount || (a.unbindDocumentMouseUp && (a.unbindDocumentMouseUp = a.unbindDocumentMouseUp()), a.unbindDocumentTouchEnd && (a.unbindDocumentTouchEnd = a.unbindDocumentTouchEnd()));\n        clearInterval(b.tooltipTimeout);\n        a.objectEach(b, function (a, e) {\n          b[e] = null;\n        });\n      }\n    };\n  });\n  I(H, \"parts/TouchPointer.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.charts,\n        A = a.extend,\n        E = a.noop,\n        m = a.pick;\n    A(a.Pointer.prototype, {\n      pinchTranslate: function (a, m, x, y, z, n) {\n        this.zoomHor && this.pinchTranslateDirection(!0, a, m, x, y, z, n);\n        this.zoomVert && this.pinchTranslateDirection(!1, a, m, x, y, z, n);\n      },\n      pinchTranslateDirection: function (a, m, x, y, z, n, f, h) {\n        var r = this.chart,\n            e = a ? \"x\" : \"y\",\n            b = a ? \"X\" : \"Y\",\n            l = \"chart\" + b,\n            c = a ? \"width\" : \"height\",\n            t = r[\"plot\" + (a ? \"Left\" : \"Top\")],\n            g,\n            w,\n            B = h || 1,\n            p = r.inverted,\n            d = r.bounds[a ? \"h\" : \"v\"],\n            k = 1 === m.length,\n            u = m[0][l],\n            D = x[0][l],\n            G = !k && m[1][l],\n            q = !k && x[1][l],\n            K;\n\n        x = function () {\n          !k && 20 < Math.abs(u - G) && (B = h || Math.abs(D - q) / Math.abs(u - G));\n          w = (t - D) / B + u;\n          g = r[\"plot\" + (a ? \"Width\" : \"Height\")] / B;\n        };\n\n        x();\n        m = w;\n        m < d.min ? (m = d.min, K = !0) : m + g > d.max && (m = d.max - g, K = !0);\n        K ? (D -= .8 * (D - f[e][0]), k || (q -= .8 * (q - f[e][1])), x()) : f[e] = [D, q];\n        p || (n[e] = w - t, n[c] = g);\n        n = p ? 1 / B : B;\n        z[c] = g;\n        z[e] = m;\n        y[p ? a ? \"scaleY\" : \"scaleX\" : \"scale\" + b] = B;\n        y[\"translate\" + b] = n * t + (D - n * u);\n      },\n      pinch: function (a) {\n        var g = this,\n            x = g.chart,\n            y = g.pinchDown,\n            z = a.touches,\n            n = z.length,\n            f = g.lastValidTouch,\n            h = g.hasZoom,\n            r = g.selectionMarker,\n            e = {},\n            b = 1 === n && (g.inClass(a.target, \"highcharts-tracker\") && x.runTrackerClick || g.runChartClick),\n            l = {};\n        1 < n && (g.initiated = !0);\n        h && g.initiated && !b && a.preventDefault();\n        [].map.call(z, function (a) {\n          return g.normalize(a);\n        });\n        \"touchstart\" === a.type ? ([].forEach.call(z, function (a, b) {\n          y[b] = {\n            chartX: a.chartX,\n            chartY: a.chartY\n          };\n        }), f.x = [y[0].chartX, y[1] && y[1].chartX], f.y = [y[0].chartY, y[1] && y[1].chartY], x.axes.forEach(function (a) {\n          if (a.zoomEnabled) {\n            var b = x.bounds[a.horiz ? \"h\" : \"v\"],\n                c = a.minPixelPadding,\n                e = a.toPixels(Math.min(m(a.options.min, a.dataMin), a.dataMin)),\n                l = a.toPixels(Math.max(m(a.options.max, a.dataMax), a.dataMax)),\n                p = Math.max(e, l);\n            b.min = Math.min(a.pos, Math.min(e, l) - c);\n            b.max = Math.max(a.pos + a.len, p + c);\n          }\n        }), g.res = !0) : g.followTouchMove && 1 === n ? this.runPointActions(g.normalize(a)) : y.length && (r || (g.selectionMarker = r = A({\n          destroy: E,\n          touch: !0\n        }, x.plotBox)), g.pinchTranslate(y, z, e, r, l, f), g.hasPinched = h, g.scaleGroups(e, l), g.res && (g.res = !1, this.reset(!1, 0)));\n      },\n      touch: function (g, v) {\n        var x = this.chart,\n            y,\n            z;\n        if (x.index !== a.hoverChartIndex) this.onContainerMouseLeave({\n          relatedTarget: !0\n        });\n        a.hoverChartIndex = x.index;\n        1 === g.touches.length ? (g = this.normalize(g), (z = x.isInsidePlot(g.chartX - x.plotLeft, g.chartY - x.plotTop)) && !x.openMenu ? (v && this.runPointActions(g), \"touchmove\" === g.type && (v = this.pinchDown, y = v[0] ? 4 <= Math.sqrt(Math.pow(v[0].chartX - g.chartX, 2) + Math.pow(v[0].chartY - g.chartY, 2)) : !1), m(y, !0) && this.pinch(g)) : v && this.reset()) : 2 === g.touches.length && this.pinch(g);\n      },\n      onContainerTouchStart: function (a) {\n        this.zoomOption(a);\n        this.touch(a, !0);\n      },\n      onContainerTouchMove: function (a) {\n        this.touch(a);\n      },\n      onDocumentTouchEnd: function (g) {\n        C[a.hoverChartIndex] && C[a.hoverChartIndex].pointer.drop(g);\n      }\n    });\n  });\n  I(H, \"parts/MSPointer.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.addEvent,\n        A = a.charts,\n        E = a.css,\n        m = a.doc,\n        g = a.extend,\n        v = a.noop,\n        x = a.Pointer,\n        y = a.removeEvent,\n        z = a.win,\n        n = a.wrap;\n\n    if (!a.hasTouch && (z.PointerEvent || z.MSPointerEvent)) {\n      var f = {},\n          h = !!z.PointerEvent,\n          r = function () {\n        var b = [];\n\n        b.item = function (a) {\n          return this[a];\n        };\n\n        a.objectEach(f, function (a) {\n          b.push({\n            pageX: a.pageX,\n            pageY: a.pageY,\n            target: a.target\n          });\n        });\n        return b;\n      },\n          e = function (b, e, c, f) {\n        \"touch\" !== b.pointerType && b.pointerType !== b.MSPOINTER_TYPE_TOUCH || !A[a.hoverChartIndex] || (f(b), f = A[a.hoverChartIndex].pointer, f[e]({\n          type: c,\n          target: b.currentTarget,\n          preventDefault: v,\n          touches: r()\n        }));\n      };\n\n      g(x.prototype, {\n        onContainerPointerDown: function (a) {\n          e(a, \"onContainerTouchStart\", \"touchstart\", function (a) {\n            f[a.pointerId] = {\n              pageX: a.pageX,\n              pageY: a.pageY,\n              target: a.currentTarget\n            };\n          });\n        },\n        onContainerPointerMove: function (a) {\n          e(a, \"onContainerTouchMove\", \"touchmove\", function (a) {\n            f[a.pointerId] = {\n              pageX: a.pageX,\n              pageY: a.pageY\n            };\n            f[a.pointerId].target || (f[a.pointerId].target = a.currentTarget);\n          });\n        },\n        onDocumentPointerUp: function (a) {\n          e(a, \"onDocumentTouchEnd\", \"touchend\", function (a) {\n            delete f[a.pointerId];\n          });\n        },\n        batchMSEvents: function (a) {\n          a(this.chart.container, h ? \"pointerdown\" : \"MSPointerDown\", this.onContainerPointerDown);\n          a(this.chart.container, h ? \"pointermove\" : \"MSPointerMove\", this.onContainerPointerMove);\n          a(m, h ? \"pointerup\" : \"MSPointerUp\", this.onDocumentPointerUp);\n        }\n      });\n      n(x.prototype, \"init\", function (a, e, c) {\n        a.call(this, e, c);\n        this.hasZoom && E(e.container, {\n          \"-ms-touch-action\": \"none\",\n          \"touch-action\": \"none\"\n        });\n      });\n      n(x.prototype, \"setDOMEvents\", function (a) {\n        a.apply(this);\n        (this.hasZoom || this.followTouchMove) && this.batchMSEvents(C);\n      });\n      n(x.prototype, \"destroy\", function (a) {\n        this.batchMSEvents(y);\n        a.call(this);\n      });\n    }\n  });\n  I(H, \"parts/Legend.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.addEvent,\n        A = a.css,\n        E = a.discardElement,\n        m = a.defined,\n        g = a.fireEvent,\n        v = a.isFirefox,\n        x = a.marginNames,\n        y = a.merge,\n        z = a.pick,\n        n = a.setAnimation,\n        f = a.stableSort,\n        h = a.win,\n        r = a.wrap;\n\n    a.Legend = function (a, b) {\n      this.init(a, b);\n    };\n\n    a.Legend.prototype = {\n      init: function (a, b) {\n        this.chart = a;\n        this.setOptions(b);\n        b.enabled && (this.render(), C(this.chart, \"endResize\", function () {\n          this.legend.positionCheckboxes();\n        }), this.proximate ? this.unchartrender = C(this.chart, \"render\", function () {\n          this.legend.proximatePositions();\n          this.legend.positionItems();\n        }) : this.unchartrender && this.unchartrender());\n      },\n      setOptions: function (a) {\n        var b = z(a.padding, 8);\n        this.options = a;\n        this.chart.styledMode || (this.itemStyle = a.itemStyle, this.itemHiddenStyle = y(this.itemStyle, a.itemHiddenStyle));\n        this.itemMarginTop = a.itemMarginTop || 0;\n        this.padding = b;\n        this.initialItemY = b - 5;\n        this.symbolWidth = z(a.symbolWidth, 16);\n        this.pages = [];\n        this.proximate = \"proximate\" === a.layout && !this.chart.inverted;\n      },\n      update: function (a, b) {\n        var e = this.chart;\n        this.setOptions(y(!0, this.options, a));\n        this.destroy();\n        e.isDirtyLegend = e.isDirtyBox = !0;\n        z(b, !0) && e.redraw();\n        g(this, \"afterUpdate\");\n      },\n      colorizeItem: function (a, b) {\n        a.legendGroup[b ? \"removeClass\" : \"addClass\"](\"highcharts-legend-item-hidden\");\n\n        if (!this.chart.styledMode) {\n          var e = this.options,\n              c = a.legendItem,\n              f = a.legendLine,\n              h = a.legendSymbol,\n              r = this.itemHiddenStyle.color,\n              e = b ? e.itemStyle.color : r,\n              n = b ? a.color || r : r,\n              p = a.options && a.options.marker,\n              d = {\n            fill: n\n          };\n          c && c.css({\n            fill: e,\n            color: e\n          });\n          f && f.attr({\n            stroke: n\n          });\n          h && (p && h.isMarker && (d = a.pointAttribs(), b || (d.stroke = d.fill = r)), h.attr(d));\n        }\n\n        g(this, \"afterColorizeItem\", {\n          item: a,\n          visible: b\n        });\n      },\n      positionItems: function () {\n        this.allItems.forEach(this.positionItem, this);\n        this.chart.isResizing || this.positionCheckboxes();\n      },\n      positionItem: function (a) {\n        var b = this.options,\n            e = b.symbolPadding,\n            b = !b.rtl,\n            c = a._legendItemPos,\n            f = c[0],\n            c = c[1],\n            h = a.checkbox;\n        if ((a = a.legendGroup) && a.element) a[m(a.translateY) ? \"animate\" : \"attr\"]({\n          translateX: b ? f : this.legendWidth - f - 2 * e - 4,\n          translateY: c\n        });\n        h && (h.x = f, h.y = c);\n      },\n      destroyItem: function (a) {\n        var b = a.checkbox;\n        [\"legendItem\", \"legendLine\", \"legendSymbol\", \"legendGroup\"].forEach(function (b) {\n          a[b] && (a[b] = a[b].destroy());\n        });\n        b && E(a.checkbox);\n      },\n      destroy: function () {\n        function a(a) {\n          this[a] && (this[a] = this[a].destroy());\n        }\n\n        this.getAllItems().forEach(function (b) {\n          [\"legendItem\", \"legendGroup\"].forEach(a, b);\n        });\n        \"clipRect up down pager nav box title group\".split(\" \").forEach(a, this);\n        this.display = null;\n      },\n      positionCheckboxes: function () {\n        var a = this.group && this.group.alignAttr,\n            b,\n            f = this.clipHeight || this.legendHeight,\n            c = this.titleHeight;\n        a && (b = a.translateY, this.allItems.forEach(function (e) {\n          var h = e.checkbox,\n              l;\n          h && (l = b + c + h.y + (this.scrollOffset || 0) + 3, A(h, {\n            left: a.translateX + e.checkboxOffset + h.x - 20 + \"px\",\n            top: l + \"px\",\n            display: this.proximate || l > b - 6 && l < b + f - 6 ? \"\" : \"none\"\n          }));\n        }, this));\n      },\n      renderTitle: function () {\n        var a = this.options,\n            b = this.padding,\n            f = a.title,\n            c = 0;\n        f.text && (this.title || (this.title = this.chart.renderer.label(f.text, b - 3, b - 4, null, null, null, a.useHTML, null, \"legend-title\").attr({\n          zIndex: 1\n        }), this.chart.styledMode || this.title.css(f.style), this.title.add(this.group)), f.width || this.title.css({\n          width: this.maxLegendWidth + \"px\"\n        }), a = this.title.getBBox(), c = a.height, this.offsetWidth = a.width, this.contentGroup.attr({\n          translateY: c\n        }));\n        this.titleHeight = c;\n      },\n      setText: function (e) {\n        var b = this.options;\n        e.legendItem.attr({\n          text: b.labelFormat ? a.format(b.labelFormat, e, this.chart.time) : b.labelFormatter.call(e)\n        });\n      },\n      renderItem: function (a) {\n        var b = this.chart,\n            e = b.renderer,\n            c = this.options,\n            f = this.symbolWidth,\n            h = c.symbolPadding,\n            r = this.itemStyle,\n            g = this.itemHiddenStyle,\n            p = \"horizontal\" === c.layout ? z(c.itemDistance, 20) : 0,\n            d = !c.rtl,\n            k = a.legendItem,\n            u = !a.series,\n            D = !u && a.series.drawLegendSymbol ? a.series : a,\n            G = D.options,\n            G = this.createCheckboxForItem && G && G.showCheckbox,\n            p = f + h + p + (G ? 20 : 0),\n            q = c.useHTML,\n            n = a.options.className;\n        k || (a.legendGroup = e.g(\"legend-item\").addClass(\"highcharts-\" + D.type + \"-series highcharts-color-\" + a.colorIndex + (n ? \" \" + n : \"\") + (u ? \" highcharts-series-\" + a.index : \"\")).attr({\n          zIndex: 1\n        }).add(this.scrollGroup), a.legendItem = k = e.text(\"\", d ? f + h : -h, this.baseline || 0, q), b.styledMode || k.css(y(a.visible ? r : g)), k.attr({\n          align: d ? \"left\" : \"right\",\n          zIndex: 2\n        }).add(a.legendGroup), this.baseline || (this.fontMetrics = e.fontMetrics(b.styledMode ? 12 : r.fontSize, k), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, k.attr(\"y\", this.baseline)), this.symbolHeight = c.symbolHeight || this.fontMetrics.f, D.drawLegendSymbol(this, a), this.setItemEvents && this.setItemEvents(a, k, q));\n        G && !a.checkbox && this.createCheckboxForItem(a);\n        this.colorizeItem(a, a.visible);\n        !b.styledMode && r.width || k.css({\n          width: (c.itemWidth || this.widthOption || b.spacingBox.width) - p\n        });\n        this.setText(a);\n        b = k.getBBox();\n        a.itemWidth = a.checkboxOffset = c.itemWidth || a.legendItemWidth || b.width + p;\n        this.maxItemWidth = Math.max(this.maxItemWidth, a.itemWidth);\n        this.totalItemWidth += a.itemWidth;\n        this.itemHeight = a.itemHeight = Math.round(a.legendItemHeight || b.height || this.symbolHeight);\n      },\n      layoutItem: function (a) {\n        var b = this.options,\n            e = this.padding,\n            c = \"horizontal\" === b.layout,\n            f = a.itemHeight,\n            h = b.itemMarginBottom || 0,\n            r = this.itemMarginTop,\n            g = c ? z(b.itemDistance, 20) : 0,\n            p = this.maxLegendWidth,\n            b = b.alignColumns && this.totalItemWidth > p ? this.maxItemWidth : a.itemWidth;\n        c && this.itemX - e + b > p && (this.itemX = e, this.lastLineHeight && (this.itemY += r + this.lastLineHeight + h), this.lastLineHeight = 0);\n        this.lastItemY = r + this.itemY + h;\n        this.lastLineHeight = Math.max(f, this.lastLineHeight);\n        a._legendItemPos = [this.itemX, this.itemY];\n        c ? this.itemX += b : (this.itemY += r + f + h, this.lastLineHeight = f);\n        this.offsetWidth = this.widthOption || Math.max((c ? this.itemX - e - (a.checkbox ? 0 : g) : b) + e, this.offsetWidth);\n      },\n      getAllItems: function () {\n        var a = [];\n        this.chart.series.forEach(function (b) {\n          var e = b && b.options;\n          b && z(e.showInLegend, m(e.linkedTo) ? !1 : void 0, !0) && (a = a.concat(b.legendItems || (\"point\" === e.legendType ? b.data : b)));\n        });\n        g(this, \"afterGetAllItems\", {\n          allItems: a\n        });\n        return a;\n      },\n      getAlignment: function () {\n        var a = this.options;\n        return this.proximate ? a.align.charAt(0) + \"tv\" : a.floating ? \"\" : a.align.charAt(0) + a.verticalAlign.charAt(0) + a.layout.charAt(0);\n      },\n      adjustMargins: function (a, b) {\n        var e = this.chart,\n            c = this.options,\n            f = this.getAlignment(),\n            h = void 0 !== e.options.title.margin ? e.titleOffset + e.options.title.margin : 0;\n        f && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (l, t) {\n          l.test(f) && !m(a[t]) && (e[x[t]] = Math.max(e[x[t]], e.legend[(t + 1) % 2 ? \"legendHeight\" : \"legendWidth\"] + [1, -1, -1, 1][t] * c[t % 2 ? \"x\" : \"y\"] + z(c.margin, 12) + b[t] + (0 === t && (0 === e.titleOffset ? 0 : h))));\n        });\n      },\n      proximatePositions: function () {\n        var e = this.chart,\n            b = [],\n            f = \"left\" === this.options.align;\n        this.allItems.forEach(function (c) {\n          var h, l;\n          l = f;\n          var r;\n          c.yAxis && c.points && (c.xAxis.options.reversed && (l = !l), h = a.find(l ? c.points : c.points.slice(0).reverse(), function (b) {\n            return a.isNumber(b.plotY);\n          }), l = c.legendGroup.getBBox().height, r = c.yAxis.top - e.plotTop, c.visible ? (h = h ? h.plotY : c.yAxis.height, h += r - .3 * l) : h = r + c.yAxis.height, b.push({\n            target: h,\n            size: l,\n            item: c\n          }));\n        }, this);\n        a.distribute(b, e.plotHeight);\n        b.forEach(function (a) {\n          a.item._legendItemPos[1] = e.plotTop - e.spacing[0] + a.pos;\n        });\n      },\n      render: function () {\n        var e = this.chart,\n            b = e.renderer,\n            h = this.group,\n            c,\n            t,\n            r,\n            w = this.box,\n            n = this.options,\n            p = this.padding;\n        this.itemX = p;\n        this.itemY = this.initialItemY;\n        this.lastItemY = this.offsetWidth = 0;\n        this.widthOption = a.relativeLength(n.width, e.spacingBox.width - p);\n        c = e.spacingBox.width - 2 * p - n.x;\n        -1 < [\"rm\", \"lm\"].indexOf(this.getAlignment().substring(0, 2)) && (c /= 2);\n        this.maxLegendWidth = this.widthOption || c;\n        h || (this.group = h = b.g(\"legend\").attr({\n          zIndex: 7\n        }).add(), this.contentGroup = b.g().attr({\n          zIndex: 1\n        }).add(h), this.scrollGroup = b.g().add(this.contentGroup));\n        this.renderTitle();\n        c = this.getAllItems();\n        f(c, function (a, b) {\n          return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0);\n        });\n        n.reversed && c.reverse();\n        this.allItems = c;\n        this.display = t = !!c.length;\n        this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;\n        c.forEach(this.renderItem, this);\n        c.forEach(this.layoutItem, this);\n        c = (this.widthOption || this.offsetWidth) + p;\n        r = this.lastItemY + this.lastLineHeight + this.titleHeight;\n        r = this.handleOverflow(r);\n        r += p;\n        w || (this.box = w = b.rect().addClass(\"highcharts-legend-box\").attr({\n          r: n.borderRadius\n        }).add(h), w.isNew = !0);\n        e.styledMode || w.attr({\n          stroke: n.borderColor,\n          \"stroke-width\": n.borderWidth || 0,\n          fill: n.backgroundColor || \"none\"\n        }).shadow(n.shadow);\n        0 < c && 0 < r && (w[w.isNew ? \"attr\" : \"animate\"](w.crisp.call({}, {\n          x: 0,\n          y: 0,\n          width: c,\n          height: r\n        }, w.strokeWidth())), w.isNew = !1);\n        w[t ? \"show\" : \"hide\"]();\n        e.styledMode && \"none\" === h.getStyle(\"display\") && (c = r = 0);\n        this.legendWidth = c;\n        this.legendHeight = r;\n        t && (b = e.spacingBox, /(lth|ct|rth)/.test(this.getAlignment()) && (w = b.y + e.titleOffset, b = y(b, {\n          y: 0 < e.titleOffset ? w += e.options.title.margin : w\n        })), h.align(y(n, {\n          width: c,\n          height: r,\n          verticalAlign: this.proximate ? \"top\" : n.verticalAlign\n        }), !0, b));\n        this.proximate || this.positionItems();\n        g(this, \"afterRender\");\n      },\n      handleOverflow: function (a) {\n        var b = this,\n            e = this.chart,\n            c = e.renderer,\n            h = this.options,\n            f = h.y,\n            r = this.padding,\n            f = e.spacingBox.height + (\"top\" === h.verticalAlign ? -f : f) - r,\n            g = h.maxHeight,\n            p,\n            d = this.clipRect,\n            k = h.navigation,\n            u = z(k.animation, !0),\n            D = k.arrowSize || 12,\n            G = this.nav,\n            q = this.pages,\n            n,\n            m = this.allItems,\n            v = function (a) {\n          \"number\" === typeof a ? d.attr({\n            height: a\n          }) : d && (b.clipRect = d.destroy(), b.contentGroup.clip());\n          b.contentGroup.div && (b.contentGroup.div.style.clip = a ? \"rect(\" + r + \"px,9999px,\" + (r + a) + \"px,0)\" : \"auto\");\n        },\n            L = function (a) {\n          b[a] = c.circle(0, 0, 1.3 * D).translate(D / 2, D / 2).add(G);\n          e.styledMode || b[a].attr(\"fill\", \"rgba(0,0,0,0.0001)\");\n          return b[a];\n        };\n\n        \"horizontal\" !== h.layout || \"middle\" === h.verticalAlign || h.floating || (f /= 2);\n        g && (f = Math.min(f, g));\n        q.length = 0;\n        a > f && !1 !== k.enabled ? (this.clipHeight = p = Math.max(f - 20 - this.titleHeight - r, 0), this.currentPage = z(this.currentPage, 1), this.fullHeight = a, m.forEach(function (a, d) {\n          var b = a._legendItemPos[1],\n              c = Math.round(a.legendItem.getBBox().height),\n              k = q.length;\n          if (!k || b - q[k - 1] > p && (n || b) !== q[k - 1]) q.push(n || b), k++;\n          a.pageIx = k - 1;\n          n && (m[d - 1].pageIx = k - 1);\n          d === m.length - 1 && b + c - q[k - 1] > p && b !== n && (q.push(b), a.pageIx = k);\n          b !== n && (n = b);\n        }), d || (d = b.clipRect = c.clipRect(0, r, 9999, 0), b.contentGroup.clip(d)), v(p), G || (this.nav = G = c.g().attr({\n          zIndex: 1\n        }).add(this.group), this.up = c.symbol(\"triangle\", 0, 0, D, D).add(G), L(\"upTracker\").on(\"click\", function () {\n          b.scroll(-1, u);\n        }), this.pager = c.text(\"\", 15, 10).addClass(\"highcharts-legend-navigation\"), e.styledMode || this.pager.css(k.style), this.pager.add(G), this.down = c.symbol(\"triangle-down\", 0, 0, D, D).add(G), L(\"downTracker\").on(\"click\", function () {\n          b.scroll(1, u);\n        })), b.scroll(0), a = f) : G && (v(), this.nav = G.destroy(), this.scrollGroup.attr({\n          translateY: 1\n        }), this.clipHeight = 0);\n        return a;\n      },\n      scroll: function (a, b) {\n        var e = this.pages,\n            c = e.length,\n            h = this.currentPage + a;\n        a = this.clipHeight;\n        var f = this.options.navigation,\n            r = this.pager,\n            g = this.padding;\n        h > c && (h = c);\n        0 < h && (void 0 !== b && n(b, this.chart), this.nav.attr({\n          translateX: g,\n          translateY: a + this.padding + 7 + this.titleHeight,\n          visibility: \"visible\"\n        }), [this.up, this.upTracker].forEach(function (a) {\n          a.attr({\n            \"class\": 1 === h ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n          });\n        }), r.attr({\n          text: h + \"/\" + c\n        }), [this.down, this.downTracker].forEach(function (a) {\n          a.attr({\n            x: 18 + this.pager.getBBox().width,\n            \"class\": h === c ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n          });\n        }, this), this.chart.styledMode || (this.up.attr({\n          fill: 1 === h ? f.inactiveColor : f.activeColor\n        }), this.upTracker.css({\n          cursor: 1 === h ? \"default\" : \"pointer\"\n        }), this.down.attr({\n          fill: h === c ? f.inactiveColor : f.activeColor\n        }), this.downTracker.css({\n          cursor: h === c ? \"default\" : \"pointer\"\n        })), this.scrollOffset = -e[h - 1] + this.initialItemY, this.scrollGroup.animate({\n          translateY: this.scrollOffset\n        }), this.currentPage = h, this.positionCheckboxes());\n      }\n    };\n    a.LegendSymbolMixin = {\n      drawRectangle: function (a, b) {\n        var e = a.symbolHeight,\n            c = a.options.squareSymbol;\n        b.legendSymbol = this.chart.renderer.rect(c ? (a.symbolWidth - e) / 2 : 0, a.baseline - e + 1, c ? e : a.symbolWidth, e, z(a.options.symbolRadius, e / 2)).addClass(\"highcharts-point\").attr({\n          zIndex: 3\n        }).add(b.legendGroup);\n      },\n      drawLineMarker: function (a) {\n        var b = this.options,\n            e = b.marker,\n            c = a.symbolWidth,\n            h = a.symbolHeight,\n            f = h / 2,\n            r = this.chart.renderer,\n            g = this.legendGroup;\n        a = a.baseline - Math.round(.3 * a.fontMetrics.b);\n        var p = {};\n        this.chart.styledMode || (p = {\n          \"stroke-width\": b.lineWidth || 0\n        }, b.dashStyle && (p.dashstyle = b.dashStyle));\n        this.legendLine = r.path([\"M\", 0, a, \"L\", c, a]).addClass(\"highcharts-graph\").attr(p).add(g);\n        e && !1 !== e.enabled && c && (b = Math.min(z(e.radius, f), f), 0 === this.symbol.indexOf(\"url\") && (e = y(e, {\n          width: h,\n          height: h\n        }), b = 0), this.legendSymbol = e = r.symbol(this.symbol, c / 2 - b, a - b, 2 * b, 2 * b, e).addClass(\"highcharts-point\").add(g), e.isMarker = !0);\n      }\n    };\n    (/Trident\\/7\\.0/.test(h.navigator && h.navigator.userAgent) || v) && r(a.Legend.prototype, \"positionItem\", function (a, b) {\n      var e = this,\n          c = function () {\n        b._legendItemPos && a.call(e, b);\n      };\n\n      c();\n      e.bubbleLegend || setTimeout(c);\n    });\n  });\n  I(H, \"parts/Chart.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.addEvent,\n        A = a.animate,\n        E = a.animObject,\n        m = a.attr,\n        g = a.doc,\n        v = a.Axis,\n        x = a.createElement,\n        y = a.defaultOptions,\n        z = a.discardElement,\n        n = a.charts,\n        f = a.css,\n        h = a.defined,\n        r = a.extend,\n        e = a.find,\n        b = a.fireEvent,\n        l = a.isNumber,\n        c = a.isObject,\n        t = a.isString,\n        F = a.Legend,\n        w = a.marginNames,\n        B = a.merge,\n        p = a.objectEach,\n        d = a.Pointer,\n        k = a.pick,\n        u = a.pInt,\n        D = a.removeEvent,\n        G = a.seriesTypes,\n        q = a.splat,\n        K = a.syncTimeout,\n        N = a.win,\n        O = a.Chart = function () {\n      this.getArgs.apply(this, arguments);\n    };\n\n    a.chart = function (a, d, b) {\n      return new O(a, d, b);\n    };\n\n    r(O.prototype, {\n      callbacks: [],\n      getArgs: function () {\n        var a = [].slice.call(arguments);\n        if (t(a[0]) || a[0].nodeName) this.renderTo = a.shift();\n        this.init(a[0], a[1]);\n      },\n      init: function (d, k) {\n        var e,\n            u = d.series,\n            q = d.plotOptions || {};\n        b(this, \"init\", {\n          args: arguments\n        }, function () {\n          d.series = null;\n          e = B(y, d);\n          p(e.plotOptions, function (a, d) {\n            c(a) && (a.tooltip = q[d] && B(q[d].tooltip) || void 0);\n          });\n          e.tooltip.userOptions = d.chart && d.chart.forExport && d.tooltip.userOptions || d.tooltip;\n          e.series = d.series = u;\n          this.userOptions = d;\n          var h = e.chart,\n              f = h.events;\n          this.margin = [];\n          this.spacing = [];\n          this.bounds = {\n            h: {},\n            v: {}\n          };\n          this.labelCollectors = [];\n          this.callback = k;\n          this.isResizing = 0;\n          this.options = e;\n          this.axes = [];\n          this.series = [];\n          this.time = d.time && Object.keys(d.time).length ? new a.Time(d.time) : a.time;\n          this.styledMode = h.styledMode;\n          this.hasCartesianSeries = h.showAxes;\n          var l = this;\n          l.index = n.length;\n          n.push(l);\n          a.chartCount++;\n          f && p(f, function (d, b) {\n            a.isFunction(d) && C(l, b, d);\n          });\n          l.xAxis = [];\n          l.yAxis = [];\n          l.pointCount = l.colorCounter = l.symbolCounter = 0;\n          b(l, \"afterInit\");\n          l.firstRender();\n        });\n      },\n      initSeries: function (d) {\n        var b = this.options.chart;\n        (b = G[d.type || b.type || b.defaultSeriesType]) || a.error(17, !0, this);\n        b = new b();\n        b.init(this, d);\n        return b;\n      },\n      orderSeries: function (a) {\n        var d = this.series;\n\n        for (a = a || 0; a < d.length; a++) d[a] && (d[a].index = a, d[a].name = d[a].getName());\n      },\n      isInsidePlot: function (a, d, b) {\n        var c = b ? d : a;\n        a = b ? a : d;\n        return 0 <= c && c <= this.plotWidth && 0 <= a && a <= this.plotHeight;\n      },\n      redraw: function (d) {\n        b(this, \"beforeRedraw\");\n        var c = this.axes,\n            k = this.series,\n            e = this.pointer,\n            u = this.legend,\n            q = this.userOptions.legend,\n            h = this.isDirtyLegend,\n            f,\n            p,\n            l = this.hasCartesianSeries,\n            t = this.isDirtyBox,\n            g,\n            D = this.renderer,\n            G = D.isHidden(),\n            w = [];\n        this.setResponsive && this.setResponsive(!1);\n        a.setAnimation(d, this);\n        G && this.temporaryDisplay();\n        this.layOutTitles();\n\n        for (d = k.length; d--;) if (g = k[d], g.options.stacking && (f = !0, g.isDirty)) {\n          p = !0;\n          break;\n        }\n\n        if (p) for (d = k.length; d--;) g = k[d], g.options.stacking && (g.isDirty = !0);\n        k.forEach(function (a) {\n          a.isDirty && (\"point\" === a.options.legendType ? (a.updateTotals && a.updateTotals(), h = !0) : q && (q.labelFormatter || q.labelFormat) && (h = !0));\n          a.isDirtyData && b(a, \"updatedData\");\n        });\n        h && u && u.options.enabled && (u.render(), this.isDirtyLegend = !1);\n        f && this.getStacks();\n        l && c.forEach(function (a) {\n          a.updateNames();\n          a.setScale();\n        });\n        this.getMargins();\n        l && (c.forEach(function (a) {\n          a.isDirty && (t = !0);\n        }), c.forEach(function (a) {\n          var d = a.min + \",\" + a.max;\n          a.extKey !== d && (a.extKey = d, w.push(function () {\n            b(a, \"afterSetExtremes\", r(a.eventArgs, a.getExtremes()));\n            delete a.eventArgs;\n          }));\n          (t || f) && a.redraw();\n        }));\n        t && this.drawChartBox();\n        b(this, \"predraw\");\n        k.forEach(function (a) {\n          (t || a.isDirty) && a.visible && a.redraw();\n          a.isDirtyData = !1;\n        });\n        e && e.reset(!0);\n        D.draw();\n        b(this, \"redraw\");\n        b(this, \"render\");\n        G && this.temporaryDisplay(!0);\n        w.forEach(function (a) {\n          a.call();\n        });\n      },\n      get: function (a) {\n        function d(d) {\n          return d.id === a || d.options && d.options.id === a;\n        }\n\n        var b,\n            c = this.series,\n            k;\n        b = e(this.axes, d) || e(this.series, d);\n\n        for (k = 0; !b && k < c.length; k++) b = e(c[k].points || [], d);\n\n        return b;\n      },\n      getAxes: function () {\n        var a = this,\n            d = this.options,\n            c = d.xAxis = q(d.xAxis || {}),\n            d = d.yAxis = q(d.yAxis || {});\n        b(this, \"getAxes\");\n        c.forEach(function (a, d) {\n          a.index = d;\n          a.isX = !0;\n        });\n        d.forEach(function (a, d) {\n          a.index = d;\n        });\n        c.concat(d).forEach(function (d) {\n          new v(a, d);\n        });\n        b(this, \"afterGetAxes\");\n      },\n      getSelectedPoints: function () {\n        var a = [];\n        this.series.forEach(function (d) {\n          a = a.concat((d[d.hasGroupedData ? \"points\" : \"data\"] || []).filter(function (a) {\n            return a.selected;\n          }));\n        });\n        return a;\n      },\n      getSelectedSeries: function () {\n        return this.series.filter(function (a) {\n          return a.selected;\n        });\n      },\n      setTitle: function (a, d, b) {\n        var c = this,\n            k = c.options,\n            e = c.styledMode,\n            u;\n        u = k.title = B(!e && {\n          style: {\n            color: \"#333333\",\n            fontSize: k.isStock ? \"16px\" : \"18px\"\n          }\n        }, k.title, a);\n        k = k.subtitle = B(!e && {\n          style: {\n            color: \"#666666\"\n          }\n        }, k.subtitle, d);\n        [[\"title\", a, u], [\"subtitle\", d, k]].forEach(function (a, d) {\n          var b = a[0],\n              k = c[b],\n              u = a[1];\n          a = a[2];\n          k && u && (c[b] = k = k.destroy());\n          a && !k && (c[b] = c.renderer.text(a.text, 0, 0, a.useHTML).attr({\n            align: a.align,\n            \"class\": \"highcharts-\" + b,\n            zIndex: a.zIndex || 4\n          }).add(), c[b].update = function (a) {\n            c.setTitle(!d && a, d && a);\n          }, e || c[b].css(a.style));\n        });\n        c.layOutTitles(b);\n      },\n      layOutTitles: function (a) {\n        var d = 0,\n            b,\n            c = this.renderer,\n            e = this.spacingBox;\n        [\"title\", \"subtitle\"].forEach(function (a) {\n          var b = this[a],\n              k = this.options[a];\n          a = \"title\" === a ? -3 : k.verticalAlign ? 0 : d + 2;\n          var u;\n          b && (this.styledMode || (u = k.style.fontSize), u = c.fontMetrics(u, b).b, b.css({\n            width: (k.width || e.width + k.widthAdjust) + \"px\"\n          }).align(r({\n            y: a + u\n          }, k), !1, \"spacingBox\"), k.floating || k.verticalAlign || (d = Math.ceil(d + b.getBBox(k.useHTML).height)));\n        }, this);\n        b = this.titleOffset !== d;\n        this.titleOffset = d;\n        !this.isDirtyBox && b && (this.isDirtyBox = this.isDirtyLegend = b, this.hasRendered && k(a, !0) && this.isDirtyBox && this.redraw());\n      },\n      getChartSize: function () {\n        var d = this.options.chart,\n            b = d.width,\n            d = d.height,\n            c = this.renderTo;\n        h(b) || (this.containerWidth = a.getStyle(c, \"width\"));\n        h(d) || (this.containerHeight = a.getStyle(c, \"height\"));\n        this.chartWidth = Math.max(0, b || this.containerWidth || 600);\n        this.chartHeight = Math.max(0, a.relativeLength(d, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));\n      },\n      temporaryDisplay: function (d) {\n        var b = this.renderTo;\n        if (d) for (; b && b.style;) b.hcOrigStyle && (a.css(b, b.hcOrigStyle), delete b.hcOrigStyle), b.hcOrigDetached && (g.body.removeChild(b), b.hcOrigDetached = !1), b = b.parentNode;else for (; b && b.style;) {\n          g.body.contains(b) || b.parentNode || (b.hcOrigDetached = !0, g.body.appendChild(b));\n          if (\"none\" === a.getStyle(b, \"display\", !1) || b.hcOricDetached) b.hcOrigStyle = {\n            display: b.style.display,\n            height: b.style.height,\n            overflow: b.style.overflow\n          }, d = {\n            display: \"block\",\n            overflow: \"hidden\"\n          }, b !== this.renderTo && (d.height = 0), a.css(b, d), b.offsetWidth || b.style.setProperty(\"display\", \"block\", \"important\");\n          b = b.parentNode;\n          if (b === g.body) break;\n        }\n      },\n      setClassName: function (a) {\n        this.container.className = \"highcharts-container \" + (a || \"\");\n      },\n      getContainer: function () {\n        var d,\n            c = this.options,\n            k = c.chart,\n            e,\n            q;\n        d = this.renderTo;\n        var h = a.uniqueKey(),\n            p,\n            D;\n        d || (this.renderTo = d = k.renderTo);\n        t(d) && (this.renderTo = d = g.getElementById(d));\n        d || a.error(13, !0, this);\n        e = u(m(d, \"data-highcharts-chart\"));\n        l(e) && n[e] && n[e].hasRendered && n[e].destroy();\n        m(d, \"data-highcharts-chart\", this.index);\n        d.innerHTML = \"\";\n        k.skipClone || d.offsetWidth || this.temporaryDisplay();\n        this.getChartSize();\n        e = this.chartWidth;\n        q = this.chartHeight;\n        f(d, {\n          overflow: \"hidden\"\n        });\n        this.styledMode || (p = r({\n          position: \"relative\",\n          overflow: \"hidden\",\n          width: e + \"px\",\n          height: q + \"px\",\n          textAlign: \"left\",\n          lineHeight: \"normal\",\n          zIndex: 0,\n          \"-webkit-tap-highlight-color\": \"rgba(0,0,0,0)\"\n        }, k.style));\n        this.container = d = x(\"div\", {\n          id: h\n        }, p, d);\n        this._cursor = d.style.cursor;\n        this.renderer = new (a[k.renderer] || a.Renderer)(d, e, q, null, k.forExport, c.exporting && c.exporting.allowHTML, this.styledMode);\n        this.setClassName(k.className);\n        if (this.styledMode) for (D in c.defs) this.renderer.definition(c.defs[D]);else this.renderer.setStyle(k.style);\n        this.renderer.chartIndex = this.index;\n        b(this, \"afterGetContainer\");\n      },\n      getMargins: function (a) {\n        var d = this.spacing,\n            c = this.margin,\n            k = this.titleOffset;\n        this.resetMargins();\n        k && !h(c[0]) && (this.plotTop = Math.max(this.plotTop, k + this.options.title.margin + d[0]));\n        this.legend && this.legend.display && this.legend.adjustMargins(c, d);\n        b(this, \"getMargins\");\n        a || this.getAxisMargins();\n      },\n      getAxisMargins: function () {\n        var a = this,\n            d = a.axisOffset = [0, 0, 0, 0],\n            b = a.margin;\n        a.hasCartesianSeries && a.axes.forEach(function (a) {\n          a.visible && a.getOffset();\n        });\n        w.forEach(function (c, k) {\n          h(b[k]) || (a[c] += d[k]);\n        });\n        a.setChartSize();\n      },\n      reflow: function (d) {\n        var b = this,\n            c = b.options.chart,\n            k = b.renderTo,\n            e = h(c.width) && h(c.height),\n            u = c.width || a.getStyle(k, \"width\"),\n            c = c.height || a.getStyle(k, \"height\"),\n            k = d ? d.target : N;\n\n        if (!e && !b.isPrinting && u && c && (k === N || k === g)) {\n          if (u !== b.containerWidth || c !== b.containerHeight) a.clearTimeout(b.reflowTimeout), b.reflowTimeout = K(function () {\n            b.container && b.setSize(void 0, void 0, !1);\n          }, d ? 100 : 0);\n          b.containerWidth = u;\n          b.containerHeight = c;\n        }\n      },\n      setReflow: function (a) {\n        var d = this;\n        !1 === a || this.unbindReflow ? !1 === a && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = C(N, \"resize\", function (a) {\n          d.reflow(a);\n        }), C(this, \"destroy\", this.unbindReflow));\n      },\n      setSize: function (d, c, k) {\n        var e = this,\n            u = e.renderer,\n            q;\n        e.isResizing += 1;\n        a.setAnimation(k, e);\n        e.oldChartHeight = e.chartHeight;\n        e.oldChartWidth = e.chartWidth;\n        void 0 !== d && (e.options.chart.width = d);\n        void 0 !== c && (e.options.chart.height = c);\n        e.getChartSize();\n        e.styledMode || (q = u.globalAnimation, (q ? A : f)(e.container, {\n          width: e.chartWidth + \"px\",\n          height: e.chartHeight + \"px\"\n        }, q));\n        e.setChartSize(!0);\n        u.setSize(e.chartWidth, e.chartHeight, k);\n        e.axes.forEach(function (a) {\n          a.isDirty = !0;\n          a.setScale();\n        });\n        e.isDirtyLegend = !0;\n        e.isDirtyBox = !0;\n        e.layOutTitles();\n        e.getMargins();\n        e.redraw(k);\n        e.oldChartHeight = null;\n        b(e, \"resize\");\n        K(function () {\n          e && b(e, \"endResize\", null, function () {\n            --e.isResizing;\n          });\n        }, E(q).duration);\n      },\n      setChartSize: function (a) {\n        var d = this.inverted,\n            c = this.renderer,\n            k = this.chartWidth,\n            e = this.chartHeight,\n            u = this.options.chart,\n            q = this.spacing,\n            h = this.clipOffset,\n            f,\n            p,\n            l,\n            t;\n        this.plotLeft = f = Math.round(this.plotLeft);\n        this.plotTop = p = Math.round(this.plotTop);\n        this.plotWidth = l = Math.max(0, Math.round(k - f - this.marginRight));\n        this.plotHeight = t = Math.max(0, Math.round(e - p - this.marginBottom));\n        this.plotSizeX = d ? t : l;\n        this.plotSizeY = d ? l : t;\n        this.plotBorderWidth = u.plotBorderWidth || 0;\n        this.spacingBox = c.spacingBox = {\n          x: q[3],\n          y: q[0],\n          width: k - q[3] - q[1],\n          height: e - q[0] - q[2]\n        };\n        this.plotBox = c.plotBox = {\n          x: f,\n          y: p,\n          width: l,\n          height: t\n        };\n        k = 2 * Math.floor(this.plotBorderWidth / 2);\n        d = Math.ceil(Math.max(k, h[3]) / 2);\n        c = Math.ceil(Math.max(k, h[0]) / 2);\n        this.clipBox = {\n          x: d,\n          y: c,\n          width: Math.floor(this.plotSizeX - Math.max(k, h[1]) / 2 - d),\n          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(k, h[2]) / 2 - c))\n        };\n        a || this.axes.forEach(function (a) {\n          a.setAxisSize();\n          a.setAxisTranslation();\n        });\n        b(this, \"afterSetChartSize\", {\n          skipAxes: a\n        });\n      },\n      resetMargins: function () {\n        b(this, \"resetMargins\");\n        var a = this,\n            d = a.options.chart;\n        [\"margin\", \"spacing\"].forEach(function (b) {\n          var e = d[b],\n              u = c(e) ? e : [e, e, e, e];\n          [\"Top\", \"Right\", \"Bottom\", \"Left\"].forEach(function (c, e) {\n            a[b][e] = k(d[b + c], u[e]);\n          });\n        });\n        w.forEach(function (d, b) {\n          a[d] = k(a.margin[b], a.spacing[b]);\n        });\n        a.axisOffset = [0, 0, 0, 0];\n        a.clipOffset = [0, 0, 0, 0];\n      },\n      drawChartBox: function () {\n        var a = this.options.chart,\n            d = this.renderer,\n            c = this.chartWidth,\n            k = this.chartHeight,\n            e = this.chartBackground,\n            u = this.plotBackground,\n            q = this.plotBorder,\n            h,\n            f = this.styledMode,\n            p = this.plotBGImage,\n            l = a.backgroundColor,\n            t = a.plotBackgroundColor,\n            r = a.plotBackgroundImage,\n            g,\n            D = this.plotLeft,\n            G = this.plotTop,\n            w = this.plotWidth,\n            n = this.plotHeight,\n            m = this.plotBox,\n            K = this.clipRect,\n            B = this.clipBox,\n            F = \"animate\";\n        e || (this.chartBackground = e = d.rect().addClass(\"highcharts-background\").add(), F = \"attr\");\n        if (f) h = g = e.strokeWidth();else {\n          h = a.borderWidth || 0;\n          g = h + (a.shadow ? 8 : 0);\n          l = {\n            fill: l || \"none\"\n          };\n          if (h || e[\"stroke-width\"]) l.stroke = a.borderColor, l[\"stroke-width\"] = h;\n          e.attr(l).shadow(a.shadow);\n        }\n        e[F]({\n          x: g / 2,\n          y: g / 2,\n          width: c - g - h % 2,\n          height: k - g - h % 2,\n          r: a.borderRadius\n        });\n        F = \"animate\";\n        u || (F = \"attr\", this.plotBackground = u = d.rect().addClass(\"highcharts-plot-background\").add());\n        u[F](m);\n        f || (u.attr({\n          fill: t || \"none\"\n        }).shadow(a.plotShadow), r && (p ? p.animate(m) : this.plotBGImage = d.image(r, D, G, w, n).add()));\n        K ? K.animate({\n          width: B.width,\n          height: B.height\n        }) : this.clipRect = d.clipRect(B);\n        F = \"animate\";\n        q || (F = \"attr\", this.plotBorder = q = d.rect().addClass(\"highcharts-plot-border\").attr({\n          zIndex: 1\n        }).add());\n        f || q.attr({\n          stroke: a.plotBorderColor,\n          \"stroke-width\": a.plotBorderWidth || 0,\n          fill: \"none\"\n        });\n        q[F](q.crisp({\n          x: D,\n          y: G,\n          width: w,\n          height: n\n        }, -q.strokeWidth()));\n        this.isDirtyBox = !1;\n        b(this, \"afterDrawChartBox\");\n      },\n      propFromSeries: function () {\n        var a = this,\n            d = a.options.chart,\n            b,\n            c = a.options.series,\n            k,\n            e;\n        [\"inverted\", \"angular\", \"polar\"].forEach(function (u) {\n          b = G[d.type || d.defaultSeriesType];\n          e = d[u] || b && b.prototype[u];\n\n          for (k = c && c.length; !e && k--;) (b = G[c[k].type]) && b.prototype[u] && (e = !0);\n\n          a[u] = e;\n        });\n      },\n      linkSeries: function () {\n        var a = this,\n            d = a.series;\n        d.forEach(function (a) {\n          a.linkedSeries.length = 0;\n        });\n        d.forEach(function (d) {\n          var b = d.options.linkedTo;\n          t(b) && (b = \":previous\" === b ? a.series[d.index - 1] : a.get(b)) && b.linkedParent !== d && (b.linkedSeries.push(d), d.linkedParent = b, d.visible = k(d.options.visible, b.options.visible, d.visible));\n        });\n        b(this, \"afterLinkSeries\");\n      },\n      renderSeries: function () {\n        this.series.forEach(function (a) {\n          a.translate();\n          a.render();\n        });\n      },\n      renderLabels: function () {\n        var a = this,\n            d = a.options.labels;\n        d.items && d.items.forEach(function (b) {\n          var c = r(d.style, b.style),\n              k = u(c.left) + a.plotLeft,\n              e = u(c.top) + a.plotTop + 12;\n          delete c.left;\n          delete c.top;\n          a.renderer.text(b.html, k, e).attr({\n            zIndex: 2\n          }).css(c).add();\n        });\n      },\n      render: function () {\n        var a = this.axes,\n            d = this.renderer,\n            b = this.options,\n            c = 0,\n            k,\n            e,\n            u;\n        this.setTitle();\n        this.legend = new F(this, b.legend);\n        this.getStacks && this.getStacks();\n        this.getMargins(!0);\n        this.setChartSize();\n        b = this.plotWidth;\n        a.some(function (a) {\n          if (a.horiz && a.visible && a.options.labels.enabled && a.series.length) return c = 21, !0;\n        });\n        k = this.plotHeight = Math.max(this.plotHeight - c, 0);\n        a.forEach(function (a) {\n          a.setScale();\n        });\n        this.getAxisMargins();\n        e = 1.1 < b / this.plotWidth;\n        u = 1.05 < k / this.plotHeight;\n        if (e || u) a.forEach(function (a) {\n          (a.horiz && e || !a.horiz && u) && a.setTickInterval(!0);\n        }), this.getMargins();\n        this.drawChartBox();\n        this.hasCartesianSeries && a.forEach(function (a) {\n          a.visible && a.render();\n        });\n        this.seriesGroup || (this.seriesGroup = d.g(\"series-group\").attr({\n          zIndex: 3\n        }).add());\n        this.renderSeries();\n        this.renderLabels();\n        this.addCredits();\n        this.setResponsive && this.setResponsive();\n        this.hasRendered = !0;\n      },\n      addCredits: function (a) {\n        var d = this;\n        a = B(!0, this.options.credits, a);\n        a.enabled && !this.credits && (this.credits = this.renderer.text(a.text + (this.mapCredits || \"\"), 0, 0).addClass(\"highcharts-credits\").on(\"click\", function () {\n          a.href && (N.location.href = a.href);\n        }).attr({\n          align: a.position.align,\n          zIndex: 8\n        }), d.styledMode || this.credits.css(a.style), this.credits.add().align(a.position), this.credits.update = function (a) {\n          d.credits = d.credits.destroy();\n          d.addCredits(a);\n        });\n      },\n      destroy: function () {\n        var d = this,\n            c = d.axes,\n            k = d.series,\n            e = d.container,\n            u,\n            q = e && e.parentNode;\n        b(d, \"destroy\");\n        d.renderer.forExport ? a.erase(n, d) : n[d.index] = void 0;\n        a.chartCount--;\n        d.renderTo.removeAttribute(\"data-highcharts-chart\");\n        D(d);\n\n        for (u = c.length; u--;) c[u] = c[u].destroy();\n\n        this.scroller && this.scroller.destroy && this.scroller.destroy();\n\n        for (u = k.length; u--;) k[u] = k[u].destroy();\n\n        \"title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer\".split(\" \").forEach(function (a) {\n          var b = d[a];\n          b && b.destroy && (d[a] = b.destroy());\n        });\n        e && (e.innerHTML = \"\", D(e), q && z(e));\n        p(d, function (a, b) {\n          delete d[b];\n        });\n      },\n      firstRender: function () {\n        var c = this,\n            k = c.options;\n\n        if (!c.isReadyToRender || c.isReadyToRender()) {\n          c.getContainer();\n          c.resetMargins();\n          c.setChartSize();\n          c.propFromSeries();\n          c.getAxes();\n          (a.isArray(k.series) ? k.series : []).forEach(function (a) {\n            c.initSeries(a);\n          });\n          c.linkSeries();\n          b(c, \"beforeRender\");\n          d && (c.pointer = new d(c, k));\n          c.render();\n          if (!c.renderer.imgCount && c.onload) c.onload();\n          c.temporaryDisplay(!0);\n        }\n      },\n      onload: function () {\n        this.callbacks.concat([this.callback]).forEach(function (a) {\n          a && void 0 !== this.index && a.apply(this, [this]);\n        }, this);\n        b(this, \"load\");\n        b(this, \"render\");\n        h(this.index) && this.setReflow(this.options.chart.reflow);\n        this.onload = null;\n      }\n    });\n  });\n  I(H, \"parts/ScrollablePlotArea.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.addEvent,\n        A = a.Chart;\n    C(A, \"afterSetChartSize\", function (A) {\n      var m = this.options.chart.scrollablePlotArea,\n          g = m && m.minWidth,\n          m = m && m.minHeight,\n          v;\n\n      if (!this.renderer.forExport) {\n        if (g) {\n          if (this.scrollablePixelsX = g = Math.max(0, g - this.chartWidth)) this.plotWidth += g, this.inverted ? this.clipBox.height += g : this.clipBox.width += g, v = {\n            1: {\n              name: \"right\",\n              value: g\n            }\n          };\n        } else m && (this.scrollablePixelsY = g = Math.max(0, m - this.chartHeight)) && (this.plotHeight += g, this.inverted ? this.clipBox.width += g : this.clipBox.height += g, v = {\n          2: {\n            name: \"bottom\",\n            value: g\n          }\n        });\n\n        v && !A.skipAxes && this.axes.forEach(function (g) {\n          v[g.side] ? g.getPlotLinePath = function () {\n            var m = v[g.side].name,\n                x = this[m],\n                n;\n            this[m] = x - v[g.side].value;\n            n = a.Axis.prototype.getPlotLinePath.apply(this, arguments);\n            this[m] = x;\n            return n;\n          } : (g.setAxisSize(), g.setAxisTranslation());\n        });\n      }\n    });\n    C(A, \"render\", function () {\n      this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();\n    });\n\n    A.prototype.setUpScrolling = function () {\n      var A = {\n        WebkitOverflowScrolling: \"touch\",\n        overflowX: \"hidden\",\n        overflowY: \"hidden\"\n      };\n      this.scrollablePixelsX && (A.overflowX = \"auto\");\n      this.scrollablePixelsY && (A.overflowY = \"auto\");\n      this.scrollingContainer = a.createElement(\"div\", {\n        className: \"highcharts-scrolling\"\n      }, A, this.renderTo);\n      this.innerContainer = a.createElement(\"div\", {\n        className: \"highcharts-inner-container\"\n      }, null, this.scrollingContainer);\n      this.innerContainer.appendChild(this.container);\n      this.setUpScrolling = null;\n    };\n\n    A.prototype.moveFixedElements = function () {\n      var a = this.container,\n          m = this.fixedRenderer,\n          g = \".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-reset-zoom .highcharts-subtitle .highcharts-title .highcharts-legend-checkbox\".split(\" \"),\n          v;\n      this.scrollablePixelsX && !this.inverted ? v = \".highcharts-yaxis\" : this.scrollablePixelsX && this.inverted ? v = \".highcharts-xaxis\" : this.scrollablePixelsY && !this.inverted ? v = \".highcharts-xaxis\" : this.scrollablePixelsY && this.inverted && (v = \".highcharts-yaxis\");\n      g.push(v, v + \"-labels\");\n      g.forEach(function (g) {\n        [].forEach.call(a.querySelectorAll(g), function (a) {\n          (a.namespaceURI === m.SVG_NS ? m.box : m.box.parentNode).appendChild(a);\n          a.style.pointerEvents = \"auto\";\n        });\n      });\n    };\n\n    A.prototype.applyFixed = function () {\n      var A,\n          m,\n          g = !this.fixedDiv,\n          v = this.options.chart.scrollablePlotArea;\n      g ? (this.fixedDiv = a.createElement(\"div\", {\n        className: \"highcharts-fixed\"\n      }, {\n        position: \"absolute\",\n        overflow: \"hidden\",\n        pointerEvents: \"none\",\n        zIndex: 2\n      }, null, !0), this.renderTo.insertBefore(this.fixedDiv, this.renderTo.firstChild), this.renderTo.style.overflow = \"visible\", this.fixedRenderer = A = new a.Renderer(this.fixedDiv, this.chartWidth, this.chartHeight), this.scrollableMask = A.path().attr({\n        fill: a.color(this.options.chart.backgroundColor || \"#fff\").setOpacity(a.pick(v.opacity, .85)).get(),\n        zIndex: -1\n      }).addClass(\"highcharts-scrollable-mask\").add(), this.moveFixedElements(), C(this, \"afterShowResetZoom\", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);\n      A = this.chartWidth + (this.scrollablePixelsX || 0);\n      m = this.chartHeight + (this.scrollablePixelsY || 0);\n      a.stop(this.container);\n      this.container.style.width = A + \"px\";\n      this.container.style.height = m + \"px\";\n      this.renderer.boxWrapper.attr({\n        width: A,\n        height: m,\n        viewBox: [0, 0, A, m].join(\" \")\n      });\n      this.chartBackground.attr({\n        width: A,\n        height: m\n      });\n      this.scrollablePixelsY && (this.scrollingContainer.style.height = this.chartHeight + \"px\");\n      g && (v.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * v.scrollPositionX), v.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * v.scrollPositionY));\n      m = this.axisOffset;\n      g = this.plotTop - m[0] - 1;\n      v = this.plotLeft - m[3] - 1;\n      A = this.plotTop + this.plotHeight + m[2] + 1;\n      m = this.plotLeft + this.plotWidth + m[1] + 1;\n      var x = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),\n          y = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0),\n          g = this.scrollablePixelsX ? [\"M\", 0, g, \"L\", this.plotLeft - 1, g, \"L\", this.plotLeft - 1, A, \"L\", 0, A, \"Z\", \"M\", x, g, \"L\", this.chartWidth, g, \"L\", this.chartWidth, A, \"L\", x, A, \"Z\"] : this.scrollablePixelsY ? [\"M\", v, 0, \"L\", v, this.plotTop - 1, \"L\", m, this.plotTop - 1, \"L\", m, 0, \"Z\", \"M\", v, y, \"L\", v, this.chartHeight, \"L\", m, this.chartHeight, \"L\", m, y, \"Z\"] : [\"M\", 0, 0];\n      \"adjustHeight\" !== this.redrawTrigger && this.scrollableMask.attr({\n        d: g\n      });\n    };\n  });\n  I(H, \"parts/Point.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C,\n        A = a.extend,\n        E = a.erase,\n        m = a.fireEvent,\n        g = a.format,\n        v = a.isArray,\n        x = a.isNumber,\n        y = a.pick,\n        z = a.uniqueKey,\n        n = a.defined,\n        f = a.removeEvent;\n\n    a.Point = C = function () {};\n\n    a.Point.prototype = {\n      init: function (a, f, e) {\n        this.series = a;\n        this.applyOptions(f, e);\n        this.id = n(this.id) ? this.id : z();\n        this.resolveColor();\n        a.chart.pointCount++;\n        m(this, \"afterInit\");\n        return this;\n      },\n      resolveColor: function () {\n        var a = this.series,\n            f;\n        f = a.chart.options.chart.colorCount;\n        var e = a.chart.styledMode;\n        e || this.options.color || (this.color = a.color);\n        a.options.colorByPoint ? (e || (f = a.options.colors || a.chart.options.colors, this.color = this.color || f[a.colorCounter], f = f.length), e = a.colorCounter, a.colorCounter++, a.colorCounter === f && (a.colorCounter = 0)) : e = a.colorIndex;\n        this.colorIndex = y(this.colorIndex, e);\n      },\n      applyOptions: function (a, f) {\n        var e = this.series,\n            b = e.options.pointValKey || e.pointValKey;\n        a = C.prototype.optionsToObject.call(this, a);\n        A(this, a);\n        this.options = this.options ? A(this.options, a) : a;\n        a.group && delete this.group;\n        a.dataLabels && delete this.dataLabels;\n        b && (this.y = this[b]);\n        if (this.isNull = y(this.isValid && !this.isValid(), null === this.x || !x(this.y, !0))) this.formatPrefix = \"null\";\n        this.selected && (this.state = \"select\");\n        \"name\" in this && void 0 === f && e.xAxis && e.xAxis.hasNames && (this.x = e.xAxis.nameToX(this));\n        void 0 === this.x && e && (this.x = void 0 === f ? e.autoIncrement(this) : f);\n        return this;\n      },\n      setNestedProperty: function (f, g, e) {\n        e.split(\".\").reduce(function (b, e, c, f) {\n          b[e] = f.length - 1 === c ? g : a.isObject(b[e], !0) ? b[e] : {};\n          return b[e];\n        }, f);\n        return f;\n      },\n      optionsToObject: function (f) {\n        var h = {},\n            e = this.series,\n            b = e.options.keys,\n            l = b || e.pointArrayMap || [\"y\"],\n            c = l.length,\n            t = 0,\n            g = 0;\n        if (x(f) || null === f) h[l[0]] = f;else if (v(f)) for (!b && f.length > c && (e = typeof f[0], \"string\" === e ? h.name = f[0] : \"number\" === e && (h.x = f[0]), t++); g < c;) b && void 0 === f[t] || (0 < l[g].indexOf(\".\") ? a.Point.prototype.setNestedProperty(h, f[t], l[g]) : h[l[g]] = f[t]), t++, g++;else \"object\" === typeof f && (h = f, f.dataLabels && (e._hasPointLabels = !0), f.marker && (e._hasPointMarkers = !0));\n        return h;\n      },\n      getClassName: function () {\n        return \"highcharts-point\" + (this.selected ? \" highcharts-point-select\" : \"\") + (this.negative ? \" highcharts-negative\" : \"\") + (this.isNull ? \" highcharts-null-point\" : \"\") + (void 0 !== this.colorIndex ? \" highcharts-color-\" + this.colorIndex : \"\") + (this.options.className ? \" \" + this.options.className : \"\") + (this.zone && this.zone.className ? \" \" + this.zone.className.replace(\"highcharts-negative\", \"\") : \"\");\n      },\n      getZone: function () {\n        var a = this.series,\n            f = a.zones,\n            a = a.zoneAxis || \"y\",\n            e = 0,\n            b;\n\n        for (b = f[e]; this[a] >= b.value;) b = f[++e];\n\n        this.nonZonedColor || (this.nonZonedColor = this.color);\n        this.color = b && b.color && !this.options.color ? b.color : this.nonZonedColor;\n        return b;\n      },\n      destroy: function () {\n        var a = this.series.chart,\n            g = a.hoverPoints,\n            e;\n        a.pointCount--;\n        g && (this.setState(), E(g, this), g.length || (a.hoverPoints = null));\n        if (this === a.hoverPoint) this.onMouseOut();\n        if (this.graphic || this.dataLabel || this.dataLabels) f(this), this.destroyElements();\n        this.legendItem && a.legend.destroyItem(this);\n\n        for (e in this) this[e] = null;\n      },\n      destroyElements: function (a) {\n        var f = this,\n            e = [],\n            b,\n            h;\n        a = a || {\n          graphic: 1,\n          dataLabel: 1\n        };\n        a.graphic && e.push(\"graphic\", \"shadowGroup\");\n        a.dataLabel && e.push(\"dataLabel\", \"dataLabelUpper\", \"connector\");\n\n        for (h = e.length; h--;) b = e[h], f[b] && (f[b] = f[b].destroy());\n\n        [\"dataLabel\", \"connector\"].forEach(function (b) {\n          var c = b + \"s\";\n          a[b] && f[c] && (f[c].forEach(function (a) {\n            a.element && a.destroy();\n          }), delete f[c]);\n        });\n      },\n      getLabelConfig: function () {\n        return {\n          x: this.category,\n          y: this.y,\n          color: this.color,\n          colorIndex: this.colorIndex,\n          key: this.name || this.category,\n          series: this.series,\n          point: this,\n          percentage: this.percentage,\n          total: this.total || this.stackTotal\n        };\n      },\n      tooltipFormatter: function (a) {\n        var f = this.series,\n            e = f.tooltipOptions,\n            b = y(e.valueDecimals, \"\"),\n            h = e.valuePrefix || \"\",\n            c = e.valueSuffix || \"\";\n        f.chart.styledMode && (a = f.chart.tooltip.styledModeFormat(a));\n        (f.pointArrayMap || [\"y\"]).forEach(function (e) {\n          e = \"{point.\" + e;\n          if (h || c) a = a.replace(RegExp(e + \"}\", \"g\"), h + e + \"}\" + c);\n          a = a.replace(RegExp(e + \"}\", \"g\"), e + \":,.\" + b + \"f}\");\n        });\n        return g(a, {\n          point: this,\n          series: this.series\n        }, f.chart.time);\n      },\n      firePointEvent: function (a, f, e) {\n        var b = this,\n            h = this.series.options;\n        (h.point.events[a] || b.options && b.options.events && b.options.events[a]) && this.importEvents();\n        \"click\" === a && h.allowPointSelect && (e = function (a) {\n          b.select && b.select(null, a.ctrlKey || a.metaKey || a.shiftKey);\n        });\n        m(this, a, f, e);\n      },\n      visible: !0\n    };\n  });\n  I(H, \"parts/Series.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.addEvent,\n        A = a.animObject,\n        E = a.arrayMax,\n        m = a.arrayMin,\n        g = a.correctFloat,\n        v = a.defaultOptions,\n        x = a.defaultPlotOptions,\n        y = a.defined,\n        z = a.erase,\n        n = a.extend,\n        f = a.fireEvent,\n        h = a.isArray,\n        r = a.isNumber,\n        e = a.isString,\n        b = a.merge,\n        l = a.objectEach,\n        c = a.pick,\n        t = a.removeEvent,\n        F = a.splat,\n        w = a.SVGElement,\n        B = a.syncTimeout,\n        p = a.win;\n    a.Series = a.seriesType(\"line\", null, {\n      lineWidth: 2,\n      allowPointSelect: !1,\n      showCheckbox: !1,\n      animation: {\n        duration: 1E3\n      },\n      events: {},\n      marker: {\n        lineWidth: 0,\n        lineColor: \"#ffffff\",\n        enabledThreshold: 2,\n        radius: 4,\n        states: {\n          normal: {\n            animation: !0\n          },\n          hover: {\n            animation: {\n              duration: 50\n            },\n            enabled: !0,\n            radiusPlus: 2,\n            lineWidthPlus: 1\n          },\n          select: {\n            fillColor: \"#cccccc\",\n            lineColor: \"#000000\",\n            lineWidth: 2\n          }\n        }\n      },\n      point: {\n        events: {}\n      },\n      dataLabels: {\n        align: \"center\",\n        formatter: function () {\n          return null === this.y ? \"\" : a.numberFormat(this.y, -1);\n        },\n        padding: 5,\n        style: {\n          fontSize: \"11px\",\n          fontWeight: \"bold\",\n          color: \"contrast\",\n          textOutline: \"1px contrast\"\n        },\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0\n      },\n      cropThreshold: 300,\n      opacity: 1,\n      pointRange: 0,\n      softThreshold: !0,\n      states: {\n        normal: {\n          animation: !0\n        },\n        hover: {\n          animation: {\n            duration: 50\n          },\n          lineWidthPlus: 1,\n          marker: {},\n          halo: {\n            size: 10,\n            opacity: .25\n          }\n        },\n        select: {\n          animation: {\n            duration: 0\n          }\n        },\n        inactive: {\n          animation: {\n            duration: 50\n          },\n          opacity: .2\n        }\n      },\n      stickyTracking: !0,\n      turboThreshold: 1E3,\n      findNearestPointBy: \"x\"\n    }, {\n      isCartesian: !0,\n      pointClass: a.Point,\n      sorted: !0,\n      requireSorting: !0,\n      directTouch: !1,\n      axisTypes: [\"xAxis\", \"yAxis\"],\n      colorCounter: 0,\n      parallelArrays: [\"x\", \"y\"],\n      coll: \"series\",\n      cropShoulder: 1,\n      init: function (d, b) {\n        f(this, \"init\", {\n          options: b\n        });\n        var k = this,\n            e,\n            p = d.series,\n            q;\n        k.chart = d;\n        k.options = b = k.setOptions(b);\n        k.linkedSeries = [];\n        k.bindAxes();\n        n(k, {\n          name: b.name,\n          state: \"\",\n          visible: !1 !== b.visible,\n          selected: !0 === b.selected\n        });\n        e = b.events;\n        l(e, function (d, b) {\n          !a.isFunction(d) || k.hcEvents && k.hcEvents[b] && k.hcEvents[b].some(function (a) {\n            return a.fn === d;\n          }) || C(k, b, d);\n        });\n        if (e && e.click || b.point && b.point.events && b.point.events.click || b.allowPointSelect) d.runTrackerClick = !0;\n        k.getColor();\n        k.getSymbol();\n        k.parallelArrays.forEach(function (a) {\n          k[a + \"Data\"] || (k[a + \"Data\"] = []);\n        });\n        k.points || k.setData(b.data, !1);\n        k.isCartesian && (d.hasCartesianSeries = !0);\n        p.length && (q = p[p.length - 1]);\n        k._i = c(q && q._i, -1) + 1;\n        d.orderSeries(this.insert(p));\n        f(this, \"afterInit\");\n      },\n      insert: function (a) {\n        var d = this.options.index,\n            b;\n\n        if (r(d)) {\n          for (b = a.length; b--;) if (d >= c(a[b].options.index, a[b]._i)) {\n            a.splice(b + 1, 0, this);\n            break;\n          }\n\n          -1 === b && a.unshift(this);\n          b += 1;\n        } else a.push(this);\n\n        return c(b, a.length - 1);\n      },\n      bindAxes: function () {\n        var d = this,\n            b = d.options,\n            c = d.chart,\n            e;\n        f(this, \"bindAxes\", null, function () {\n          (d.axisTypes || []).forEach(function (k) {\n            c[k].forEach(function (a) {\n              e = a.options;\n              if (b[k] === e.index || void 0 !== b[k] && b[k] === e.id || void 0 === b[k] && 0 === e.index) d.insert(a.series), d[k] = a, a.isDirty = !0;\n            });\n            d[k] || d.optionalAxis === k || a.error(18, !0, c);\n          });\n        });\n      },\n      updateParallelArrays: function (a, b) {\n        var d = a.series,\n            c = arguments,\n            k = r(b) ? function (c) {\n          var k = \"y\" === c && d.toYData ? d.toYData(a) : a[c];\n          d[c + \"Data\"][b] = k;\n        } : function (a) {\n          Array.prototype[b].apply(d[a + \"Data\"], Array.prototype.slice.call(c, 2));\n        };\n        d.parallelArrays.forEach(k);\n      },\n      hasData: function () {\n        return this.visible && void 0 !== this.dataMax && void 0 !== this.dataMin || this.visible && this.yData && 0 < this.yData.length;\n      },\n      autoIncrement: function () {\n        var a = this.options,\n            b = this.xIncrement,\n            e,\n            f = a.pointIntervalUnit,\n            p = this.chart.time,\n            b = c(b, a.pointStart, 0);\n        this.pointInterval = e = c(this.pointInterval, a.pointInterval, 1);\n        f && (a = new p.Date(b), \"day\" === f ? p.set(\"Date\", a, p.get(\"Date\", a) + e) : \"month\" === f ? p.set(\"Month\", a, p.get(\"Month\", a) + e) : \"year\" === f && p.set(\"FullYear\", a, p.get(\"FullYear\", a) + e), e = a.getTime() - b);\n        this.xIncrement = b + e;\n        return b;\n      },\n      setOptions: function (a) {\n        var d = this.chart,\n            e = d.options,\n            p = e.plotOptions,\n            h = d.userOptions || {};\n        a = b(a);\n        var d = d.styledMode,\n            q = {\n          plotOptions: p,\n          userOptions: a\n        };\n        f(this, \"setOptions\", q);\n        var l = h.plotOptions || {},\n            g = q.plotOptions[this.type];\n        this.userOptions = q.userOptions;\n        h = b(g, p.series, h.plotOptions && h.plotOptions[this.type], a);\n        this.tooltipOptions = b(v.tooltip, v.plotOptions.series && v.plotOptions.series.tooltip, v.plotOptions[this.type].tooltip, e.tooltip.userOptions, p.series && p.series.tooltip, p[this.type].tooltip, a.tooltip);\n        this.stickyTracking = c(a.stickyTracking, l[this.type] && l[this.type].stickyTracking, l.series && l.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : h.stickyTracking);\n        null === g.marker && delete h.marker;\n        this.zoneAxis = h.zoneAxis;\n        e = this.zones = (h.zones || []).slice();\n        !h.negativeColor && !h.negativeFillColor || h.zones || (p = {\n          value: h[this.zoneAxis + \"Threshold\"] || h.threshold || 0,\n          className: \"highcharts-negative\"\n        }, d || (p.color = h.negativeColor, p.fillColor = h.negativeFillColor), e.push(p));\n        e.length && y(e[e.length - 1].value) && e.push(d ? {} : {\n          color: this.color,\n          fillColor: this.fillColor\n        });\n        f(this, \"afterSetOptions\", {\n          options: h\n        });\n        return h;\n      },\n      getName: function () {\n        return c(this.options.name, \"Series \" + (this.index + 1));\n      },\n      getCyclic: function (a, b, e) {\n        var d,\n            k = this.chart,\n            u = this.userOptions,\n            f = a + \"Index\",\n            p = a + \"Counter\",\n            h = e ? e.length : c(k.options.chart[a + \"Count\"], k[a + \"Count\"]);\n        b || (d = c(u[f], u[\"_\" + f]), y(d) || (k.series.length || (k[p] = 0), u[\"_\" + f] = d = k[p] % h, k[p] += 1), e && (b = e[d]));\n        void 0 !== d && (this[f] = d);\n        this[a] = b;\n      },\n      getColor: function () {\n        this.chart.styledMode ? this.getCyclic(\"color\") : this.options.colorByPoint ? this.options.color = null : this.getCyclic(\"color\", this.options.color || x[this.type].color, this.chart.options.colors);\n      },\n      getSymbol: function () {\n        this.getCyclic(\"symbol\", this.options.marker.symbol, this.chart.options.symbols);\n      },\n      findPointIndex: function (a, b) {\n        var d = a.id;\n        a = a.x;\n        var c = this.points,\n            e,\n            k;\n        d && (k = (d = this.chart.get(d)) && d.index, void 0 !== k && (e = !0));\n        void 0 === k && r(a) && (k = this.xData.indexOf(a, b));\n        -1 !== k && void 0 !== k && this.cropped && (k = k >= this.cropStart ? k - this.cropStart : k);\n        !e && c[k] && c[k].touched && (k = void 0);\n        return k;\n      },\n      drawLegendSymbol: a.LegendSymbolMixin.drawLineMarker,\n      updateData: function (d) {\n        var b = this.options,\n            c = this.points,\n            e = [],\n            f,\n            q,\n            p,\n            h = this.requireSorting,\n            l = d.length === c.length,\n            g = !0;\n        this.xIncrement = null;\n        d.forEach(function (d, k) {\n          var u,\n              q = a.defined(d) && this.pointClass.prototype.optionsToObject.call({\n            series: this\n          }, d) || {};\n          u = q.x;\n          if (q.id || r(u)) if (u = this.findPointIndex(q, p), -1 === u || void 0 === u ? e.push(d) : c[u] && d !== b.data[u] ? (c[u].update(d, !1, null, !1), c[u].touched = !0, h && (p = u + 1)) : c[u] && (c[u].touched = !0), !l || k !== u || this.hasDerivedData) f = !0;\n        }, this);\n        if (f) for (d = c.length; d--;) (q = c[d]) && !q.touched && q.remove(!1);else l ? d.forEach(function (a, d) {\n          c[d].update && a !== c[d].y && c[d].update(a, !1, null, !1);\n        }) : g = !1;\n        c.forEach(function (a) {\n          a && (a.touched = !1);\n        });\n        if (!g) return !1;\n        e.forEach(function (a) {\n          this.addPoint(a, !1, null, null, !1);\n        }, this);\n        return !0;\n      },\n      setData: function (d, b, u, f) {\n        var k = this,\n            q = k.points,\n            p = q && q.length || 0,\n            l,\n            g = k.options,\n            t = k.chart,\n            w = null,\n            D = k.xAxis,\n            n = g.turboThreshold,\n            m = this.xData,\n            B = this.yData,\n            F = (l = k.pointArrayMap) && l.length,\n            v = g.keys,\n            x = 0,\n            y = 1,\n            z;\n        d = d || [];\n        l = d.length;\n        b = c(b, !0);\n        !1 !== f && l && p && !k.cropped && !k.hasGroupedData && k.visible && !k.isSeriesBoosting && (z = this.updateData(d));\n\n        if (!z) {\n          k.xIncrement = null;\n          k.colorCounter = 0;\n          this.parallelArrays.forEach(function (a) {\n            k[a + \"Data\"].length = 0;\n          });\n\n          if (n && l > n) {\n            for (u = 0; null === w && u < l;) w = d[u], u++;\n\n            if (r(w)) for (u = 0; u < l; u++) m[u] = this.autoIncrement(), B[u] = d[u];else if (h(w)) {\n              if (F) for (u = 0; u < l; u++) w = d[u], m[u] = w[0], B[u] = w.slice(1, F + 1);else for (v && (x = v.indexOf(\"x\"), y = v.indexOf(\"y\"), x = 0 <= x ? x : 0, y = 0 <= y ? y : 1), u = 0; u < l; u++) w = d[u], m[u] = w[x], B[u] = w[y];\n            } else a.error(12, !1, t);\n          } else for (u = 0; u < l; u++) void 0 !== d[u] && (w = {\n            series: k\n          }, k.pointClass.prototype.applyOptions.apply(w, [d[u]]), k.updateParallelArrays(w, u));\n\n          B && e(B[0]) && a.error(14, !0, t);\n          k.data = [];\n          k.options.data = k.userOptions.data = d;\n\n          for (u = p; u--;) q[u] && q[u].destroy && q[u].destroy();\n\n          D && (D.minRange = D.userMinRange);\n          k.isDirty = t.isDirtyBox = !0;\n          k.isDirtyData = !!q;\n          u = !1;\n        }\n\n        \"point\" === g.legendType && (this.processData(), this.generatePoints());\n        b && t.redraw(u);\n      },\n      processData: function (d) {\n        var b = this.xData,\n            c = this.yData,\n            e = b.length,\n            f;\n        f = 0;\n        var q,\n            p,\n            h = this.xAxis,\n            l,\n            g = this.options;\n        l = g.cropThreshold;\n        var t = this.getExtremesFromAll || g.getExtremesFromAll,\n            r = this.isCartesian,\n            g = h && h.val2lin,\n            w = h && h.isLog,\n            n = this.requireSorting,\n            m,\n            B;\n        if (r && !this.isDirty && !h.isDirty && !this.yAxis.isDirty && !d) return !1;\n        h && (d = h.getExtremes(), m = d.min, B = d.max);\n        r && this.sorted && !t && (!l || e > l || this.forceCrop) && (b[e - 1] < m || b[0] > B ? (b = [], c = []) : this.yData && (b[0] < m || b[e - 1] > B) && (f = this.cropData(this.xData, this.yData, m, B), b = f.xData, c = f.yData, f = f.start, q = !0));\n\n        for (l = b.length || 1; --l;) e = w ? g(b[l]) - g(b[l - 1]) : b[l] - b[l - 1], 0 < e && (void 0 === p || e < p) ? p = e : 0 > e && n && (a.error(15, !1, this.chart), n = !1);\n\n        this.cropped = q;\n        this.cropStart = f;\n        this.processedXData = b;\n        this.processedYData = c;\n        this.closestPointRange = p;\n      },\n      cropData: function (a, b, e, f, p) {\n        var d = a.length,\n            k = 0,\n            u = d,\n            h;\n        p = c(p, this.cropShoulder);\n\n        for (h = 0; h < d; h++) if (a[h] >= e) {\n          k = Math.max(0, h - p);\n          break;\n        }\n\n        for (e = h; e < d; e++) if (a[e] > f) {\n          u = e + p;\n          break;\n        }\n\n        return {\n          xData: a.slice(k, u),\n          yData: b.slice(k, u),\n          start: k,\n          end: u\n        };\n      },\n      generatePoints: function () {\n        var a = this.options,\n            b = a.data,\n            c = this.data,\n            e,\n            p = this.processedXData,\n            q = this.processedYData,\n            h = this.pointClass,\n            l = p.length,\n            g = this.cropStart || 0,\n            t,\n            r = this.hasGroupedData,\n            a = a.keys,\n            w,\n            m = [],\n            B;\n        c || r || (c = [], c.length = b.length, c = this.data = c);\n        a && r && (this.options.keys = !1);\n\n        for (B = 0; B < l; B++) t = g + B, r ? (w = new h().init(this, [p[B]].concat(F(q[B]))), w.dataGroup = this.groupMap[B], w.dataGroup.options && (w.options = w.dataGroup.options, n(w, w.dataGroup.options), delete w.dataLabels)) : (w = c[t]) || void 0 === b[t] || (c[t] = w = new h().init(this, b[t], p[B])), w && (w.index = t, m[B] = w);\n\n        this.options.keys = a;\n        if (c && (l !== (e = c.length) || r)) for (B = 0; B < e; B++) B !== g || r || (B += l), c[B] && (c[B].destroyElements(), c[B].plotX = void 0);\n        this.data = c;\n        this.points = m;\n        f(this, \"afterGeneratePoints\");\n      },\n      getXExtremes: function (a) {\n        return {\n          min: m(a),\n          max: E(a)\n        };\n      },\n      getExtremes: function (a) {\n        var d = this.yAxis,\n            b = this.processedXData,\n            c,\n            e = [],\n            q = 0;\n        c = this.xAxis.getExtremes();\n        var p = c.min,\n            l = c.max,\n            g,\n            t,\n            w = this.requireSorting ? this.cropShoulder : 0,\n            n,\n            B;\n        a = a || this.stackedYData || this.processedYData || [];\n        c = a.length;\n\n        for (B = 0; B < c; B++) if (t = b[B], n = a[B], g = (r(n, !0) || h(n)) && (!d.positiveValuesOnly || n.length || 0 < n), t = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || (b[B + w] || t) >= p && (b[B - w] || t) <= l, g && t) if (g = n.length) for (; g--;) \"number\" === typeof n[g] && (e[q++] = n[g]);else e[q++] = n;\n\n        this.dataMin = m(e);\n        this.dataMax = E(e);\n        f(this, \"afterGetExtremes\");\n      },\n      translate: function () {\n        this.processedXData || this.processData();\n        this.generatePoints();\n        var a = this.options,\n            b = a.stacking,\n            e = this.xAxis,\n            p = e.categories,\n            l = this.yAxis,\n            q = this.points,\n            t = q.length,\n            w = !!this.modifyValue,\n            n,\n            m = this.pointPlacementToXValue(),\n            B = r(m),\n            F = a.threshold,\n            v = a.startFromThreshold ? F : 0,\n            x,\n            z,\n            A,\n            C,\n            E = this.zoneAxis || \"y\",\n            H = Number.MAX_VALUE;\n\n        for (n = 0; n < t; n++) {\n          var I = q[n],\n              U = I.x;\n          z = I.y;\n          var T = I.low,\n              X = b && l.stacks[(this.negStacks && z < (v ? 0 : F) ? \"-\" : \"\") + this.stackKey],\n              Y,\n              V;\n          l.positiveValuesOnly && null !== z && 0 >= z && (I.isNull = !0);\n          I.plotX = x = g(Math.min(Math.max(-1E5, e.translate(U, 0, 0, 0, 1, m, \"flags\" === this.type)), 1E5));\n          b && this.visible && !I.isNull && X && X[U] && (C = this.getStackIndicator(C, U, this.index), Y = X[U], V = Y.points[C.key]);\n          h(V) && (T = V[0], z = V[1], T === v && C.key === X[U].base && (T = c(r(F) && F, l.min)), l.positiveValuesOnly && 0 >= T && (T = null), I.total = I.stackTotal = Y.total, I.percentage = Y.total && I.y / Y.total * 100, I.stackY = z, Y.setOffset(this.pointXOffset || 0, this.barW || 0));\n          I.yBottom = y(T) ? Math.min(Math.max(-1E5, l.translate(T, 0, 1, 0, 1)), 1E5) : null;\n          w && (z = this.modifyValue(z, I));\n          I.plotY = z = \"number\" === typeof z && Infinity !== z ? Math.min(Math.max(-1E5, l.translate(z, 0, 1, 0, 1)), 1E5) : void 0;\n          I.isInside = void 0 !== z && 0 <= z && z <= l.len && 0 <= x && x <= e.len;\n          I.clientX = B ? g(e.translate(U, 0, 0, 0, 1, m)) : x;\n          I.negative = I[E] < (a[E + \"Threshold\"] || F || 0);\n          I.category = p && void 0 !== p[I.x] ? p[I.x] : I.x;\n          I.isNull || (void 0 !== A && (H = Math.min(H, Math.abs(x - A))), A = x);\n          I.zone = this.zones.length && I.getZone();\n        }\n\n        this.closestPointRangePx = H;\n        f(this, \"afterTranslate\");\n      },\n      getValidPoints: function (a, b, c) {\n        var d = this.chart;\n        return (a || this.points || []).filter(function (a) {\n          return b && !d.isInsidePlot(a.plotX, a.plotY, d.inverted) ? !1 : c || !a.isNull;\n        });\n      },\n      getClipBox: function (a, b) {\n        var d = this.options,\n            c = this.chart,\n            e = c.inverted,\n            k = this.xAxis,\n            f = k && this.yAxis;\n        a && !1 === d.clip && f ? a = e ? {\n          y: -c.chartWidth + f.len + f.pos,\n          height: c.chartWidth,\n          width: c.chartHeight,\n          x: -c.chartHeight + k.len + k.pos\n        } : {\n          y: -f.pos,\n          height: c.chartHeight,\n          width: c.chartWidth,\n          x: -k.pos\n        } : (a = this.clipBox || c.clipBox, b && (a.width = c.plotSizeX, a.x = 0));\n        return b ? {\n          width: a.width,\n          x: a.x\n        } : a;\n      },\n      setClip: function (a) {\n        var d = this.chart,\n            b = this.options,\n            c = d.renderer,\n            e = d.inverted,\n            f = this.clipBox,\n            p = this.getClipBox(a),\n            h = this.sharedClipKey || [\"_sharedClip\", a && a.duration, a && a.easing, p.height, b.xAxis, b.yAxis].join(),\n            l = d[h],\n            g = d[h + \"m\"];\n        l || (a && (p.width = 0, e && (p.x = d.plotSizeX + (!1 !== b.clip ? 0 : d.plotTop)), d[h + \"m\"] = g = c.clipRect(e ? d.plotSizeX + 99 : -99, e ? -d.plotLeft : -d.plotTop, 99, e ? d.chartWidth : d.chartHeight)), d[h] = l = c.clipRect(p), l.count = {\n          length: 0\n        });\n        a && !l.count[this.index] && (l.count[this.index] = !0, l.count.length += 1);\n        if (!1 !== b.clip || a) this.group.clip(a || f ? l : d.clipRect), this.markerGroup.clip(g), this.sharedClipKey = h;\n        a || (l.count[this.index] && (delete l.count[this.index], --l.count.length), 0 === l.count.length && h && d[h] && (f || (d[h] = d[h].destroy()), d[h + \"m\"] && (d[h + \"m\"] = d[h + \"m\"].destroy())));\n      },\n      animate: function (a) {\n        var d = this.chart,\n            b = A(this.options.animation),\n            c,\n            e;\n        a ? this.setClip(b) : (c = this.sharedClipKey, a = d[c], e = this.getClipBox(b, !0), a && a.animate(e, b), d[c + \"m\"] && d[c + \"m\"].animate({\n          width: e.width + 99,\n          x: e.x - (d.inverted ? 0 : 99)\n        }, b), this.animate = null);\n      },\n      afterAnimate: function () {\n        this.setClip();\n        f(this, \"afterAnimate\");\n        this.finishedAnimating = !0;\n      },\n      drawPoints: function () {\n        var a = this.points,\n            b = this.chart,\n            e,\n            f,\n            p,\n            q,\n            h,\n            l = this.options.marker,\n            g,\n            t,\n            r,\n            w = this[this.specialGroup] || this.markerGroup;\n        e = this.xAxis;\n        var n,\n            m = c(l.enabled, !e || e.isRadial ? !0 : null, this.closestPointRangePx >= l.enabledThreshold * l.radius);\n        if (!1 !== l.enabled || this._hasPointMarkers) for (e = 0; e < a.length; e++) if (f = a[e], h = (q = f.graphic) ? \"animate\" : \"attr\", g = f.marker || {}, t = !!f.marker, p = m && void 0 === g.enabled || g.enabled, r = !1 !== f.isInside, p && !f.isNull) {\n          p = c(g.symbol, this.symbol);\n          n = this.markerAttribs(f, f.selected && \"select\");\n          q ? q[r ? \"show\" : \"hide\"](!0).animate(n) : r && (0 < n.width || f.hasImage) && (f.graphic = q = b.renderer.symbol(p, n.x, n.y, n.width, n.height, t ? g : l).add(w));\n          if (q && !b.styledMode) q[h](this.pointAttribs(f, f.selected && \"select\"));\n          q && q.addClass(f.getClassName(), !0);\n        } else q && (f.graphic = q.destroy());\n      },\n      markerAttribs: function (a, b) {\n        var d = this.options.marker,\n            e = a.marker || {},\n            k = e.symbol || d.symbol,\n            f = c(e.radius, d.radius);\n        b && (d = d.states[b], b = e.states && e.states[b], f = c(b && b.radius, d && d.radius, f + (d && d.radiusPlus || 0)));\n        a.hasImage = k && 0 === k.indexOf(\"url\");\n        a.hasImage && (f = 0);\n        a = {\n          x: Math.floor(a.plotX) - f,\n          y: a.plotY - f\n        };\n        f && (a.width = a.height = 2 * f);\n        return a;\n      },\n      pointAttribs: function (a, b) {\n        var d = this.options.marker,\n            e = a && a.options,\n            k = e && e.marker || {},\n            f = this.color,\n            p = e && e.color,\n            h = a && a.color,\n            e = c(k.lineWidth, d.lineWidth),\n            l = a && a.zone && a.zone.color;\n        a = 1;\n        f = p || l || h || f;\n        p = k.fillColor || d.fillColor || f;\n        f = k.lineColor || d.lineColor || f;\n        b = b || \"normal\";\n        d = d.states[b];\n        b = k.states && k.states[b] || {};\n        e = c(b.lineWidth, d.lineWidth, e + c(b.lineWidthPlus, d.lineWidthPlus, 0));\n        p = b.fillColor || d.fillColor || p;\n        f = b.lineColor || d.lineColor || f;\n        a = c(b.opacity, d.opacity, a);\n        return {\n          stroke: f,\n          \"stroke-width\": e,\n          fill: p,\n          opacity: a\n        };\n      },\n      destroy: function (d) {\n        var b = this,\n            c = b.chart,\n            e = /AppleWebKit\\/533/.test(p.navigator.userAgent),\n            h,\n            q,\n            g = b.data || [],\n            r,\n            n;\n        f(b, \"destroy\");\n        d || t(b);\n        (b.axisTypes || []).forEach(function (a) {\n          (n = b[a]) && n.series && (z(n.series, b), n.isDirty = n.forceRedraw = !0);\n        });\n        b.legendItem && b.chart.legend.destroyItem(b);\n\n        for (q = g.length; q--;) (r = g[q]) && r.destroy && r.destroy();\n\n        b.points = null;\n        a.clearTimeout(b.animationTimeout);\n        l(b, function (a, d) {\n          a instanceof w && !a.survive && (h = e && \"group\" === d ? \"hide\" : \"destroy\", a[h]());\n        });\n        c.hoverSeries === b && (c.hoverSeries = null);\n        z(c.series, b);\n        c.orderSeries();\n        l(b, function (a, c) {\n          d && \"hcEvents\" === c || delete b[c];\n        });\n      },\n      getGraphPath: function (a, b, c) {\n        var d = this,\n            e = d.options,\n            k = e.step,\n            f,\n            p = [],\n            h = [],\n            u;\n        a = a || d.points;\n        (f = a.reversed) && a.reverse();\n        (k = {\n          right: 1,\n          center: 2\n        }[k] || k && 3) && f && (k = 4 - k);\n        !e.connectNulls || b || c || (a = this.getValidPoints(a));\n        a.forEach(function (f, q) {\n          var l = f.plotX,\n              g = f.plotY,\n              t = a[q - 1];\n          (f.leftCliff || t && t.rightCliff) && !c && (u = !0);\n          f.isNull && !y(b) && 0 < q ? u = !e.connectNulls : f.isNull && !b ? u = !0 : (0 === q || u ? q = [\"M\", f.plotX, f.plotY] : d.getPointSpline ? q = d.getPointSpline(a, f, q) : k ? (q = 1 === k ? [\"L\", t.plotX, g] : 2 === k ? [\"L\", (t.plotX + l) / 2, t.plotY, \"L\", (t.plotX + l) / 2, g] : [\"L\", l, t.plotY], q.push(\"L\", l, g)) : q = [\"L\", l, g], h.push(f.x), k && (h.push(f.x), 2 === k && h.push(f.x)), p.push.apply(p, q), u = !1);\n        });\n        p.xMap = h;\n        return d.graphPath = p;\n      },\n      drawGraph: function () {\n        var a = this,\n            b = this.options,\n            c = (this.gappedPath || this.getGraphPath).call(this),\n            e = this.chart.styledMode,\n            f = [[\"graph\", \"highcharts-graph\"]];\n        e || f[0].push(b.lineColor || this.color || \"#cccccc\", b.dashStyle);\n        f = a.getZonesGraphs(f);\n        f.forEach(function (d, k) {\n          var f = d[0],\n              p = a[f],\n              h = p ? \"animate\" : \"attr\";\n          p ? (p.endX = a.preventGraphAnimation ? null : c.xMap, p.animate({\n            d: c\n          })) : c.length && (a[f] = p = a.chart.renderer.path(c).addClass(d[1]).attr({\n            zIndex: 1\n          }).add(a.group));\n          p && !e && (f = {\n            stroke: d[2],\n            \"stroke-width\": b.lineWidth,\n            fill: a.fillGraph && a.color || \"none\"\n          }, d[3] ? f.dashstyle = d[3] : \"square\" !== b.linecap && (f[\"stroke-linecap\"] = f[\"stroke-linejoin\"] = \"round\"), p[h](f).shadow(2 > k && b.shadow));\n          p && (p.startX = c.xMap, p.isArea = c.isArea);\n        });\n      },\n      getZonesGraphs: function (a) {\n        this.zones.forEach(function (d, b) {\n          b = [\"zone-graph-\" + b, \"highcharts-graph highcharts-zone-graph-\" + b + \" \" + (d.className || \"\")];\n          this.chart.styledMode || b.push(d.color || this.color, d.dashStyle || this.options.dashStyle);\n          a.push(b);\n        }, this);\n        return a;\n      },\n      applyZones: function () {\n        var a = this,\n            b = this.chart,\n            e = b.renderer,\n            f = this.zones,\n            p,\n            h,\n            l = this.clips || [],\n            g,\n            t = this.graph,\n            r = this.area,\n            w = Math.max(b.chartWidth, b.chartHeight),\n            n = this[(this.zoneAxis || \"y\") + \"Axis\"],\n            m,\n            B,\n            F = b.inverted,\n            v,\n            x,\n            y,\n            z,\n            A = !1;\n        f.length && (t || r) && n && void 0 !== n.min ? (B = n.reversed, v = n.horiz, t && !this.showLine && t.hide(), r && r.hide(), m = n.getExtremes(), f.forEach(function (d, k) {\n          p = B ? v ? b.plotWidth : 0 : v ? 0 : n.toPixels(m.min) || 0;\n          p = Math.min(Math.max(c(h, p), 0), w);\n          h = Math.min(Math.max(Math.round(n.toPixels(c(d.value, m.max), !0) || 0), 0), w);\n          A && (p = h = n.toPixels(m.max));\n          x = Math.abs(p - h);\n          y = Math.min(p, h);\n          z = Math.max(p, h);\n          n.isXAxis ? (g = {\n            x: F ? z : y,\n            y: 0,\n            width: x,\n            height: w\n          }, v || (g.x = b.plotHeight - g.x)) : (g = {\n            x: 0,\n            y: F ? z : y,\n            width: w,\n            height: x\n          }, v && (g.y = b.plotWidth - g.y));\n          F && e.isVML && (g = n.isXAxis ? {\n            x: 0,\n            y: B ? y : z,\n            height: g.width,\n            width: b.chartWidth\n          } : {\n            x: g.y - b.plotLeft - b.spacingBox.x,\n            y: 0,\n            width: g.height,\n            height: b.chartHeight\n          });\n          l[k] ? l[k].animate(g) : l[k] = e.clipRect(g);\n          t && a[\"zone-graph-\" + k].clip(l[k]);\n          r && a[\"zone-area-\" + k].clip(l[k]);\n          A = d.value > m.max;\n          a.resetZones && 0 === h && (h = void 0);\n        }), this.clips = l) : a.visible && (t && t.show(!0), r && r.show(!0));\n      },\n      invertGroups: function (a) {\n        function d() {\n          [\"group\", \"markerGroup\"].forEach(function (d) {\n            b[d] && (c.renderer.isVML && b[d].attr({\n              width: b.yAxis.len,\n              height: b.xAxis.len\n            }), b[d].width = b.yAxis.len, b[d].height = b.xAxis.len, b[d].invert(a));\n          });\n        }\n\n        var b = this,\n            c = b.chart,\n            e;\n        b.xAxis && (e = C(c, \"resize\", d), C(b, \"destroy\", e), d(a), b.invertGroups = d);\n      },\n      plotGroup: function (a, b, c, e, f) {\n        var d = this[a],\n            k = !d;\n        k && (this[a] = d = this.chart.renderer.g().attr({\n          zIndex: e || .1\n        }).add(f));\n        d.addClass(\"highcharts-\" + b + \" highcharts-series-\" + this.index + \" highcharts-\" + this.type + \"-series \" + (y(this.colorIndex) ? \"highcharts-color-\" + this.colorIndex + \" \" : \"\") + (this.options.className || \"\") + (d.hasClass(\"highcharts-tracker\") ? \" highcharts-tracker\" : \"\"), !0);\n        d.attr({\n          visibility: c\n        })[k ? \"attr\" : \"animate\"](this.getPlotBox());\n        return d;\n      },\n      getPlotBox: function () {\n        var a = this.chart,\n            b = this.xAxis,\n            c = this.yAxis;\n        a.inverted && (b = c, c = this.xAxis);\n        return {\n          translateX: b ? b.left : a.plotLeft,\n          translateY: c ? c.top : a.plotTop,\n          scaleX: 1,\n          scaleY: 1\n        };\n      },\n      render: function () {\n        var a = this,\n            b = a.chart,\n            c,\n            e = a.options,\n            p = !!a.animate && b.renderer.isSVG && A(e.animation).duration,\n            h = a.visible ? \"inherit\" : \"hidden\",\n            l = e.zIndex,\n            g = a.hasRendered,\n            t = b.seriesGroup,\n            r = b.inverted;\n        f(this, \"render\");\n        c = a.plotGroup(\"group\", \"series\", h, l, t);\n        a.markerGroup = a.plotGroup(\"markerGroup\", \"markers\", h, l, t);\n        p && a.animate(!0);\n        c.inverted = a.isCartesian || a.invertable ? r : !1;\n        a.drawGraph && (a.drawGraph(), a.applyZones());\n        a.visible && a.drawPoints();\n        a.drawDataLabels && a.drawDataLabels();\n        a.redrawPoints && a.redrawPoints();\n        a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker();\n        a.invertGroups(r);\n        !1 === e.clip || a.sharedClipKey || g || c.clip(b.clipRect);\n        p && a.animate();\n        g || (a.animationTimeout = B(function () {\n          a.afterAnimate();\n        }, p));\n        a.isDirty = !1;\n        a.hasRendered = !0;\n        f(a, \"afterRender\");\n      },\n      redraw: function () {\n        var a = this.chart,\n            b = this.isDirty || this.isDirtyData,\n            e = this.group,\n            f = this.xAxis,\n            p = this.yAxis;\n        e && (a.inverted && e.attr({\n          width: a.plotWidth,\n          height: a.plotHeight\n        }), e.animate({\n          translateX: c(f && f.left, a.plotLeft),\n          translateY: c(p && p.top, a.plotTop)\n        }));\n        this.translate();\n        this.render();\n        b && delete this.kdTree;\n      },\n      kdAxisArray: [\"clientX\", \"plotY\"],\n      searchPoint: function (a, b) {\n        var d = this.xAxis,\n            c = this.yAxis,\n            e = this.chart.inverted;\n        return this.searchKDTree({\n          clientX: e ? d.len - a.chartY + d.pos : a.chartX - d.pos,\n          plotY: e ? c.len - a.chartX + c.pos : a.chartY - c.pos\n        }, b, a);\n      },\n      buildKDTree: function (a) {\n        function b(a, c, e) {\n          var k, f;\n          if (f = a && a.length) return k = d.kdAxisArray[c % e], a.sort(function (a, b) {\n            return a[k] - b[k];\n          }), f = Math.floor(f / 2), {\n            point: a[f],\n            left: b(a.slice(0, f), c + 1, e),\n            right: b(a.slice(f + 1), c + 1, e)\n          };\n        }\n\n        this.buildingKdTree = !0;\n        var d = this,\n            c = -1 < d.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        delete d.kdTree;\n        B(function () {\n          d.kdTree = b(d.getValidPoints(null, !d.directTouch), c, c);\n          d.buildingKdTree = !1;\n        }, d.options.kdNow || a && \"touchstart\" === a.type ? 0 : 1);\n      },\n      searchKDTree: function (a, b, c) {\n        function d(a, b, c, h) {\n          var l = b.point,\n              q = e.kdAxisArray[c % h],\n              u,\n              g,\n              t = l;\n          g = y(a[k]) && y(l[k]) ? Math.pow(a[k] - l[k], 2) : null;\n          u = y(a[f]) && y(l[f]) ? Math.pow(a[f] - l[f], 2) : null;\n          u = (g || 0) + (u || 0);\n          l.dist = y(u) ? Math.sqrt(u) : Number.MAX_VALUE;\n          l.distX = y(g) ? Math.sqrt(g) : Number.MAX_VALUE;\n          q = a[q] - l[q];\n          u = 0 > q ? \"left\" : \"right\";\n          g = 0 > q ? \"right\" : \"left\";\n          b[u] && (u = d(a, b[u], c + 1, h), t = u[p] < t[p] ? u : l);\n          b[g] && Math.sqrt(q * q) < t[p] && (a = d(a, b[g], c + 1, h), t = a[p] < t[p] ? a : t);\n          return t;\n        }\n\n        var e = this,\n            k = this.kdAxisArray[0],\n            f = this.kdAxisArray[1],\n            p = b ? \"distX\" : \"dist\";\n        b = -1 < e.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        this.kdTree || this.buildingKdTree || this.buildKDTree(c);\n        if (this.kdTree) return d(a, this.kdTree, b, b);\n      },\n      pointPlacementToXValue: function () {\n        var a = this.options.pointPlacement;\n        \"between\" === a && (a = .5);\n        r(a) && (a *= c(this.options.pointRange || this.xAxis.pointRange));\n        return a;\n      }\n    });\n  });\n  I(H, \"parts/Stacking.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.Axis,\n        A = a.Chart,\n        E = a.correctFloat,\n        m = a.defined,\n        g = a.destroyObjectProperties,\n        v = a.format,\n        x = a.objectEach,\n        y = a.pick,\n        z = a.Series;\n\n    a.StackItem = function (a, f, h, g, e) {\n      var b = a.chart.inverted;\n      this.axis = a;\n      this.isNegative = h;\n      this.options = f;\n      this.x = g;\n      this.total = null;\n      this.points = {};\n      this.stack = e;\n      this.rightCliff = this.leftCliff = 0;\n      this.alignOptions = {\n        align: f.align || (b ? h ? \"left\" : \"right\" : \"center\"),\n        verticalAlign: f.verticalAlign || (b ? \"middle\" : h ? \"bottom\" : \"top\"),\n        y: y(f.y, b ? 4 : h ? 14 : -6),\n        x: y(f.x, b ? h ? -6 : 6 : 0)\n      };\n      this.textAlign = f.textAlign || (b ? h ? \"right\" : \"left\" : \"center\");\n    };\n\n    a.StackItem.prototype = {\n      destroy: function () {\n        g(this, this.axis);\n      },\n      render: function (a) {\n        var f = this.axis.chart,\n            h = this.options,\n            g = h.format,\n            g = g ? v(g, this, f.time) : h.formatter.call(this);\n        this.label ? this.label.attr({\n          text: g,\n          visibility: \"hidden\"\n        }) : this.label = f.renderer.text(g, null, null, h.useHTML).css(h.style).attr({\n          align: this.textAlign,\n          rotation: h.rotation,\n          visibility: \"hidden\"\n        }).add(a);\n        this.label.labelrank = f.plotHeight;\n      },\n      setOffset: function (a, f, h, g) {\n        var e = this.axis,\n            b = e.chart;\n        g = e.translate(e.usePercentage ? 100 : g ? g : this.total, 0, 0, 0, 1);\n        h = e.translate(h ? h : 0);\n        h = m(g) && Math.abs(g - h);\n        a = b.xAxis[0].translate(this.x) + a;\n        e = m(g) && this.getStackBox(b, this, a, g, f, h, e);\n        (f = this.label) && e && (f.align(this.alignOptions, null, e), e = f.alignAttr, f[!1 === this.options.crop || b.isInsidePlot(e.x, e.y) ? \"show\" : \"hide\"](!0));\n      },\n      getStackBox: function (a, f, h, g, e, b, l) {\n        var c = f.axis.reversed,\n            t = a.inverted;\n        a = l.height + l.pos - (t ? a.plotLeft : a.plotTop);\n        f = f.isNegative && !c || !f.isNegative && c;\n        return {\n          x: t ? f ? g : g - b : h,\n          y: t ? a - h - e : f ? a - g - b : a - g,\n          width: t ? b : e,\n          height: t ? e : b\n        };\n      }\n    };\n\n    A.prototype.getStacks = function () {\n      var a = this;\n      a.yAxis.forEach(function (a) {\n        a.stacks && a.hasVisibleSeries && (a.oldStacks = a.stacks);\n      });\n      a.series.forEach(function (f) {\n        !f.options.stacking || !0 !== f.visible && !1 !== a.options.chart.ignoreHiddenSeries || (f.stackKey = f.type + y(f.options.stack, \"\"));\n      });\n    };\n\n    C.prototype.buildStacks = function () {\n      var a = this.series,\n          f = y(this.options.reversedStacks, !0),\n          h = a.length,\n          g;\n\n      if (!this.isXAxis) {\n        this.usePercentage = !1;\n\n        for (g = h; g--;) a[f ? g : h - g - 1].setStackedPoints();\n\n        for (g = 0; g < h; g++) a[g].modifyStacks();\n      }\n    };\n\n    C.prototype.renderStackTotals = function () {\n      var a = this.chart,\n          f = a.renderer,\n          h = this.stacks,\n          g = this.stackTotalGroup;\n      g || (this.stackTotalGroup = g = f.g(\"stack-labels\").attr({\n        visibility: \"visible\",\n        zIndex: 6\n      }).add());\n      g.translate(a.plotLeft, a.plotTop);\n      x(h, function (a) {\n        x(a, function (a) {\n          a.render(g);\n        });\n      });\n    };\n\n    C.prototype.resetStacks = function () {\n      var a = this,\n          f = a.stacks;\n      a.isXAxis || x(f, function (f) {\n        x(f, function (h, e) {\n          h.touched < a.stacksTouched ? (h.destroy(), delete f[e]) : (h.total = null, h.cumulative = null);\n        });\n      });\n    };\n\n    C.prototype.cleanStacks = function () {\n      var a;\n      this.isXAxis || (this.oldStacks && (a = this.stacks = this.oldStacks), x(a, function (a) {\n        x(a, function (a) {\n          a.cumulative = a.total;\n        });\n      }));\n    };\n\n    z.prototype.setStackedPoints = function () {\n      if (this.options.stacking && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {\n        var g = this.processedXData,\n            f = this.processedYData,\n            h = [],\n            r = f.length,\n            e = this.options,\n            b = e.threshold,\n            l = y(e.startFromThreshold && b, 0),\n            c = e.stack,\n            e = e.stacking,\n            t = this.stackKey,\n            F = \"-\" + t,\n            w = this.negStacks,\n            B = this.yAxis,\n            p = B.stacks,\n            d = B.oldStacks,\n            k,\n            u,\n            D,\n            G,\n            q,\n            v,\n            x;\n        B.stacksTouched += 1;\n\n        for (q = 0; q < r; q++) v = g[q], x = f[q], k = this.getStackIndicator(k, v, this.index), G = k.key, D = (u = w && x < (l ? 0 : b)) ? F : t, p[D] || (p[D] = {}), p[D][v] || (d[D] && d[D][v] ? (p[D][v] = d[D][v], p[D][v].total = null) : p[D][v] = new a.StackItem(B, B.options.stackLabels, u, v, c)), D = p[D][v], null !== x ? (D.points[G] = D.points[this.index] = [y(D.cumulative, l)], m(D.cumulative) || (D.base = G), D.touched = B.stacksTouched, 0 < k.index && !1 === this.singleStacks && (D.points[G][0] = D.points[this.index + \",\" + v + \",0\"][0])) : D.points[G] = D.points[this.index] = null, \"percent\" === e ? (u = u ? t : F, w && p[u] && p[u][v] ? (u = p[u][v], D.total = u.total = Math.max(u.total, D.total) + Math.abs(x) || 0) : D.total = E(D.total + (Math.abs(x) || 0))) : D.total = E(D.total + (x || 0)), D.cumulative = y(D.cumulative, l) + (x || 0), null !== x && (D.points[G].push(D.cumulative), h[q] = D.cumulative);\n\n        \"percent\" === e && (B.usePercentage = !0);\n        this.stackedYData = h;\n        B.oldStacks = {};\n      }\n    };\n\n    z.prototype.modifyStacks = function () {\n      var a = this,\n          f = a.stackKey,\n          h = a.yAxis.stacks,\n          g = a.processedXData,\n          e,\n          b = a.options.stacking;\n      a[b + \"Stacker\"] && [f, \"-\" + f].forEach(function (f) {\n        for (var c = g.length, l, r; c--;) if (l = g[c], e = a.getStackIndicator(e, l, a.index, f), r = (l = h[f] && h[f][l]) && l.points[e.key]) a[b + \"Stacker\"](r, l, c);\n      });\n    };\n\n    z.prototype.percentStacker = function (a, f, h) {\n      f = f.total ? 100 / f.total : 0;\n      a[0] = E(a[0] * f);\n      a[1] = E(a[1] * f);\n      this.stackedYData[h] = a[1];\n    };\n\n    z.prototype.getStackIndicator = function (a, f, h, g) {\n      !m(a) || a.x !== f || g && a.key !== g ? a = {\n        x: f,\n        index: 0,\n        key: g\n      } : a.index++;\n      a.key = [h, f, a.index].join();\n      return a;\n    };\n  });\n  I(H, \"parts/Dynamics.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.addEvent,\n        A = a.animate,\n        E = a.Axis,\n        m = a.Chart,\n        g = a.createElement,\n        v = a.css,\n        x = a.defined,\n        y = a.erase,\n        z = a.extend,\n        n = a.fireEvent,\n        f = a.isNumber,\n        h = a.isObject,\n        r = a.isArray,\n        e = a.merge,\n        b = a.objectEach,\n        l = a.pick,\n        c = a.Point,\n        t = a.Series,\n        F = a.seriesTypes,\n        w = a.setAnimation,\n        B = a.splat;\n\n    a.cleanRecursively = function (c, d) {\n      var e = {};\n      b(c, function (b, k) {\n        if (h(c[k], !0) && !c.nodeType && d[k]) b = a.cleanRecursively(c[k], d[k]), Object.keys(b).length && (e[k] = b);else if (h(c[k]) || c[k] !== d[k]) e[k] = c[k];\n      });\n      return e;\n    };\n\n    z(m.prototype, {\n      addSeries: function (a, b, c) {\n        var d,\n            e = this;\n        a && (b = l(b, !0), n(e, \"addSeries\", {\n          options: a\n        }, function () {\n          d = e.initSeries(a);\n          e.isDirtyLegend = !0;\n          e.linkSeries();\n          n(e, \"afterAddSeries\", {\n            series: d\n          });\n          b && e.redraw(c);\n        }));\n        return d;\n      },\n      addAxis: function (a, b, c, f) {\n        var d = b ? \"xAxis\" : \"yAxis\",\n            k = this.options;\n        a = e(a, {\n          index: this[d].length,\n          isX: b\n        });\n        b = new E(this, a);\n        k[d] = B(k[d] || {});\n        k[d].push(a);\n        l(c, !0) && this.redraw(f);\n        return b;\n      },\n      showLoading: function (a) {\n        var b = this,\n            c = b.options,\n            e = b.loadingDiv,\n            f = c.loading,\n            p = function () {\n          e && v(e, {\n            left: b.plotLeft + \"px\",\n            top: b.plotTop + \"px\",\n            width: b.plotWidth + \"px\",\n            height: b.plotHeight + \"px\"\n          });\n        };\n\n        e || (b.loadingDiv = e = g(\"div\", {\n          className: \"highcharts-loading highcharts-loading-hidden\"\n        }, null, b.container), b.loadingSpan = g(\"span\", {\n          className: \"highcharts-loading-inner\"\n        }, null, e), C(b, \"redraw\", p));\n        e.className = \"highcharts-loading\";\n        b.loadingSpan.innerHTML = a || c.lang.loading;\n        b.styledMode || (v(e, z(f.style, {\n          zIndex: 10\n        })), v(b.loadingSpan, f.labelStyle), b.loadingShown || (v(e, {\n          opacity: 0,\n          display: \"\"\n        }), A(e, {\n          opacity: f.style.opacity || .5\n        }, {\n          duration: f.showDuration || 0\n        })));\n        b.loadingShown = !0;\n        p();\n      },\n      hideLoading: function () {\n        var a = this.options,\n            b = this.loadingDiv;\n        b && (b.className = \"highcharts-loading highcharts-loading-hidden\", this.styledMode || A(b, {\n          opacity: 0\n        }, {\n          duration: a.loading.hideDuration || 100,\n          complete: function () {\n            v(b, {\n              display: \"none\"\n            });\n          }\n        }));\n        this.loadingShown = !1;\n      },\n      propsRequireDirtyBox: \"backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow\".split(\" \"),\n      propsRequireReflow: \"margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft\".split(\" \"),\n      propsRequireUpdateSeries: \"chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip\".split(\" \"),\n      collectionsWithUpdate: \"xAxis yAxis zAxis series colorAxis pane\".split(\" \"),\n      update: function (c, d, k, h) {\n        var p = this,\n            g = {\n          credits: \"addCredits\",\n          title: \"setTitle\",\n          subtitle: \"setSubtitle\"\n        },\n            q,\n            u,\n            t,\n            r,\n            w = [];\n        n(p, \"update\", {\n          options: c\n        });\n        c.isResponsiveOptions || p.setResponsive(!1, !0);\n        c = a.cleanRecursively(c, p.options);\n        e(!0, p.userOptions, c);\n\n        if (q = c.chart) {\n          e(!0, p.options.chart, q);\n          \"className\" in q && p.setClassName(q.className);\n          \"reflow\" in q && p.setReflow(q.reflow);\n          if (\"inverted\" in q || \"polar\" in q || \"type\" in q) p.propFromSeries(), u = !0;\n          \"alignTicks\" in q && (u = !0);\n          b(q, function (a, b) {\n            -1 !== p.propsRequireUpdateSeries.indexOf(\"chart.\" + b) && (t = !0);\n            -1 !== p.propsRequireDirtyBox.indexOf(b) && (p.isDirtyBox = !0);\n            -1 !== p.propsRequireReflow.indexOf(b) && (r = !0);\n          });\n          !p.styledMode && \"style\" in q && p.renderer.setStyle(q.style);\n        }\n\n        !p.styledMode && c.colors && (this.options.colors = c.colors);\n        c.plotOptions && e(!0, this.options.plotOptions, c.plotOptions);\n        c.time && this.time === a.time && (this.time = new a.Time(c.time));\n        b(c, function (a, b) {\n          if (p[b] && \"function\" === typeof p[b].update) p[b].update(a, !1);else if (\"function\" === typeof p[g[b]]) p[g[b]](a);\n          \"chart\" !== b && -1 !== p.propsRequireUpdateSeries.indexOf(b) && (t = !0);\n        });\n        this.collectionsWithUpdate.forEach(function (a) {\n          var b;\n          c[a] && (\"series\" === a && (b = [], p[a].forEach(function (a, d) {\n            a.options.isInternal || b.push(l(a.options.index, d));\n          })), B(c[a]).forEach(function (d, c) {\n            (c = x(d.id) && p.get(d.id) || p[a][b ? b[c] : c]) && c.coll === a && (c.update(d, !1), k && (c.touched = !0));\n            !c && k && p.collectionsWithInit[a] && (p.collectionsWithInit[a][0].apply(p, [d].concat(p.collectionsWithInit[a][1] || []).concat([!1])).touched = !0);\n          }), k && p[a].forEach(function (a) {\n            a.touched || a.options.isInternal ? delete a.touched : w.push(a);\n          }));\n        });\n        w.forEach(function (a) {\n          a.remove && a.remove(!1);\n        });\n        u && p.axes.forEach(function (a) {\n          a.update({}, !1);\n        });\n        t && p.series.forEach(function (a) {\n          a.update({}, !1);\n        });\n        c.loading && e(!0, p.options.loading, c.loading);\n        u = q && q.width;\n        q = q && q.height;\n        a.isString(q) && (q = a.relativeLength(q, u || p.chartWidth));\n        r || f(u) && u !== p.chartWidth || f(q) && q !== p.chartHeight ? p.setSize(u, q, h) : l(d, !0) && p.redraw(h);\n        n(p, \"afterUpdate\", {\n          options: c,\n          redraw: d,\n          animation: h\n        });\n      },\n      setSubtitle: function (a) {\n        this.setTitle(void 0, a);\n      }\n    });\n    m.prototype.collectionsWithInit = {\n      xAxis: [m.prototype.addAxis, [!0]],\n      yAxis: [m.prototype.addAxis, [!1]],\n      series: [m.prototype.addSeries]\n    };\n    z(c.prototype, {\n      update: function (a, b, c, e) {\n        function d() {\n          k.applyOptions(a);\n          null === k.y && p && (k.graphic = p.destroy());\n          h(a, !0) && (p && p.element && a && a.marker && void 0 !== a.marker.symbol && (k.graphic = p.destroy()), a && a.dataLabels && k.dataLabel && (k.dataLabel = k.dataLabel.destroy()), k.connector && (k.connector = k.connector.destroy()));\n          g = k.index;\n          f.updateParallelArrays(k, g);\n          t.data[g] = h(t.data[g], !0) || h(a, !0) ? k.options : l(a, t.data[g]);\n          f.isDirty = f.isDirtyData = !0;\n          !f.fixedBox && f.hasCartesianSeries && (u.isDirtyBox = !0);\n          \"point\" === t.legendType && (u.isDirtyLegend = !0);\n          b && u.redraw(c);\n        }\n\n        var k = this,\n            f = k.series,\n            p = k.graphic,\n            g,\n            u = f.chart,\n            t = f.options;\n        b = l(b, !0);\n        !1 === e ? d() : k.firePointEvent(\"update\", {\n          options: a\n        }, d);\n      },\n      remove: function (a, b) {\n        this.series.removePoint(this.series.data.indexOf(this), a, b);\n      }\n    });\n    z(t.prototype, {\n      addPoint: function (a, b, c, e, f) {\n        var d = this.options,\n            k = this.data,\n            p = this.chart,\n            h = this.xAxis,\n            h = h && h.hasNames && h.names,\n            g = d.data,\n            u,\n            t = this.xData,\n            r,\n            w,\n            m;\n        b = l(b, !0);\n        u = {\n          series: this\n        };\n        this.pointClass.prototype.applyOptions.apply(u, [a]);\n        m = u.x;\n        w = t.length;\n        if (this.requireSorting && m < t[w - 1]) for (r = !0; w && t[w - 1] > m;) w--;\n        this.updateParallelArrays(u, \"splice\", w, 0, 0);\n        this.updateParallelArrays(u, w);\n        h && u.name && (h[m] = u.name);\n        g.splice(w, 0, a);\n        r && (this.data.splice(w, 0, null), this.processData());\n        \"point\" === d.legendType && this.generatePoints();\n        c && (k[0] && k[0].remove ? k[0].remove(!1) : (k.shift(), this.updateParallelArrays(u, \"shift\"), g.shift()));\n        !1 !== f && n(this, \"addPoint\", {\n          point: u\n        });\n        this.isDirtyData = this.isDirty = !0;\n        b && p.redraw(e);\n      },\n      removePoint: function (a, b, c) {\n        var d = this,\n            e = d.data,\n            k = e[a],\n            f = d.points,\n            p = d.chart,\n            h = function () {\n          f && f.length === e.length && f.splice(a, 1);\n          e.splice(a, 1);\n          d.options.data.splice(a, 1);\n          d.updateParallelArrays(k || {\n            series: d\n          }, \"splice\", a, 1);\n          k && k.destroy();\n          d.isDirty = !0;\n          d.isDirtyData = !0;\n          b && p.redraw();\n        };\n\n        w(c, p);\n        b = l(b, !0);\n        k ? k.firePointEvent(\"remove\", null, h) : h();\n      },\n      remove: function (a, b, c, e) {\n        function d() {\n          k.destroy(e);\n          k.remove = null;\n          f.isDirtyLegend = f.isDirtyBox = !0;\n          f.linkSeries();\n          l(a, !0) && f.redraw(b);\n        }\n\n        var k = this,\n            f = k.chart;\n        !1 !== c ? n(k, \"remove\", null, d) : d();\n      },\n      update: function (b, d) {\n        b = a.cleanRecursively(b, this.userOptions);\n        n(this, \"update\", {\n          options: b\n        });\n        var c = this,\n            f = c.chart,\n            h = c.userOptions,\n            p,\n            g = c.initialType || c.type,\n            t = b.type || h.type || f.options.chart.type,\n            r = !(this.hasDerivedData || b.dataGrouping || t && t !== this.type || void 0 !== b.pointStart || b.pointInterval || b.pointIntervalUnit || b.keys),\n            w = F[g].prototype,\n            m,\n            B = [\"group\", \"markerGroup\", \"dataLabelsGroup\", \"transformGroup\"],\n            v = [\"navigatorSeries\", \"baseSeries\"],\n            x = c.finishedAnimating && {\n          animation: !1\n        },\n            y = {};\n        r && (v.push(\"data\", \"isDirtyData\", \"points\", \"processedXData\", \"processedYData\", \"xIncrement\", \"_hasPointMarkers\", \"_hasPointLabels\", \"mapMap\", \"mapData\", \"minY\", \"maxY\", \"minX\", \"maxX\"), !1 !== b.visible && v.push(\"area\", \"graph\"), c.parallelArrays.forEach(function (a) {\n          v.push(a + \"Data\");\n        }), b.data && this.setData(b.data, !1));\n        b = e(h, x, {\n          index: void 0 === h.index ? c.index : h.index,\n          pointStart: l(h.pointStart, c.xData[0])\n        }, !r && {\n          data: c.options.data\n        }, b);\n        v = B.concat(v);\n        v.forEach(function (a) {\n          v[a] = c[a];\n          delete c[a];\n        });\n        c.remove(!1, null, !1, !0);\n\n        for (m in w) c[m] = void 0;\n\n        F[t || g] ? z(c, F[t || g].prototype) : a.error(17, !0, f);\n        v.forEach(function (a) {\n          c[a] = v[a];\n        });\n        c.init(f, b);\n        r && this.points && (p = c.options, !1 === p.visible ? (y.graphic = 1, y.dataLabel = 1) : (p.marker && !1 === p.marker.enabled && !c._hasPointMarkers && (y.graphic = 1), p.dataLabels && !1 === p.dataLabels.enabled && !c._hasPointLabels && (y.dataLabel = 1)), this.points.forEach(function (a) {\n          a && a.series && (a.resolveColor(), Object.keys(y).length && a.destroyElements(y), !1 === p.showInLegend && a.legendItem && f.legend.destroyItem(a));\n        }, this));\n        b.zIndex !== h.zIndex && B.forEach(function (a) {\n          c[a] && c[a].attr({\n            zIndex: b.zIndex\n          });\n        });\n        c.initialType = g;\n        f.linkSeries();\n        n(this, \"afterUpdate\");\n        l(d, !0) && f.redraw(r ? void 0 : !1);\n      },\n      setName: function (a) {\n        this.name = this.options.name = this.userOptions.name = a;\n        this.chart.isDirtyLegend = !0;\n      }\n    });\n    z(E.prototype, {\n      update: function (a, d) {\n        var c = this.chart,\n            f = a && a.events || {};\n        a = e(this.userOptions, a);\n        c.options[this.coll].indexOf && (c.options[this.coll][c.options[this.coll].indexOf(this.userOptions)] = a);\n        b(c.options[this.coll].events, function (a, b) {\n          \"undefined\" === typeof f[b] && (f[b] = void 0);\n        });\n        this.destroy(!0);\n        this.init(c, z(a, {\n          events: f\n        }));\n        c.isDirtyBox = !0;\n        l(d, !0) && c.redraw();\n      },\n      remove: function (a) {\n        for (var b = this.chart, c = this.coll, e = this.series, f = e.length; f--;) e[f] && e[f].remove(!1);\n\n        y(b.axes, this);\n        y(b[c], this);\n        r(b.options[c]) ? b.options[c].splice(this.options.index, 1) : delete b.options[c];\n        b[c].forEach(function (a, b) {\n          a.options.index = a.userOptions.index = b;\n        });\n        this.destroy();\n        b.isDirtyBox = !0;\n        l(a, !0) && b.redraw();\n      },\n      setTitle: function (a, b) {\n        this.update({\n          title: a\n        }, b);\n      },\n      setCategories: function (a, b) {\n        this.update({\n          categories: a\n        }, b);\n      }\n    });\n  });\n  I(H, \"parts/AreaSeries.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.color,\n        A = a.pick,\n        E = a.Series,\n        m = a.seriesType;\n    m(\"area\", \"line\", {\n      softThreshold: !1,\n      threshold: 0\n    }, {\n      singleStacks: !1,\n      getStackPoints: function (g) {\n        var m = [],\n            x = [],\n            y = this.xAxis,\n            z = this.yAxis,\n            n = z.stacks[this.stackKey],\n            f = {},\n            h = this.index,\n            r = z.series,\n            e = r.length,\n            b,\n            l = A(z.options.reversedStacks, !0) ? 1 : -1,\n            c;\n        g = g || this.points;\n\n        if (this.options.stacking) {\n          for (c = 0; c < g.length; c++) g[c].leftNull = g[c].rightNull = null, f[g[c].x] = g[c];\n\n          a.objectEach(n, function (a, b) {\n            null !== a.total && x.push(b);\n          });\n          x.sort(function (a, b) {\n            return a - b;\n          });\n          b = r.map(function (a) {\n            return a.visible;\n          });\n          x.forEach(function (a, g) {\n            var t = 0,\n                r,\n                p;\n            if (f[a] && !f[a].isNull) m.push(f[a]), [-1, 1].forEach(function (d) {\n              var k = 1 === d ? \"rightNull\" : \"leftNull\",\n                  t = 0,\n                  w = n[x[g + d]];\n              if (w) for (c = h; 0 <= c && c < e;) r = w.points[c], r || (c === h ? f[a][k] = !0 : b[c] && (p = n[a].points[c]) && (t -= p[1] - p[0])), c += l;\n              f[a][1 === d ? \"rightCliff\" : \"leftCliff\"] = t;\n            });else {\n              for (c = h; 0 <= c && c < e;) {\n                if (r = n[a].points[c]) {\n                  t = r[1];\n                  break;\n                }\n\n                c += l;\n              }\n\n              t = z.translate(t, 0, 1, 0, 1);\n              m.push({\n                isNull: !0,\n                plotX: y.translate(a, 0, 0, 0, 1),\n                x: a,\n                plotY: t,\n                yBottom: t\n              });\n            }\n          });\n        }\n\n        return m;\n      },\n      getGraphPath: function (g) {\n        var m = E.prototype.getGraphPath,\n            x = this.options,\n            y = x.stacking,\n            z = this.yAxis,\n            n,\n            f,\n            h = [],\n            r = [],\n            e = this.index,\n            b,\n            l = z.stacks[this.stackKey],\n            c = x.threshold,\n            t = z.getThreshold(x.threshold),\n            F,\n            x = a.pick(x.connectNulls, \"percent\" === y),\n            w = function (a, f, d) {\n          var k = g[a];\n          a = y && l[k.x].points[e];\n          var p = k[d + \"Null\"] || 0;\n          d = k[d + \"Cliff\"] || 0;\n          var w,\n              n,\n              k = !0;\n          d || p ? (w = (p ? a[0] : a[1]) + d, n = a[0] + d, k = !!p) : !y && g[f] && g[f].isNull && (w = n = c);\n          void 0 !== w && (r.push({\n            plotX: b,\n            plotY: null === w ? t : z.getThreshold(w),\n            isNull: k,\n            isCliff: !0\n          }), h.push({\n            plotX: b,\n            plotY: null === n ? t : z.getThreshold(n),\n            doCurve: !1\n          }));\n        };\n\n        g = g || this.points;\n        y && (g = this.getStackPoints(g));\n\n        for (n = 0; n < g.length; n++) if (f = g[n].isNull, b = A(g[n].rectPlotX, g[n].plotX), F = A(g[n].yBottom, t), !f || x) x || w(n, n - 1, \"left\"), f && !y && x || (r.push(g[n]), h.push({\n          x: n,\n          plotX: b,\n          plotY: F\n        })), x || w(n, n + 1, \"right\");\n\n        n = m.call(this, r, !0, !0);\n        h.reversed = !0;\n        f = m.call(this, h, !0, !0);\n        f.length && (f[0] = \"L\");\n        f = n.concat(f);\n        m = m.call(this, r, !1, x);\n        f.xMap = n.xMap;\n        this.areaPath = f;\n        return m;\n      },\n      drawGraph: function () {\n        this.areaPath = [];\n        E.prototype.drawGraph.apply(this);\n        var a = this,\n            m = this.areaPath,\n            x = this.options,\n            y = [[\"area\", \"highcharts-area\", this.color, x.fillColor]];\n        this.zones.forEach(function (g, n) {\n          y.push([\"zone-area-\" + n, \"highcharts-area highcharts-zone-area-\" + n + \" \" + g.className, g.color || a.color, g.fillColor || x.fillColor]);\n        });\n        y.forEach(function (g) {\n          var n = g[0],\n              f = a[n],\n              h = f ? \"animate\" : \"attr\",\n              r = {};\n          f ? (f.endX = a.preventGraphAnimation ? null : m.xMap, f.animate({\n            d: m\n          })) : (r.zIndex = 0, f = a[n] = a.chart.renderer.path(m).addClass(g[1]).add(a.group), f.isArea = !0);\n          a.chart.styledMode || (r.fill = A(g[3], C(g[2]).setOpacity(A(x.fillOpacity, .75)).get()));\n          f[h](r);\n          f.startX = m.xMap;\n          f.shiftUnit = x.step ? 2 : 1;\n        });\n      },\n      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle\n    });\n  });\n  I(H, \"parts/SplineSeries.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.pick;\n    a = a.seriesType;\n    a(\"spline\", \"line\", {}, {\n      getPointSpline: function (a, E, m) {\n        var g = E.plotX,\n            v = E.plotY,\n            x = a[m - 1];\n        m = a[m + 1];\n        var y, z, n, f;\n\n        if (x && !x.isNull && !1 !== x.doCurve && !E.isCliff && m && !m.isNull && !1 !== m.doCurve && !E.isCliff) {\n          a = x.plotY;\n          n = m.plotX;\n          m = m.plotY;\n          var h = 0;\n          y = (1.5 * g + x.plotX) / 2.5;\n          z = (1.5 * v + a) / 2.5;\n          n = (1.5 * g + n) / 2.5;\n          f = (1.5 * v + m) / 2.5;\n          n !== y && (h = (f - z) * (n - g) / (n - y) + v - f);\n          z += h;\n          f += h;\n          z > a && z > v ? (z = Math.max(a, v), f = 2 * v - z) : z < a && z < v && (z = Math.min(a, v), f = 2 * v - z);\n          f > m && f > v ? (f = Math.max(m, v), z = 2 * v - f) : f < m && f < v && (f = Math.min(m, v), z = 2 * v - f);\n          E.rightContX = n;\n          E.rightContY = f;\n        }\n\n        E = [\"C\", C(x.rightContX, x.plotX), C(x.rightContY, x.plotY), C(y, g), C(z, v), g, v];\n        x.rightContX = x.rightContY = null;\n        return E;\n      }\n    });\n  });\n  I(H, \"parts/AreaSplineSeries.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.seriesTypes.area.prototype,\n        A = a.seriesType;\n    A(\"areaspline\", \"spline\", a.defaultPlotOptions.area, {\n      getStackPoints: C.getStackPoints,\n      getGraphPath: C.getGraphPath,\n      drawGraph: C.drawGraph,\n      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle\n    });\n  });\n  I(H, \"parts/ColumnSeries.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.animObject,\n        A = a.color,\n        E = a.extend,\n        m = a.defined,\n        g = a.isNumber,\n        v = a.merge,\n        x = a.pick,\n        y = a.Series,\n        z = a.seriesType,\n        n = a.svg;\n    z(\"column\", \"line\", {\n      borderRadius: 0,\n      crisp: !0,\n      groupPadding: .2,\n      marker: null,\n      pointPadding: .1,\n      minPointLength: 0,\n      cropThreshold: 50,\n      pointRange: null,\n      states: {\n        hover: {\n          halo: !1,\n          brightness: .1\n        },\n        select: {\n          color: \"#cccccc\",\n          borderColor: \"#000000\"\n        }\n      },\n      dataLabels: {\n        align: null,\n        verticalAlign: null,\n        y: null\n      },\n      softThreshold: !1,\n      startFromThreshold: !0,\n      stickyTracking: !1,\n      tooltip: {\n        distance: 6\n      },\n      threshold: 0,\n      borderColor: \"#ffffff\"\n    }, {\n      cropShoulder: 0,\n      directTouch: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      negStacks: !0,\n      init: function () {\n        y.prototype.init.apply(this, arguments);\n        var a = this,\n            h = a.chart;\n        h.hasRendered && h.series.forEach(function (f) {\n          f.type === a.type && (f.isDirty = !0);\n        });\n      },\n      getColumnMetrics: function () {\n        var a = this,\n            h = a.options,\n            g = a.xAxis,\n            e = a.yAxis,\n            b = g.options.reversedStacks,\n            b = g.reversed && !b || !g.reversed && b,\n            l,\n            c = {},\n            t = 0;\n        !1 === h.grouping ? t = 1 : a.chart.series.forEach(function (b) {\n          var d = b.options,\n              k = b.yAxis,\n              f;\n          b.type !== a.type || !b.visible && a.chart.options.chart.ignoreHiddenSeries || e.len !== k.len || e.pos !== k.pos || (d.stacking ? (l = b.stackKey, void 0 === c[l] && (c[l] = t++), f = c[l]) : !1 !== d.grouping && (f = t++), b.columnIndex = f);\n        });\n        var n = Math.min(Math.abs(g.transA) * (g.ordinalSlope || h.pointRange || g.closestPointRange || g.tickInterval || 1), g.len),\n            w = n * h.groupPadding,\n            m = (n - 2 * w) / (t || 1),\n            h = Math.min(h.maxPointWidth || g.len, x(h.pointWidth, m * (1 - 2 * h.pointPadding)));\n        a.columnMetrics = {\n          width: h,\n          offset: (m - h) / 2 + (w + ((a.columnIndex || 0) + (b ? 1 : 0)) * m - n / 2) * (b ? -1 : 1)\n        };\n        return a.columnMetrics;\n      },\n      crispCol: function (a, h, g, e) {\n        var b = this.chart,\n            f = this.borderWidth,\n            c = -(f % 2 ? .5 : 0),\n            f = f % 2 ? .5 : 1;\n        b.inverted && b.renderer.isVML && (f += 1);\n        this.options.crisp && (g = Math.round(a + g) + c, a = Math.round(a) + c, g -= a);\n        e = Math.round(h + e) + f;\n        c = .5 >= Math.abs(h) && .5 < e;\n        h = Math.round(h) + f;\n        e -= h;\n        c && e && (--h, e += 1);\n        return {\n          x: a,\n          y: h,\n          width: g,\n          height: e\n        };\n      },\n      translate: function () {\n        var a = this,\n            h = a.chart,\n            g = a.options,\n            e = a.dense = 2 > a.closestPointRange * a.xAxis.transA,\n            e = a.borderWidth = x(g.borderWidth, e ? 0 : 1),\n            b = a.yAxis,\n            l = g.threshold,\n            c = a.translatedThreshold = b.getThreshold(l),\n            t = x(g.minPointLength, 5),\n            n = a.getColumnMetrics(),\n            w = n.width,\n            B = a.barW = Math.max(w, 1 + 2 * e),\n            p = a.pointXOffset = n.offset,\n            d = a.dataMin,\n            k = a.dataMax;\n        h.inverted && (c -= .5);\n        g.pointPadding && (B = Math.ceil(B));\n        y.prototype.translate.apply(a);\n        a.points.forEach(function (e) {\n          var f = x(e.yBottom, c),\n              g = 999 + Math.abs(f),\n              q = w,\n              g = Math.min(Math.max(-g, e.plotY), b.len + g),\n              u = e.plotX + p,\n              r = B,\n              n = Math.min(g, f),\n              v,\n              F = Math.max(g, f) - n;\n          t && Math.abs(F) < t && (F = t, v = !b.reversed && !e.negative || b.reversed && e.negative, e.y === l && a.dataMax <= l && b.min < l && d !== k && (v = !v), n = Math.abs(n - c) > t ? f - t : c - (v ? t : 0));\n          m(e.options.pointWidth) && (q = r = Math.ceil(e.options.pointWidth), u -= Math.round((q - w) / 2));\n          e.barX = u;\n          e.pointWidth = q;\n          e.tooltipPos = h.inverted ? [b.len + b.pos - h.plotLeft - g, a.xAxis.len - u - r / 2, F] : [u + r / 2, g + b.pos - h.plotTop, F];\n          e.shapeType = a.pointClass.prototype.shapeType || \"rect\";\n          e.shapeArgs = a.crispCol.apply(a, e.isNull ? [u, c, r, 0] : [u, n, r, F]);\n        });\n      },\n      getSymbol: a.noop,\n      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,\n      drawGraph: function () {\n        this.group[this.dense ? \"addClass\" : \"removeClass\"](\"highcharts-dense-data\");\n      },\n      pointAttribs: function (a, h) {\n        var f = this.options,\n            e,\n            b = this.pointAttrToOptions || {};\n        e = b.stroke || \"borderColor\";\n        var g = b[\"stroke-width\"] || \"borderWidth\",\n            c = a && a.color || this.color,\n            t = a && a[e] || f[e] || this.color || c,\n            n = a && a[g] || f[g] || this[g] || 0,\n            b = a && a.dashStyle || f.dashStyle,\n            w = x(f.opacity, 1),\n            m;\n        a && this.zones.length && (m = a.getZone(), c = a.options.color || m && m.color || this.color, m && (t = m.borderColor || t, b = m.dashStyle || b, n = m.borderWidth || n));\n        h && (a = v(f.states[h], a.options.states && a.options.states[h] || {}), h = a.brightness, c = a.color || void 0 !== h && A(c).brighten(a.brightness).get() || c, t = a[e] || t, n = a[g] || n, b = a.dashStyle || b, w = x(a.opacity, w));\n        e = {\n          fill: c,\n          stroke: t,\n          \"stroke-width\": n,\n          opacity: w\n        };\n        b && (e.dashstyle = b);\n        return e;\n      },\n      drawPoints: function () {\n        var a = this,\n            h = this.chart,\n            r = a.options,\n            e = h.renderer,\n            b = r.animationLimit || 250,\n            l;\n        a.points.forEach(function (c) {\n          var f = c.graphic,\n              n = f && h.pointCount < b ? \"animate\" : \"attr\";\n\n          if (g(c.plotY) && null !== c.y) {\n            l = c.shapeArgs;\n            f && f.element.nodeName !== c.shapeType && (f = f.destroy());\n            if (f) f[n](v(l));else c.graphic = f = e[c.shapeType](l).add(c.group || a.group);\n            if (r.borderRadius) f[n]({\n              r: r.borderRadius\n            });\n            h.styledMode || f[n](a.pointAttribs(c, c.selected && \"select\")).shadow(!1 !== c.allowShadow && r.shadow, null, r.stacking && !r.borderRadius);\n            f.addClass(c.getClassName(), !0);\n          } else f && (c.graphic = f.destroy());\n        });\n      },\n      animate: function (a) {\n        var f = this,\n            g = this.yAxis,\n            e = f.options,\n            b = this.chart.inverted,\n            l = {},\n            c = b ? \"translateX\" : \"translateY\",\n            t;\n        n && (a ? (l.scaleY = .001, a = Math.min(g.pos + g.len, Math.max(g.pos, g.toPixels(e.threshold))), b ? l.translateX = a - g.len : l.translateY = a, f.clipBox && f.setClip(), f.group.attr(l)) : (t = f.group.attr(c), f.group.animate({\n          scaleY: 1\n        }, E(C(f.options.animation), {\n          step: function (a, b) {\n            l[c] = t + b.pos * (g.pos - t);\n            f.group.attr(l);\n          }\n        })), f.animate = null));\n      },\n      remove: function () {\n        var a = this,\n            h = a.chart;\n        h.hasRendered && h.series.forEach(function (f) {\n          f.type === a.type && (f.isDirty = !0);\n        });\n        y.prototype.remove.apply(a, arguments);\n      }\n    });\n  });\n  I(H, \"parts/BarSeries.js\", [H[\"parts/Globals.js\"]], function (a) {\n    a = a.seriesType;\n    a(\"bar\", \"column\", null, {\n      inverted: !0\n    });\n  });\n  I(H, \"parts/ScatterSeries.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.Series,\n        A = a.seriesType;\n    A(\"scatter\", \"line\", {\n      lineWidth: 0,\n      findNearestPointBy: \"xy\",\n      jitter: {\n        x: 0,\n        y: 0\n      },\n      marker: {\n        enabled: !0\n      },\n      tooltip: {\n        headerFormat: '\\x3cspan style\\x3d\"color:{point.color}\"\\x3e\\u25cf\\x3c/span\\x3e \\x3cspan style\\x3d\"font-size: 10px\"\\x3e {series.name}\\x3c/span\\x3e\\x3cbr/\\x3e',\n        pointFormat: \"x: \\x3cb\\x3e{point.x}\\x3c/b\\x3e\\x3cbr/\\x3ey: \\x3cb\\x3e{point.y}\\x3c/b\\x3e\\x3cbr/\\x3e\"\n      }\n    }, {\n      sorted: !1,\n      requireSorting: !1,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n      takeOrdinalPosition: !1,\n      drawGraph: function () {\n        this.options.lineWidth && C.prototype.drawGraph.call(this);\n      },\n      applyJitter: function () {\n        var a = this,\n            m = this.options.jitter,\n            g = this.points.length;\n        m && this.points.forEach(function (v, x) {\n          [\"x\", \"y\"].forEach(function (y, z) {\n            var n,\n                f = \"plot\" + y.toUpperCase(),\n                h,\n                r;\n            m[y] && !v.isNull && (n = a[y + \"Axis\"], r = m[y] * n.transA, n && !n.isLog && (h = Math.max(0, v[f] - r), n = Math.min(n.len, v[f] + r), z = 1E4 * Math.sin(x + z * g), v[f] = h + (n - h) * (z - Math.floor(z)), \"x\" === y && (v.clientX = v.plotX)));\n          });\n        });\n      }\n    });\n    a.addEvent(C, \"afterTranslate\", function () {\n      this.applyJitter && this.applyJitter();\n    });\n  });\n  I(H, \"mixins/centered-series.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.deg2rad,\n        A = a.isNumber,\n        E = a.pick,\n        m = a.relativeLength;\n    a.CenteredSeriesMixin = {\n      getCenter: function () {\n        var a = this.options,\n            v = this.chart,\n            x = 2 * (a.slicedOffset || 0),\n            y = v.plotWidth - 2 * x,\n            v = v.plotHeight - 2 * x,\n            z = a.center,\n            z = [E(z[0], \"50%\"), E(z[1], \"50%\"), a.size || \"100%\", a.innerSize || 0],\n            n = Math.min(y, v),\n            f,\n            h;\n\n        for (f = 0; 4 > f; ++f) h = z[f], a = 2 > f || 2 === f && /%$/.test(h), z[f] = m(h, [y, v, n, z[2]][f]) + (a ? x : 0);\n\n        z[3] > z[2] && (z[3] = z[2]);\n        return z;\n      },\n      getStartAndEndRadians: function (a, m) {\n        a = A(a) ? a : 0;\n        m = A(m) && m > a && 360 > m - a ? m : a + 360;\n        return {\n          start: C * (a + -90),\n          end: C * (m + -90)\n        };\n      }\n    };\n  });\n  I(H, \"parts/PieSeries.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.addEvent,\n        A = a.CenteredSeriesMixin,\n        E = a.defined,\n        m = A.getStartAndEndRadians,\n        g = a.merge,\n        v = a.noop,\n        x = a.pick,\n        y = a.Point,\n        z = a.Series,\n        n = a.seriesType,\n        f = a.setAnimation;\n    n(\"pie\", \"line\", {\n      center: [null, null],\n      clip: !1,\n      colorByPoint: !0,\n      dataLabels: {\n        allowOverlap: !0,\n        connectorPadding: 5,\n        distance: 30,\n        enabled: !0,\n        formatter: function () {\n          return this.point.isNull ? void 0 : this.point.name;\n        },\n        softConnector: !0,\n        x: 0,\n        connectorShape: \"fixedOffset\",\n        crookDistance: \"70%\"\n      },\n      ignoreHiddenPoint: !0,\n      inactiveOtherPoints: !0,\n      legendType: \"point\",\n      marker: null,\n      size: null,\n      showInLegend: !1,\n      slicedOffset: 10,\n      stickyTracking: !1,\n      tooltip: {\n        followPointer: !0\n      },\n      borderColor: \"#ffffff\",\n      borderWidth: 1,\n      states: {\n        hover: {\n          brightness: .1\n        }\n      }\n    }, {\n      isCartesian: !1,\n      requireSorting: !1,\n      directTouch: !0,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      axisTypes: [],\n      pointAttribs: a.seriesTypes.column.prototype.pointAttribs,\n      animate: function (a) {\n        var f = this,\n            e = f.points,\n            b = f.startAngleRad;\n        a || (e.forEach(function (a) {\n          var c = a.graphic,\n              e = a.shapeArgs;\n          c && (c.attr({\n            r: a.startR || f.center[3] / 2,\n            start: b,\n            end: b\n          }), c.animate({\n            r: e.r,\n            start: e.start,\n            end: e.end\n          }, f.options.animation));\n        }), f.animate = null);\n      },\n      hasData: function () {\n        return !!this.processedXData.length;\n      },\n      updateTotals: function () {\n        var a,\n            f = 0,\n            e = this.points,\n            b = e.length,\n            g,\n            c = this.options.ignoreHiddenPoint;\n\n        for (a = 0; a < b; a++) g = e[a], f += c && !g.visible ? 0 : g.isNull ? 0 : g.y;\n\n        this.total = f;\n\n        for (a = 0; a < b; a++) g = e[a], g.percentage = 0 < f && (g.visible || !c) ? g.y / f * 100 : 0, g.total = f;\n      },\n      generatePoints: function () {\n        z.prototype.generatePoints.call(this);\n        this.updateTotals();\n      },\n      getX: function (a, f, e) {\n        var b = this.center,\n            h = this.radii ? this.radii[e.index] : b[2] / 2;\n        return b[0] + (f ? -1 : 1) * Math.cos(Math.asin(Math.max(Math.min((a - b[1]) / (h + e.labelDistance), 1), -1))) * (h + e.labelDistance) + (0 < e.labelDistance ? (f ? -1 : 1) * this.options.dataLabels.padding : 0);\n      },\n      translate: function (f) {\n        this.generatePoints();\n        var g = 0,\n            e = this.options,\n            b = e.slicedOffset,\n            h = b + (e.borderWidth || 0),\n            c,\n            t,\n            n = m(e.startAngle, e.endAngle),\n            w = this.startAngleRad = n.start,\n            n = (this.endAngleRad = n.end) - w,\n            B = this.points,\n            p,\n            d,\n            k = e.dataLabels.distance,\n            e = e.ignoreHiddenPoint,\n            u,\n            D = B.length,\n            v;\n        f || (this.center = f = this.getCenter());\n\n        for (u = 0; u < D; u++) {\n          v = B[u];\n          c = w + g * n;\n          if (!e || v.visible) g += v.percentage / 100;\n          t = w + g * n;\n          v.shapeType = \"arc\";\n          v.shapeArgs = {\n            x: f[0],\n            y: f[1],\n            r: f[2] / 2,\n            innerR: f[3] / 2,\n            start: Math.round(1E3 * c) / 1E3,\n            end: Math.round(1E3 * t) / 1E3\n          };\n          v.labelDistance = x(v.options.dataLabels && v.options.dataLabels.distance, k);\n          v.labelDistance = a.relativeLength(v.labelDistance, v.shapeArgs.r);\n          this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, v.labelDistance);\n          t = (t + c) / 2;\n          t > 1.5 * Math.PI ? t -= 2 * Math.PI : t < -Math.PI / 2 && (t += 2 * Math.PI);\n          v.slicedTranslation = {\n            translateX: Math.round(Math.cos(t) * b),\n            translateY: Math.round(Math.sin(t) * b)\n          };\n          p = Math.cos(t) * f[2] / 2;\n          d = Math.sin(t) * f[2] / 2;\n          v.tooltipPos = [f[0] + .7 * p, f[1] + .7 * d];\n          v.half = t < -Math.PI / 2 || t > Math.PI / 2 ? 1 : 0;\n          v.angle = t;\n          c = Math.min(h, v.labelDistance / 5);\n          v.labelPosition = {\n            natural: {\n              x: f[0] + p + Math.cos(t) * v.labelDistance,\n              y: f[1] + d + Math.sin(t) * v.labelDistance\n            },\n            \"final\": {},\n            alignment: 0 > v.labelDistance ? \"center\" : v.half ? \"right\" : \"left\",\n            connectorPosition: {\n              breakAt: {\n                x: f[0] + p + Math.cos(t) * c,\n                y: f[1] + d + Math.sin(t) * c\n              },\n              touchingSliceAt: {\n                x: f[0] + p,\n                y: f[1] + d\n              }\n            }\n          };\n        }\n      },\n      drawGraph: null,\n      redrawPoints: function () {\n        var a = this,\n            f = a.chart,\n            e = f.renderer,\n            b,\n            l,\n            c,\n            t,\n            n = a.options.shadow;\n        !n || a.shadowGroup || f.styledMode || (a.shadowGroup = e.g(\"shadow\").attr({\n          zIndex: -1\n        }).add(a.group));\n        a.points.forEach(function (h) {\n          var w = {};\n          l = h.graphic;\n\n          if (!h.isNull && l) {\n            t = h.shapeArgs;\n            b = h.getTranslate();\n\n            if (!f.styledMode) {\n              var p = h.shadowGroup;\n              n && !p && (p = h.shadowGroup = e.g(\"shadow\").add(a.shadowGroup));\n              p && p.attr(b);\n              c = a.pointAttribs(h, h.selected && \"select\");\n            }\n\n            h.delayedRendering ? (l.setRadialReference(a.center).attr(t).attr(b), f.styledMode || l.attr(c).attr({\n              \"stroke-linejoin\": \"round\"\n            }).shadow(n, p), h.delayedRendering = !1) : (l.setRadialReference(a.center), f.styledMode || g(!0, w, c), g(!0, w, t, b), l.animate(w));\n            l.attr({\n              visibility: h.visible ? \"inherit\" : \"hidden\"\n            });\n            l.addClass(h.getClassName());\n          } else l && (h.graphic = l.destroy());\n        });\n      },\n      drawPoints: function () {\n        var a = this.chart.renderer;\n        this.points.forEach(function (f) {\n          f.graphic || (f.graphic = a[f.shapeType](f.shapeArgs).add(f.series.group), f.delayedRendering = !0);\n        });\n      },\n      searchPoint: v,\n      sortByAngle: function (a, f) {\n        a.sort(function (a, b) {\n          return void 0 !== a.angle && (b.angle - a.angle) * f;\n        });\n      },\n      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,\n      getCenter: A.getCenter,\n      getSymbol: v\n    }, {\n      init: function () {\n        y.prototype.init.apply(this, arguments);\n        var a = this,\n            f;\n        a.name = x(a.name, \"Slice\");\n\n        f = function (e) {\n          a.slice(\"select\" === e.type);\n        };\n\n        C(a, \"select\", f);\n        C(a, \"unselect\", f);\n        return a;\n      },\n      isValid: function () {\n        return a.isNumber(this.y, !0) && 0 <= this.y;\n      },\n      setVisible: function (a, f) {\n        var e = this,\n            b = e.series,\n            g = b.chart,\n            c = b.options.ignoreHiddenPoint;\n        f = x(f, c);\n        a !== e.visible && (e.visible = e.options.visible = a = void 0 === a ? !e.visible : a, b.options.data[b.data.indexOf(e)] = e.options, [\"graphic\", \"dataLabel\", \"connector\", \"shadowGroup\"].forEach(function (b) {\n          if (e[b]) e[b][a ? \"show\" : \"hide\"](!0);\n        }), e.legendItem && g.legend.colorizeItem(e, a), a || \"hover\" !== e.state || e.setState(\"\"), c && (b.isDirty = !0), f && g.redraw());\n      },\n      slice: function (a, g, e) {\n        var b = this.series;\n        f(e, b.chart);\n        x(g, !0);\n        this.sliced = this.options.sliced = E(a) ? a : !this.sliced;\n        b.options.data[b.data.indexOf(this)] = this.options;\n        this.graphic.animate(this.getTranslate());\n        this.shadowGroup && this.shadowGroup.animate(this.getTranslate());\n      },\n      getTranslate: function () {\n        return this.sliced ? this.slicedTranslation : {\n          translateX: 0,\n          translateY: 0\n        };\n      },\n      haloPath: function (a) {\n        var f = this.shapeArgs;\n        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(f.x, f.y, f.r + a, f.r + a, {\n          innerR: this.shapeArgs.r - 1,\n          start: f.start,\n          end: f.end\n        });\n      },\n      connectorShapes: {\n        fixedOffset: function (a, f, e) {\n          var b = f.breakAt;\n          f = f.touchingSliceAt;\n          return [\"M\", a.x, a.y].concat(e.softConnector ? [\"C\", a.x + (\"left\" === a.alignment ? -5 : 5), a.y, 2 * b.x - f.x, 2 * b.y - f.y, b.x, b.y] : [\"L\", b.x, b.y]).concat([\"L\", f.x, f.y]);\n        },\n        straight: function (a, f) {\n          f = f.touchingSliceAt;\n          return [\"M\", a.x, a.y, \"L\", f.x, f.y];\n        },\n        crookedLine: function (f, g, e) {\n          g = g.touchingSliceAt;\n          var b = this.series,\n              h = b.center[0],\n              c = b.chart.plotWidth,\n              t = b.chart.plotLeft,\n              b = f.alignment,\n              r = this.shapeArgs.r;\n          e = a.relativeLength(e.crookDistance, 1);\n          e = \"left\" === b ? h + r + (c + t - h - r) * (1 - e) : t + (h - r) * e;\n          h = [\"L\", e, f.y];\n          if (\"left\" === b ? e > f.x || e < g.x : e < f.x || e > g.x) h = [];\n          return [\"M\", f.x, f.y].concat(h).concat([\"L\", g.x, g.y]);\n        }\n      },\n      getConnectorPath: function () {\n        var a = this.labelPosition,\n            f = this.series.options.dataLabels,\n            e = f.connectorShape,\n            b = this.connectorShapes;\n        b[e] && (e = b[e]);\n        return e.call(this, {\n          x: a.final.x,\n          y: a.final.y,\n          alignment: a.alignment\n        }, a.connectorPosition, f);\n      }\n    });\n  });\n  I(H, \"parts/DataLabels.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.arrayMax,\n        A = a.defined,\n        E = a.extend,\n        m = a.format,\n        g = a.merge,\n        v = a.noop,\n        x = a.pick,\n        y = a.relativeLength,\n        z = a.Series,\n        n = a.seriesTypes,\n        f = a.stableSort,\n        h = a.isArray,\n        r = a.splat;\n\n    a.distribute = function (e, b, g) {\n      function c(a, b) {\n        return a.target - b.target;\n      }\n\n      var h,\n          l = !0,\n          w = e,\n          r = [],\n          p;\n      p = 0;\n      var d = w.reducedLen || b;\n\n      for (h = e.length; h--;) p += e[h].size;\n\n      if (p > d) {\n        f(e, function (a, b) {\n          return (b.rank || 0) - (a.rank || 0);\n        });\n\n        for (p = h = 0; p <= d;) p += e[h].size, h++;\n\n        r = e.splice(h - 1, e.length);\n      }\n\n      f(e, c);\n\n      for (e = e.map(function (a) {\n        return {\n          size: a.size,\n          targets: [a.target],\n          align: x(a.align, .5)\n        };\n      }); l;) {\n        for (h = e.length; h--;) l = e[h], p = (Math.min.apply(0, l.targets) + Math.max.apply(0, l.targets)) / 2, l.pos = Math.min(Math.max(0, p - l.size * l.align), b - l.size);\n\n        h = e.length;\n\n        for (l = !1; h--;) 0 < h && e[h - 1].pos + e[h - 1].size > e[h].pos && (e[h - 1].size += e[h].size, e[h - 1].targets = e[h - 1].targets.concat(e[h].targets), e[h - 1].align = .5, e[h - 1].pos + e[h - 1].size > b && (e[h - 1].pos = b - e[h - 1].size), e.splice(h, 1), l = !0);\n      }\n\n      w.push.apply(w, r);\n      h = 0;\n      e.some(function (d) {\n        var c = 0;\n        if (d.targets.some(function () {\n          w[h].pos = d.pos + c;\n          if (Math.abs(w[h].pos - w[h].target) > g) return w.slice(0, h + 1).forEach(function (a) {\n            delete a.pos;\n          }), w.reducedLen = (w.reducedLen || b) - .1 * b, w.reducedLen > .1 * b && a.distribute(w, b, g), !0;\n          c += w[h].size;\n          h++;\n        })) return !0;\n      });\n      f(w, c);\n    };\n\n    z.prototype.drawDataLabels = function () {\n      function e(a, b) {\n        var d = b.filter;\n        return d ? (b = d.operator, a = a[d.property], d = d.value, \"\\x3e\" === b && a > d || \"\\x3c\" === b && a < d || \"\\x3e\\x3d\" === b && a >= d || \"\\x3c\\x3d\" === b && a <= d || \"\\x3d\\x3d\" === b && a == d || \"\\x3d\\x3d\\x3d\" === b && a === d ? !0 : !1) : !0;\n      }\n\n      function b(a, b) {\n        var d = [],\n            c;\n        if (h(a) && !h(b)) d = a.map(function (a) {\n          return g(a, b);\n        });else if (h(b) && !h(a)) d = b.map(function (b) {\n          return g(a, b);\n        });else if (h(a) || h(b)) for (c = Math.max(a.length, b.length); c--;) d[c] = g(a[c], b[c]);else d = g(a, b);\n        return d;\n      }\n\n      var f = this,\n          c = f.chart,\n          t = f.options,\n          n = t.dataLabels,\n          w = f.points,\n          v,\n          p = f.hasRendered || 0,\n          d,\n          k = a.animObject(t.animation).duration,\n          u = Math.min(k, 200),\n          D = !c.renderer.forExport && x(n.defer, 0 < u),\n          G = c.renderer,\n          n = b(b(c.options.plotOptions && c.options.plotOptions.series && c.options.plotOptions.series.dataLabels, c.options.plotOptions && c.options.plotOptions[f.type] && c.options.plotOptions[f.type].dataLabels), n);\n      a.fireEvent(this, \"drawDataLabels\");\n      if (h(n) || n.enabled || f._hasPointLabels) d = f.plotGroup(\"dataLabelsGroup\", \"data-labels\", D && !p ? \"hidden\" : \"inherit\", n.zIndex || 6), D && (d.attr({\n        opacity: +p\n      }), p || setTimeout(function () {\n        var a = f.dataLabelsGroup;\n        a && (f.visible && d.show(!0), a[t.animation ? \"animate\" : \"attr\"]({\n          opacity: 1\n        }, {\n          duration: u\n        }));\n      }, k - u)), w.forEach(function (k) {\n        v = r(b(n, k.dlOptions || k.options && k.options.dataLabels));\n        v.forEach(function (b, g) {\n          var p = b.enabled && (!k.isNull || k.dataLabelOnNull) && e(k, b),\n              h,\n              l,\n              u,\n              q,\n              w = k.dataLabels ? k.dataLabels[g] : k.dataLabel,\n              r = k.connectors ? k.connectors[g] : k.connector,\n              n = !w;\n          p && (h = k.getLabelConfig(), l = x(b[k.formatPrefix + \"Format\"], b.format), h = A(l) ? m(l, h, c.time) : (b[k.formatPrefix + \"Formatter\"] || b.formatter).call(h, b), l = b.style, u = b.rotation, c.styledMode || (l.color = x(b.color, l.color, f.color, \"#000000\"), \"contrast\" === l.color && (k.contrastColor = G.getContrast(k.color || f.color), l.color = b.inside || 0 > x(b.distance, k.labelDistance) || t.stacking ? k.contrastColor : \"#000000\"), t.cursor && (l.cursor = t.cursor)), q = {\n            r: b.borderRadius || 0,\n            rotation: u,\n            padding: b.padding,\n            zIndex: 1\n          }, c.styledMode || (q.fill = b.backgroundColor, q.stroke = b.borderColor, q[\"stroke-width\"] = b.borderWidth), a.objectEach(q, function (a, b) {\n            void 0 === a && delete q[b];\n          }));\n          !w || p && A(h) ? p && A(h) && (w ? q.text = h : (k.dataLabels = k.dataLabels || [], w = k.dataLabels[g] = u ? G.text(h, 0, -9999).addClass(\"highcharts-data-label\") : G.label(h, 0, -9999, b.shape, null, null, b.useHTML, null, \"data-label\"), g || (k.dataLabel = w), w.addClass(\" highcharts-data-label-color-\" + k.colorIndex + \" \" + (b.className || \"\") + (b.useHTML ? \" highcharts-tracker\" : \"\"))), w.options = b, w.attr(q), c.styledMode || w.css(l).shadow(b.shadow), w.added || w.add(d), b.textPath && !b.useHTML && w.setTextPath(k.getDataLabelPath && k.getDataLabelPath(w) || k.graphic, b.textPath), f.alignDataLabel(k, w, b, null, n)) : (k.dataLabel = k.dataLabel && k.dataLabel.destroy(), k.dataLabels && (1 === k.dataLabels.length ? delete k.dataLabels : delete k.dataLabels[g]), g || delete k.dataLabel, r && (k.connector = k.connector.destroy(), k.connectors && (1 === k.connectors.length ? delete k.connectors : delete k.connectors[g])));\n        });\n      });\n      a.fireEvent(this, \"afterDrawDataLabels\");\n    };\n\n    z.prototype.alignDataLabel = function (a, b, f, c, g) {\n      var e = this.chart,\n          h = this.isCartesian && e.inverted,\n          l = x(a.dlBox && a.dlBox.centerX, a.plotX, -9999),\n          p = x(a.plotY, -9999),\n          d = b.getBBox(),\n          k,\n          u = f.rotation,\n          t = f.align,\n          r = this.visible && (a.series.forceDL || e.isInsidePlot(l, Math.round(p), h) || c && e.isInsidePlot(l, h ? c.x + 1 : c.y + c.height - 1, h)),\n          q = \"justify\" === x(f.overflow, \"justify\");\n      if (r && (k = e.renderer.fontMetrics(e.styledMode ? void 0 : f.style.fontSize, b).b, c = E({\n        x: h ? this.yAxis.len - p : l,\n        y: Math.round(h ? this.xAxis.len - l : p),\n        width: 0,\n        height: 0\n      }, c), E(f, {\n        width: d.width,\n        height: d.height\n      }), u ? (q = !1, l = e.renderer.rotCorr(k, u), l = {\n        x: c.x + f.x + c.width / 2 + l.x,\n        y: c.y + f.y + {\n          top: 0,\n          middle: .5,\n          bottom: 1\n        }[f.verticalAlign] * c.height\n      }, b[g ? \"attr\" : \"animate\"](l).attr({\n        align: t\n      }), p = (u + 720) % 360, p = 180 < p && 360 > p, \"left\" === t ? l.y -= p ? d.height : 0 : \"center\" === t ? (l.x -= d.width / 2, l.y -= d.height / 2) : \"right\" === t && (l.x -= d.width, l.y -= p ? 0 : d.height), b.placed = !0, b.alignAttr = l) : (b.align(f, null, c), l = b.alignAttr), q && 0 <= c.height ? a.isLabelJustified = this.justifyDataLabel(b, f, l, d, c, g) : x(f.crop, !0) && (r = e.isInsidePlot(l.x, l.y) && e.isInsidePlot(l.x + d.width, l.y + d.height)), f.shape && !u)) b[g ? \"attr\" : \"animate\"]({\n        anchorX: h ? e.plotWidth - a.plotY : a.plotX,\n        anchorY: h ? e.plotHeight - a.plotX : a.plotY\n      });\n      r || (b.attr({\n        y: -9999\n      }), b.placed = !1);\n    };\n\n    z.prototype.justifyDataLabel = function (a, b, f, c, g, h) {\n      var e = this.chart,\n          l = b.align,\n          p = b.verticalAlign,\n          d,\n          k,\n          u = a.box ? 0 : a.padding || 0;\n      d = f.x + u;\n      0 > d && (\"right\" === l ? b.align = \"left\" : b.x = -d, k = !0);\n      d = f.x + c.width - u;\n      d > e.plotWidth && (\"left\" === l ? b.align = \"right\" : b.x = e.plotWidth - d, k = !0);\n      d = f.y + u;\n      0 > d && (\"bottom\" === p ? b.verticalAlign = \"top\" : b.y = -d, k = !0);\n      d = f.y + c.height - u;\n      d > e.plotHeight && (\"top\" === p ? b.verticalAlign = \"bottom\" : b.y = e.plotHeight - d, k = !0);\n      k && (a.placed = !h, a.align(b, null, g));\n      return k;\n    };\n\n    n.pie && (n.pie.prototype.dataLabelPositioners = {\n      radialDistributionY: function (a) {\n        return a.top + a.distributeBox.pos;\n      },\n      radialDistributionX: function (a, b, f, c) {\n        return a.getX(f < b.top + 2 || f > b.bottom - 2 ? c : f, b.half, b);\n      },\n      justify: function (a, b, f) {\n        return f[0] + (a.half ? -1 : 1) * (b + a.labelDistance);\n      },\n      alignToPlotEdges: function (a, b, f, c) {\n        a = a.getBBox().width;\n        return b ? a + c : f - a - c;\n      },\n      alignToConnectors: function (a, b, f, c) {\n        var e = 0,\n            g;\n        a.forEach(function (a) {\n          g = a.dataLabel.getBBox().width;\n          g > e && (e = g);\n        });\n        return b ? e + c : f - e - c;\n      }\n    }, n.pie.prototype.drawDataLabels = function () {\n      var e = this,\n          b = e.data,\n          f,\n          c = e.chart,\n          h = e.options.dataLabels,\n          r = h.connectorPadding,\n          w,\n          n = c.plotWidth,\n          p = c.plotHeight,\n          d = c.plotLeft,\n          k = Math.round(c.chartWidth / 3),\n          u,\n          m = e.center,\n          v = m[2] / 2,\n          q = m[1],\n          y,\n          N,\n          O,\n          L,\n          E = [[], []],\n          M,\n          J,\n          H,\n          I,\n          P = [0, 0, 0, 0],\n          S = e.dataLabelPositioners,\n          W;\n      e.visible && (h.enabled || e._hasPointLabels) && (b.forEach(function (a) {\n        a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({\n          width: \"auto\"\n        }).css({\n          width: \"auto\",\n          textOverflow: \"clip\"\n        }), a.dataLabel.shortened = !1);\n      }), z.prototype.drawDataLabels.apply(e), b.forEach(function (a) {\n        a.dataLabel && (a.visible ? (E[a.half].push(a), a.dataLabel._pos = null, !A(h.style.width) && !A(a.options.dataLabels && a.options.dataLabels.style && a.options.dataLabels.style.width) && a.dataLabel.getBBox().width > k && (a.dataLabel.css({\n          width: .7 * k\n        }), a.dataLabel.shortened = !0)) : (a.dataLabel = a.dataLabel.destroy(), a.dataLabels && 1 === a.dataLabels.length && delete a.dataLabels));\n      }), E.forEach(function (b, k) {\n        var g,\n            l,\n            u = b.length,\n            t = [],\n            w;\n        if (u) for (e.sortByAngle(b, k - .5), 0 < e.maxLabelDistance && (g = Math.max(0, q - v - e.maxLabelDistance), l = Math.min(q + v + e.maxLabelDistance, c.plotHeight), b.forEach(function (a) {\n          0 < a.labelDistance && a.dataLabel && (a.top = Math.max(0, q - v - a.labelDistance), a.bottom = Math.min(q + v + a.labelDistance, c.plotHeight), w = a.dataLabel.getBBox().height || 21, a.distributeBox = {\n            target: a.labelPosition.natural.y - a.top + w / 2,\n            size: w,\n            rank: a.y\n          }, t.push(a.distributeBox));\n        }), g = l + w - g, a.distribute(t, g, g / 5)), I = 0; I < u; I++) {\n          f = b[I];\n          O = f.labelPosition;\n          y = f.dataLabel;\n          H = !1 === f.visible ? \"hidden\" : \"inherit\";\n          J = g = O.natural.y;\n          t && A(f.distributeBox) && (void 0 === f.distributeBox.pos ? H = \"hidden\" : (L = f.distributeBox.size, J = S.radialDistributionY(f)));\n          delete f.positionIndex;\n          if (h.justify) M = S.justify(f, v, m);else switch (h.alignTo) {\n            case \"connectors\":\n              M = S.alignToConnectors(b, k, n, d);\n              break;\n\n            case \"plotEdges\":\n              M = S.alignToPlotEdges(y, k, n, d);\n              break;\n\n            default:\n              M = S.radialDistributionX(e, f, J, g);\n          }\n          y._attr = {\n            visibility: H,\n            align: O.alignment\n          };\n          y._pos = {\n            x: M + h.x + ({\n              left: r,\n              right: -r\n            }[O.alignment] || 0),\n            y: J + h.y - 10\n          };\n          O.final.x = M;\n          O.final.y = J;\n          x(h.crop, !0) && (N = y.getBBox().width, g = null, M - N < r && 1 === k ? (g = Math.round(N - M + r), P[3] = Math.max(g, P[3])) : M + N > n - r && 0 === k && (g = Math.round(M + N - n + r), P[1] = Math.max(g, P[1])), 0 > J - L / 2 ? P[0] = Math.max(Math.round(-J + L / 2), P[0]) : J + L / 2 > p && (P[2] = Math.max(Math.round(J + L / 2 - p), P[2])), y.sideOverflow = g);\n        }\n      }), 0 === C(P) || this.verifyDataLabelOverflow(P)) && (this.placeDataLabels(), this.points.forEach(function (a) {\n        W = g(h, a.options.dataLabels);\n\n        if (w = x(W.connectorWidth, 1)) {\n          var b;\n          u = a.connector;\n\n          if ((y = a.dataLabel) && y._pos && a.visible && 0 < a.labelDistance) {\n            H = y._attr.visibility;\n            if (b = !u) a.connector = u = c.renderer.path().addClass(\"highcharts-data-label-connector  highcharts-color-\" + a.colorIndex + (a.className ? \" \" + a.className : \"\")).add(e.dataLabelsGroup), c.styledMode || u.attr({\n              \"stroke-width\": w,\n              stroke: W.connectorColor || a.color || \"#666666\"\n            });\n            u[b ? \"attr\" : \"animate\"]({\n              d: a.getConnectorPath()\n            });\n            u.attr(\"visibility\", H);\n          } else u && (a.connector = u.destroy());\n        }\n      }));\n    }, n.pie.prototype.placeDataLabels = function () {\n      this.points.forEach(function (a) {\n        var b = a.dataLabel,\n            e;\n        b && a.visible && ((e = b._pos) ? (b.sideOverflow && (b._attr.width = Math.max(b.getBBox().width - b.sideOverflow, 0), b.css({\n          width: b._attr.width + \"px\",\n          textOverflow: (this.options.dataLabels.style || {}).textOverflow || \"ellipsis\"\n        }), b.shortened = !0), b.attr(b._attr), b[b.moved ? \"animate\" : \"attr\"](e), b.moved = !0) : b && b.attr({\n          y: -9999\n        }));\n        delete a.distributeBox;\n      }, this);\n    }, n.pie.prototype.alignDataLabel = v, n.pie.prototype.verifyDataLabelOverflow = function (a) {\n      var b = this.center,\n          e = this.options,\n          c = e.center,\n          f = e.minSize || 80,\n          g,\n          h = null !== e.size;\n      h || (null !== c[0] ? g = Math.max(b[2] - Math.max(a[1], a[3]), f) : (g = Math.max(b[2] - a[1] - a[3], f), b[0] += (a[3] - a[1]) / 2), null !== c[1] ? g = Math.max(Math.min(g, b[2] - Math.max(a[0], a[2])), f) : (g = Math.max(Math.min(g, b[2] - a[0] - a[2]), f), b[1] += (a[0] - a[2]) / 2), g < b[2] ? (b[2] = g, b[3] = Math.min(y(e.innerSize || 0, g), g), this.translate(b), this.drawDataLabels && this.drawDataLabels()) : h = !0);\n      return h;\n    });\n    n.column && (n.column.prototype.alignDataLabel = function (a, b, f, c, h) {\n      var e = this.chart.inverted,\n          l = a.series,\n          t = a.dlBox || a.shapeArgs,\n          p = x(a.below, a.plotY > x(this.translatedThreshold, l.yAxis.len)),\n          d = x(f.inside, !!this.options.stacking);\n      t && (c = g(t), 0 > c.y && (c.height += c.y, c.y = 0), t = c.y + c.height - l.yAxis.len, 0 < t && (c.height -= t), e && (c = {\n        x: l.yAxis.len - c.y - c.height,\n        y: l.xAxis.len - c.x - c.width,\n        width: c.height,\n        height: c.width\n      }), d || (e ? (c.x += p ? 0 : c.width, c.width = 0) : (c.y += p ? c.height : 0, c.height = 0)));\n      f.align = x(f.align, !e || d ? \"center\" : p ? \"right\" : \"left\");\n      f.verticalAlign = x(f.verticalAlign, e || d ? \"middle\" : p ? \"top\" : \"bottom\");\n      z.prototype.alignDataLabel.call(this, a, b, f, c, h);\n      a.isLabelJustified && a.contrastColor && b.css({\n        color: a.contrastColor\n      });\n    });\n  });\n  I(H, \"modules/overlapping-datalabels.src.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.Chart,\n        A = a.isArray,\n        E = a.objectEach,\n        m = a.pick,\n        g = a.addEvent,\n        v = a.fireEvent;\n    g(C, \"render\", function () {\n      var a = [];\n      (this.labelCollectors || []).forEach(function (g) {\n        a = a.concat(g());\n      });\n      (this.yAxis || []).forEach(function (g) {\n        g.options.stackLabels && !g.options.stackLabels.allowOverlap && E(g.stacks, function (g) {\n          E(g, function (g) {\n            a.push(g.label);\n          });\n        });\n      });\n      (this.series || []).forEach(function (g) {\n        var v = g.options.dataLabels;\n        g.visible && (!1 !== v.enabled || g._hasPointLabels) && g.points.forEach(function (g) {\n          g.visible && (A(g.dataLabels) ? g.dataLabels : g.dataLabel ? [g.dataLabel] : []).forEach(function (f) {\n            var h = f.options;\n            f.labelrank = m(h.labelrank, g.labelrank, g.shapeArgs && g.shapeArgs.height);\n            h.allowOverlap || a.push(f);\n          });\n        });\n      });\n      this.hideOverlappingLabels(a);\n    });\n\n    C.prototype.hideOverlappingLabels = function (a) {\n      var g = this,\n          m = a.length,\n          n = g.renderer,\n          f,\n          h,\n          r,\n          e,\n          b,\n          l,\n          c = function (a, b, c, e, f, d, k, g) {\n        return !(f > a + c || f + k < a || d > b + e || d + g < b);\n      };\n\n      r = function (a) {\n        var b,\n            c,\n            e,\n            f = a.box ? 0 : a.padding || 0;\n        e = 0;\n        if (a && (!a.alignAttr || a.placed)) return b = a.alignAttr || {\n          x: a.attr(\"x\"),\n          y: a.attr(\"y\")\n        }, c = a.parentGroup, a.width || (e = a.getBBox(), a.width = e.width, a.height = e.height, e = n.fontMetrics(null, a.element).h), {\n          x: b.x + (c.translateX || 0) + f,\n          y: b.y + (c.translateY || 0) + f - e,\n          width: a.width - 2 * f,\n          height: a.height - 2 * f\n        };\n      };\n\n      for (h = 0; h < m; h++) if (f = a[h]) f.oldOpacity = f.opacity, f.newOpacity = 1, f.absoluteBox = r(f);\n\n      a.sort(function (a, b) {\n        return (b.labelrank || 0) - (a.labelrank || 0);\n      });\n\n      for (h = 0; h < m; h++) for (l = (r = a[h]) && r.absoluteBox, f = h + 1; f < m; ++f) if (b = (e = a[f]) && e.absoluteBox, l && b && r !== e && 0 !== r.newOpacity && 0 !== e.newOpacity && (b = c(l.x, l.y, l.width, l.height, b.x, b.y, b.width, b.height))) (r.labelrank < e.labelrank ? r : e).newOpacity = 0;\n\n      a.forEach(function (a) {\n        var b, c;\n        a && (c = a.newOpacity, a.oldOpacity !== c && (a.alignAttr && a.placed ? (c ? a.show(!0) : b = function () {\n          a.hide();\n        }, a.alignAttr.opacity = c, a[a.isOld ? \"animate\" : \"attr\"](a.alignAttr, null, b), v(g, \"afterHideOverlappingLabels\")) : a.attr({\n          opacity: c\n        })), a.isOld = !0);\n      });\n    };\n  });\n  I(H, \"parts/Interaction.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.addEvent,\n        A = a.Chart,\n        E = a.createElement,\n        m = a.css,\n        g = a.defaultOptions,\n        v = a.defaultPlotOptions,\n        x = a.extend,\n        y = a.fireEvent,\n        z = a.hasTouch,\n        n = a.isObject,\n        f = a.isArray,\n        h = a.Legend,\n        r = a.merge,\n        e = a.pick,\n        b = a.Point,\n        l = a.Series,\n        c = a.seriesTypes,\n        t = a.svg,\n        F;\n    F = a.TrackerMixin = {\n      drawTrackerPoint: function () {\n        var a = this,\n            b = a.chart,\n            c = b.pointer,\n            d = function (a) {\n          var b = c.getPointFromEvent(a);\n          void 0 !== b && (c.isDirectTouch = !0, b.onMouseOver(a));\n        },\n            e;\n\n        a.points.forEach(function (a) {\n          e = f(a.dataLabels) ? a.dataLabels : a.dataLabel ? [a.dataLabel] : [];\n          a.graphic && (a.graphic.element.point = a);\n          e.forEach(function (b) {\n            b.div ? b.div.point = a : b.element.point = a;\n          });\n        });\n        a._hasTracking || (a.trackerGroups.forEach(function (e) {\n          if (a[e]) {\n            a[e].addClass(\"highcharts-tracker\").on(\"mouseover\", d).on(\"mouseout\", function (a) {\n              c.onTrackerMouseOut(a);\n            });\n            if (z) a[e].on(\"touchstart\", d);\n            !b.styledMode && a.options.cursor && a[e].css(m).css({\n              cursor: a.options.cursor\n            });\n          }\n        }), a._hasTracking = !0);\n        y(this, \"afterDrawTracker\");\n      },\n      drawTrackerGraph: function () {\n        var a = this,\n            b = a.options,\n            c = b.trackByArea,\n            d = [].concat(c ? a.areaPath : a.graphPath),\n            e = d.length,\n            f = a.chart,\n            g = f.pointer,\n            h = f.renderer,\n            l = f.options.tooltip.snap,\n            r = a.tracker,\n            n,\n            m = function () {\n          if (f.hoverSeries !== a) a.onMouseOver();\n        },\n            v = \"rgba(192,192,192,\" + (t ? .0001 : .002) + \")\";\n\n        if (e && !c) for (n = e + 1; n--;) \"M\" === d[n] && d.splice(n + 1, 0, d[n + 1] - l, d[n + 2], \"L\"), (n && \"M\" === d[n] || n === e) && d.splice(n, 0, \"L\", d[n - 2] + l, d[n - 1]);\n        r ? r.attr({\n          d: d\n        }) : a.graph && (a.tracker = h.path(d).attr({\n          visibility: a.visible ? \"visible\" : \"hidden\",\n          zIndex: 2\n        }).addClass(c ? \"highcharts-tracker-area\" : \"highcharts-tracker-line\").add(a.group), f.styledMode || a.tracker.attr({\n          \"stroke-linejoin\": \"round\",\n          stroke: v,\n          fill: c ? v : \"none\",\n          \"stroke-width\": a.graph.strokeWidth() + (c ? 0 : 2 * l)\n        }), [a.tracker, a.markerGroup].forEach(function (a) {\n          a.addClass(\"highcharts-tracker\").on(\"mouseover\", m).on(\"mouseout\", function (a) {\n            g.onTrackerMouseOut(a);\n          });\n          b.cursor && !f.styledMode && a.css({\n            cursor: b.cursor\n          });\n          if (z) a.on(\"touchstart\", m);\n        }));\n        y(this, \"afterDrawTracker\");\n      }\n    };\n    c.column && (c.column.prototype.drawTracker = F.drawTrackerPoint);\n    c.pie && (c.pie.prototype.drawTracker = F.drawTrackerPoint);\n    c.scatter && (c.scatter.prototype.drawTracker = F.drawTrackerPoint);\n    x(h.prototype, {\n      setItemEvents: function (a, c, e) {\n        var d = this,\n            f = d.chart.renderer.boxWrapper,\n            g = a instanceof b,\n            h = \"highcharts-legend-\" + (g ? \"point\" : \"series\") + \"-active\",\n            p = d.chart.styledMode;\n        (e ? c : a.legendGroup).on(\"mouseover\", function () {\n          d.allItems.forEach(function (b) {\n            a !== b && b.setState(\"inactive\", !g);\n          });\n          a.setState(\"hover\");\n          a.visible && f.addClass(h);\n          p || c.css(d.options.itemHoverStyle);\n        }).on(\"mouseout\", function () {\n          d.styledMode || c.css(r(a.visible ? d.itemStyle : d.itemHiddenStyle));\n          d.allItems.forEach(function (b) {\n            a !== b && b.setState(\"\", !g);\n          });\n          f.removeClass(h);\n          a.setState();\n        }).on(\"click\", function (b) {\n          var d = function () {\n            a.setVisible && a.setVisible();\n          };\n\n          f.removeClass(h);\n          b = {\n            browserEvent: b\n          };\n          a.firePointEvent ? a.firePointEvent(\"legendItemClick\", b, d) : y(a, \"legendItemClick\", b, d);\n        });\n      },\n      createCheckboxForItem: function (a) {\n        a.checkbox = E(\"input\", {\n          type: \"checkbox\",\n          className: \"highcharts-legend-checkbox\",\n          checked: a.selected,\n          defaultChecked: a.selected\n        }, this.options.itemCheckboxStyle, this.chart.container);\n        C(a.checkbox, \"click\", function (b) {\n          y(a.series || a, \"checkboxClick\", {\n            checked: b.target.checked,\n            item: a\n          }, function () {\n            a.select();\n          });\n        });\n      }\n    });\n    x(A.prototype, {\n      showResetZoom: function () {\n        function a() {\n          b.zoomOut();\n        }\n\n        var b = this,\n            c = g.lang,\n            d = b.options.chart.resetZoomButton,\n            e = d.theme,\n            f = e.states,\n            h = \"chart\" === d.relativeTo || \"spaceBox\" === d.relativeTo ? null : \"plotBox\";\n        y(this, \"beforeShowResetZoom\", null, function () {\n          b.resetZoomButton = b.renderer.button(c.resetZoom, null, null, a, e, f && f.hover).attr({\n            align: d.position.align,\n            title: c.resetZoomTitle\n          }).addClass(\"highcharts-reset-zoom\").add().align(d.position, !1, h);\n        });\n        y(this, \"afterShowResetZoom\");\n      },\n      zoomOut: function () {\n        y(this, \"selection\", {\n          resetSelection: !0\n        }, this.zoom);\n      },\n      zoom: function (b) {\n        var c = this,\n            f,\n            d = c.pointer,\n            k = !1,\n            g = c.inverted ? d.mouseDownX : d.mouseDownY,\n            h;\n        !b || b.resetSelection ? (c.axes.forEach(function (a) {\n          f = a.zoom();\n        }), d.initiated = !1) : b.xAxis.concat(b.yAxis).forEach(function (b) {\n          var e = b.axis,\n              h = c.inverted ? e.left : e.top,\n              p = c.inverted ? h + e.width : h + e.height,\n              l = e.isXAxis,\n              u = !1;\n          if (!l && g >= h && g <= p || l || !a.defined(g)) u = !0;\n          d[l ? \"zoomX\" : \"zoomY\"] && u && (f = e.zoom(b.min, b.max), e.displayBtn && (k = !0));\n        });\n        h = c.resetZoomButton;\n        k && !h ? c.showResetZoom() : !k && n(h) && (c.resetZoomButton = h.destroy());\n        f && c.redraw(e(c.options.chart.animation, b && b.animation, 100 > c.pointCount));\n      },\n      pan: function (a, b) {\n        var c = this,\n            d = c.hoverPoints,\n            e;\n        y(this, \"pan\", {\n          originalEvent: a\n        }, function () {\n          d && d.forEach(function (a) {\n            a.setState();\n          });\n          (\"xy\" === b ? [1, 0] : [1]).forEach(function (b) {\n            b = c[b ? \"xAxis\" : \"yAxis\"][0];\n            var d = b.horiz,\n                f = a[d ? \"chartX\" : \"chartY\"],\n                d = d ? \"mouseDownX\" : \"mouseDownY\",\n                k = c[d],\n                g = (b.pointRange || 0) / 2,\n                h = b.reversed && !c.inverted || !b.reversed && c.inverted ? -1 : 1,\n                p = b.getExtremes(),\n                l = b.toValue(k - f, !0) + g * h,\n                h = b.toValue(k + b.len - f, !0) - g * h,\n                u = h < l,\n                k = u ? h : l,\n                l = u ? l : h,\n                h = Math.min(p.dataMin, g ? p.min : b.toValue(b.toPixels(p.min) - b.minPixelPadding)),\n                g = Math.max(p.dataMax, g ? p.max : b.toValue(b.toPixels(p.max) + b.minPixelPadding)),\n                u = h - k;\n            0 < u && (l += u, k = h);\n            u = l - g;\n            0 < u && (l = g, k -= u);\n            b.series.length && k !== p.min && l !== p.max && (b.setExtremes(k, l, !1, !1, {\n              trigger: \"pan\"\n            }), e = !0);\n            c[d] = f;\n          });\n          e && c.redraw(!1);\n          m(c.container, {\n            cursor: \"move\"\n          });\n        });\n      }\n    });\n    x(b.prototype, {\n      select: function (a, b) {\n        var c = this,\n            d = c.series,\n            f = d.chart;\n        a = e(a, !c.selected);\n        c.firePointEvent(a ? \"select\" : \"unselect\", {\n          accumulate: b\n        }, function () {\n          c.selected = c.options.selected = a;\n          d.options.data[d.data.indexOf(c)] = c.options;\n          c.setState(a && \"select\");\n          b || f.getSelectedPoints().forEach(function (a) {\n            var b = a.series;\n            a.selected && a !== c && (a.selected = a.options.selected = !1, b.options.data[b.data.indexOf(a)] = a.options, a.setState(f.hoverPoints && b.options.inactiveOtherPoints ? \"inactive\" : \"\"), a.firePointEvent(\"unselect\"));\n          });\n        });\n      },\n      onMouseOver: function (a) {\n        var b = this.series.chart,\n            c = b.pointer;\n        a = a ? c.normalize(a) : c.getChartCoordinatesFromPoint(this, b.inverted);\n        c.runPointActions(a, this);\n      },\n      onMouseOut: function () {\n        var a = this.series.chart;\n        this.firePointEvent(\"mouseOut\");\n        this.series.options.inactiveOtherPoints || (a.hoverPoints || []).forEach(function (a) {\n          a.setState();\n        });\n        a.hoverPoints = a.hoverPoint = null;\n      },\n      importEvents: function () {\n        if (!this.hasImportedEvents) {\n          var b = this,\n              c = r(b.series.options.point, b.options).events;\n          b.events = c;\n          a.objectEach(c, function (c, d) {\n            a.isFunction(c) && C(b, d, c);\n          });\n          this.hasImportedEvents = !0;\n        }\n      },\n      setState: function (a, b) {\n        var c = Math.floor(this.plotX),\n            d = this.plotY,\n            f = this.series,\n            g = this.state,\n            h = f.options.states[a || \"normal\"] || {},\n            l = v[f.type].marker && f.options.marker,\n            q = l && !1 === l.enabled,\n            t = l && l.states && l.states[a || \"normal\"] || {},\n            r = !1 === t.enabled,\n            n = f.stateMarkerGraphic,\n            m = this.marker || {},\n            w = f.chart,\n            B = f.halo,\n            F,\n            z,\n            A,\n            C = l && f.markerAttribs;\n        a = a || \"\";\n\n        if (!(a === this.state && !b || this.selected && \"select\" !== a || !1 === h.enabled || a && (r || q && !1 === t.enabled) || a && m.states && m.states[a] && !1 === m.states[a].enabled)) {\n          this.state = a;\n          C && (F = f.markerAttribs(this, a));\n          if (this.graphic) g && this.graphic.removeClass(\"highcharts-point-\" + g), a && this.graphic.addClass(\"highcharts-point-\" + a), w.styledMode || (z = f.pointAttribs(this, a), A = e(w.options.chart.animation, h.animation), f.options.inactiveOtherPoints && ((this.dataLabels || []).forEach(function (a) {\n            a && a.animate({\n              opacity: z.opacity\n            }, A);\n          }), this.connector && this.connector.animate({\n            opacity: z.opacity\n          }, A)), this.graphic.animate(z, A)), F && this.graphic.animate(F, e(w.options.chart.animation, t.animation, l.animation)), n && n.hide();else {\n            if (a && t) {\n              g = m.symbol || f.symbol;\n              n && n.currentSymbol !== g && (n = n.destroy());\n              if (n) n[b ? \"animate\" : \"attr\"]({\n                x: F.x,\n                y: F.y\n              });else g && (f.stateMarkerGraphic = n = w.renderer.symbol(g, F.x, F.y, F.width, F.height).add(f.markerGroup), n.currentSymbol = g);\n              !w.styledMode && n && n.attr(f.pointAttribs(this, a));\n            }\n\n            n && (n[a && w.isInsidePlot(c, d, w.inverted) ? \"show\" : \"hide\"](), n.element.point = this);\n          }\n          (a = h.halo) && a.size ? (B || (f.halo = B = w.renderer.path().add((this.graphic || n).parentGroup)), B.show()[b ? \"animate\" : \"attr\"]({\n            d: this.haloPath(a.size)\n          }), B.attr({\n            \"class\": \"highcharts-halo highcharts-color-\" + e(this.colorIndex, f.colorIndex) + (this.className ? \" \" + this.className : \"\"),\n            zIndex: -1\n          }), B.point = this, w.styledMode || B.attr(x({\n            fill: this.color || f.color,\n            \"fill-opacity\": a.opacity\n          }, a.attributes))) : B && B.point && B.point.haloPath && B.animate({\n            d: B.point.haloPath(0)\n          }, null, B.hide);\n          y(this, \"afterSetState\");\n        }\n      },\n      haloPath: function (a) {\n        return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a, this.plotY - a, 2 * a, 2 * a);\n      }\n    });\n    x(l.prototype, {\n      onMouseOver: function () {\n        var a = this.chart,\n            b = a.hoverSeries;\n        if (b && b !== this) b.onMouseOut();\n        this.options.events.mouseOver && y(this, \"mouseOver\");\n        this.setState(\"hover\");\n        a.hoverSeries = this;\n      },\n      onMouseOut: function () {\n        var a = this.options,\n            b = this.chart,\n            c = b.tooltip,\n            d = b.hoverPoint;\n        b.hoverSeries = null;\n        if (d) d.onMouseOut();\n        this && a.events.mouseOut && y(this, \"mouseOut\");\n        !c || this.stickyTracking || c.shared && !this.noSharedTooltip || c.hide();\n        b.series.forEach(function (a) {\n          a.setState(\"\", !0);\n        });\n      },\n      setState: function (a, b) {\n        var c = this,\n            d = c.options,\n            f = c.graph,\n            g = d.inactiveOtherPoints,\n            h = d.states,\n            l = d.lineWidth,\n            q = d.opacity,\n            t = e(h[a || \"normal\"] && h[a || \"normal\"].animation, c.chart.options.chart.animation),\n            d = 0;\n        a = a || \"\";\n\n        if (c.state !== a && ([c.group, c.markerGroup, c.dataLabelsGroup].forEach(function (b) {\n          b && (c.state && b.removeClass(\"highcharts-series-\" + c.state), a && b.addClass(\"highcharts-series-\" + a));\n        }), c.state = a, !c.chart.styledMode)) {\n          if (h[a] && !1 === h[a].enabled) return;\n          a && (l = h[a].lineWidth || l + (h[a].lineWidthPlus || 0), q = e(h[a].opacity, q));\n          if (f && !f.dashstyle) for (h = {\n            \"stroke-width\": l\n          }, f.animate(h, t); c[\"zone-graph-\" + d];) c[\"zone-graph-\" + d].attr(h), d += 1;\n          g || [c.group, c.markerGroup, c.dataLabelsGroup, c.labelBySeries].forEach(function (a) {\n            a && a.animate({\n              opacity: q\n            }, t);\n          });\n        }\n\n        b && g && c.points && c.points.forEach(function (b) {\n          b.setState && b.setState(a);\n        });\n      },\n      setVisible: function (a, b) {\n        var c = this,\n            d = c.chart,\n            e = c.legendItem,\n            f,\n            g = d.options.chart.ignoreHiddenSeries,\n            h = c.visible;\n        f = (c.visible = a = c.options.visible = c.userOptions.visible = void 0 === a ? !h : a) ? \"show\" : \"hide\";\n        [\"group\", \"dataLabelsGroup\", \"markerGroup\", \"tracker\", \"tt\"].forEach(function (a) {\n          if (c[a]) c[a][f]();\n        });\n        if (d.hoverSeries === c || (d.hoverPoint && d.hoverPoint.series) === c) c.onMouseOut();\n        e && d.legend.colorizeItem(c, a);\n        c.isDirty = !0;\n        c.options.stacking && d.series.forEach(function (a) {\n          a.options.stacking && a.visible && (a.isDirty = !0);\n        });\n        c.linkedSeries.forEach(function (b) {\n          b.setVisible(a, !1);\n        });\n        g && (d.isDirtyBox = !0);\n        y(c, f);\n        !1 !== b && d.redraw();\n      },\n      show: function () {\n        this.setVisible(!0);\n      },\n      hide: function () {\n        this.setVisible(!1);\n      },\n      select: function (a) {\n        this.selected = a = this.options.selected = void 0 === a ? !this.selected : a;\n        this.checkbox && (this.checkbox.checked = a);\n        y(this, a ? \"select\" : \"unselect\");\n      },\n      drawTracker: F.drawTrackerGraph\n    });\n  });\n  I(H, \"parts/Responsive.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.Chart,\n        A = a.isArray,\n        E = a.isObject,\n        m = a.pick,\n        g = a.splat;\n\n    C.prototype.setResponsive = function (g, m) {\n      var v = this.options.responsive,\n          x = [],\n          n = this.currentResponsive;\n      !m && v && v.rules && v.rules.forEach(function (f) {\n        void 0 === f._id && (f._id = a.uniqueKey());\n        this.matchResponsiveRule(f, x, g);\n      }, this);\n      m = a.merge.apply(0, x.map(function (f) {\n        return a.find(v.rules, function (a) {\n          return a._id === f;\n        }).chartOptions;\n      }));\n      m.isResponsiveOptions = !0;\n      x = x.toString() || void 0;\n      x !== (n && n.ruleIds) && (n && this.update(n.undoOptions, g, !0), x ? (n = this.currentOptions(m), n.isResponsiveOptions = !0, this.currentResponsive = {\n        ruleIds: x,\n        mergedOptions: m,\n        undoOptions: n\n      }, this.update(m, g, !0)) : this.currentResponsive = void 0);\n    };\n\n    C.prototype.matchResponsiveRule = function (a, g) {\n      var v = a.condition;\n      (v.callback || function () {\n        return this.chartWidth <= m(v.maxWidth, Number.MAX_VALUE) && this.chartHeight <= m(v.maxHeight, Number.MAX_VALUE) && this.chartWidth >= m(v.minWidth, 0) && this.chartHeight >= m(v.minHeight, 0);\n      }).call(this) && g.push(a._id);\n    };\n\n    C.prototype.currentOptions = function (v) {\n      function x(n, f, h, r) {\n        var e;\n        a.objectEach(n, function (a, l) {\n          if (!r && -1 < y.collectionsWithUpdate.indexOf(l)) for (a = g(a), h[l] = [], e = 0; e < a.length; e++) f[l][e] && (h[l][e] = {}, x(a[e], f[l][e], h[l][e], r + 1));else E(a) ? (h[l] = A(a) ? [] : {}, x(a, f[l] || {}, h[l], r + 1)) : h[l] = m(f[l], null);\n        });\n      }\n\n      var y = this,\n          z = {};\n      x(v, this.options, z, 0);\n      return z;\n    };\n  });\n  I(H, \"masters/highcharts.src.js\", [H[\"parts/Globals.js\"]], function (a) {\n    return a;\n  });\n  I(H, \"parts/Scrollbar.js\", [H[\"parts/Globals.js\"]], function (a) {\n    function C(a, e, c) {\n      this.init(a, e, c);\n    }\n\n    var A = a.addEvent,\n        E = a.Axis,\n        m = a.correctFloat,\n        g = a.defaultOptions,\n        v = a.defined,\n        x = a.destroyObjectProperties,\n        y = a.fireEvent,\n        z = a.hasTouch,\n        n = a.merge,\n        f = a.pick,\n        h = a.removeEvent,\n        r,\n        e = {\n      height: a.isTouchDevice ? 20 : 14,\n      barBorderRadius: 0,\n      buttonBorderRadius: 0,\n      liveRedraw: void 0,\n      margin: 10,\n      minWidth: 6,\n      step: .2,\n      zIndex: 3,\n      barBackgroundColor: \"#cccccc\",\n      barBorderWidth: 1,\n      barBorderColor: \"#cccccc\",\n      buttonArrowColor: \"#333333\",\n      buttonBackgroundColor: \"#e6e6e6\",\n      buttonBorderColor: \"#cccccc\",\n      buttonBorderWidth: 1,\n      rifleColor: \"#333333\",\n      trackBackgroundColor: \"#f2f2f2\",\n      trackBorderColor: \"#f2f2f2\",\n      trackBorderWidth: 1\n    };\n    g.scrollbar = n(!0, e, g.scrollbar);\n\n    a.swapXY = r = function (a, e) {\n      var b = a.length,\n          f;\n      if (e) for (e = 0; e < b; e += 3) f = a[e + 1], a[e + 1] = a[e + 2], a[e + 2] = f;\n      return a;\n    };\n\n    C.prototype = {\n      init: function (a, g, c) {\n        this.scrollbarButtons = [];\n        this.renderer = a;\n        this.userOptions = g;\n        this.options = n(e, g);\n        this.chart = c;\n        this.size = f(this.options.size, this.options.height);\n        g.enabled && (this.render(), this.initEvents(), this.addEvents());\n      },\n      render: function () {\n        var a = this.renderer,\n            e = this.options,\n            c = this.size,\n            f = this.chart.styledMode,\n            g;\n        this.group = g = a.g(\"scrollbar\").attr({\n          zIndex: e.zIndex,\n          translateY: -99999\n        }).add();\n        this.track = a.rect().addClass(\"highcharts-scrollbar-track\").attr({\n          x: 0,\n          r: e.trackBorderRadius || 0,\n          height: c,\n          width: c\n        }).add(g);\n        f || this.track.attr({\n          fill: e.trackBackgroundColor,\n          stroke: e.trackBorderColor,\n          \"stroke-width\": e.trackBorderWidth\n        });\n        this.trackBorderWidth = this.track.strokeWidth();\n        this.track.attr({\n          y: -this.trackBorderWidth % 2 / 2\n        });\n        this.scrollbarGroup = a.g().add(g);\n        this.scrollbar = a.rect().addClass(\"highcharts-scrollbar-thumb\").attr({\n          height: c,\n          width: c,\n          r: e.barBorderRadius || 0\n        }).add(this.scrollbarGroup);\n        this.scrollbarRifles = a.path(r([\"M\", -3, c / 4, \"L\", -3, 2 * c / 3, \"M\", 0, c / 4, \"L\", 0, 2 * c / 3, \"M\", 3, c / 4, \"L\", 3, 2 * c / 3], e.vertical)).addClass(\"highcharts-scrollbar-rifles\").add(this.scrollbarGroup);\n        f || (this.scrollbar.attr({\n          fill: e.barBackgroundColor,\n          stroke: e.barBorderColor,\n          \"stroke-width\": e.barBorderWidth\n        }), this.scrollbarRifles.attr({\n          stroke: e.rifleColor,\n          \"stroke-width\": 1\n        }));\n        this.scrollbarStrokeWidth = this.scrollbar.strokeWidth();\n        this.scrollbarGroup.translate(-this.scrollbarStrokeWidth % 2 / 2, -this.scrollbarStrokeWidth % 2 / 2);\n        this.drawScrollbarButton(0);\n        this.drawScrollbarButton(1);\n      },\n      position: function (a, e, c, f) {\n        var b = this.options.vertical,\n            g = 0,\n            h = this.rendered ? \"animate\" : \"attr\";\n        this.x = a;\n        this.y = e + this.trackBorderWidth;\n        this.width = c;\n        this.xOffset = this.height = f;\n        this.yOffset = g;\n        b ? (this.width = this.yOffset = c = g = this.size, this.xOffset = e = 0, this.barWidth = f - 2 * c, this.x = a += this.options.margin) : (this.height = this.xOffset = f = e = this.size, this.barWidth = c - 2 * f, this.y += this.options.margin);\n        this.group[h]({\n          translateX: a,\n          translateY: this.y\n        });\n        this.track[h]({\n          width: c,\n          height: f\n        });\n        this.scrollbarButtons[1][h]({\n          translateX: b ? 0 : c - e,\n          translateY: b ? f - g : 0\n        });\n      },\n      drawScrollbarButton: function (a) {\n        var b = this.renderer,\n            c = this.scrollbarButtons,\n            e = this.options,\n            f = this.size,\n            g;\n        g = b.g().add(this.group);\n        c.push(g);\n        g = b.rect().addClass(\"highcharts-scrollbar-button\").add(g);\n        this.chart.styledMode || g.attr({\n          stroke: e.buttonBorderColor,\n          \"stroke-width\": e.buttonBorderWidth,\n          fill: e.buttonBackgroundColor\n        });\n        g.attr(g.crisp({\n          x: -.5,\n          y: -.5,\n          width: f + 1,\n          height: f + 1,\n          r: e.buttonBorderRadius\n        }, g.strokeWidth()));\n        g = b.path(r([\"M\", f / 2 + (a ? -1 : 1), f / 2 - 3, \"L\", f / 2 + (a ? -1 : 1), f / 2 + 3, \"L\", f / 2 + (a ? 2 : -2), f / 2], e.vertical)).addClass(\"highcharts-scrollbar-arrow\").add(c[a]);\n        this.chart.styledMode || g.attr({\n          fill: e.buttonArrowColor\n        });\n      },\n      setRange: function (a, e) {\n        var b = this.options,\n            f = b.vertical,\n            g = b.minWidth,\n            h = this.barWidth,\n            l,\n            p,\n            d = !this.rendered || this.hasDragged || this.chart.navigator && this.chart.navigator.hasDragged ? \"attr\" : \"animate\";\n        v(h) && (a = Math.max(a, 0), l = Math.ceil(h * a), this.calculatedWidth = p = m(h * Math.min(e, 1) - l), p < g && (l = (h - g + p) * a, p = g), g = Math.floor(l + this.xOffset + this.yOffset), h = p / 2 - .5, this.from = a, this.to = e, f ? (this.scrollbarGroup[d]({\n          translateY: g\n        }), this.scrollbar[d]({\n          height: p\n        }), this.scrollbarRifles[d]({\n          translateY: h\n        }), this.scrollbarTop = g, this.scrollbarLeft = 0) : (this.scrollbarGroup[d]({\n          translateX: g\n        }), this.scrollbar[d]({\n          width: p\n        }), this.scrollbarRifles[d]({\n          translateX: h\n        }), this.scrollbarLeft = g, this.scrollbarTop = 0), 12 >= p ? this.scrollbarRifles.hide() : this.scrollbarRifles.show(!0), !1 === b.showFull && (0 >= a && 1 <= e ? this.group.hide() : this.group.show()), this.rendered = !0);\n      },\n      initEvents: function () {\n        var a = this;\n\n        a.mouseMoveHandler = function (b) {\n          var c = a.chart.pointer.normalize(b),\n              e = a.options.vertical ? \"chartY\" : \"chartX\",\n              f = a.initPositions;\n          !a.grabbedCenter || b.touches && 0 === b.touches[0][e] || (c = a.cursorToScrollbarPosition(c)[e], e = a[e], e = c - e, a.hasDragged = !0, a.updatePosition(f[0] + e, f[1] + e), a.hasDragged && y(a, \"changed\", {\n            from: a.from,\n            to: a.to,\n            trigger: \"scrollbar\",\n            DOMType: b.type,\n            DOMEvent: b\n          }));\n        };\n\n        a.mouseUpHandler = function (b) {\n          a.hasDragged && y(a, \"changed\", {\n            from: a.from,\n            to: a.to,\n            trigger: \"scrollbar\",\n            DOMType: b.type,\n            DOMEvent: b\n          });\n          a.grabbedCenter = a.hasDragged = a.chartX = a.chartY = null;\n        };\n\n        a.mouseDownHandler = function (b) {\n          b = a.chart.pointer.normalize(b);\n          b = a.cursorToScrollbarPosition(b);\n          a.chartX = b.chartX;\n          a.chartY = b.chartY;\n          a.initPositions = [a.from, a.to];\n          a.grabbedCenter = !0;\n        };\n\n        a.buttonToMinClick = function (b) {\n          var c = m(a.to - a.from) * a.options.step;\n          a.updatePosition(m(a.from - c), m(a.to - c));\n          y(a, \"changed\", {\n            from: a.from,\n            to: a.to,\n            trigger: \"scrollbar\",\n            DOMEvent: b\n          });\n        };\n\n        a.buttonToMaxClick = function (b) {\n          var c = (a.to - a.from) * a.options.step;\n          a.updatePosition(a.from + c, a.to + c);\n          y(a, \"changed\", {\n            from: a.from,\n            to: a.to,\n            trigger: \"scrollbar\",\n            DOMEvent: b\n          });\n        };\n\n        a.trackClick = function (b) {\n          var c = a.chart.pointer.normalize(b),\n              e = a.to - a.from,\n              f = a.y + a.scrollbarTop,\n              g = a.x + a.scrollbarLeft;\n          a.options.vertical && c.chartY > f || !a.options.vertical && c.chartX > g ? a.updatePosition(a.from + e, a.to + e) : a.updatePosition(a.from - e, a.to - e);\n          y(a, \"changed\", {\n            from: a.from,\n            to: a.to,\n            trigger: \"scrollbar\",\n            DOMEvent: b\n          });\n        };\n      },\n      cursorToScrollbarPosition: function (a) {\n        var b = this.options,\n            b = b.minWidth > this.calculatedWidth ? b.minWidth : 0;\n        return {\n          chartX: (a.chartX - this.x - this.xOffset) / (this.barWidth - b),\n          chartY: (a.chartY - this.y - this.yOffset) / (this.barWidth - b)\n        };\n      },\n      updatePosition: function (a, e) {\n        1 < e && (a = m(1 - m(e - a)), e = 1);\n        0 > a && (e = m(e - a), a = 0);\n        this.from = a;\n        this.to = e;\n      },\n      update: function (a) {\n        this.destroy();\n        this.init(this.chart.renderer, n(!0, this.options, a), this.chart);\n      },\n      addEvents: function () {\n        var a = this.options.inverted ? [1, 0] : [0, 1],\n            e = this.scrollbarButtons,\n            c = this.scrollbarGroup.element,\n            f = this.mouseDownHandler,\n            g = this.mouseMoveHandler,\n            h = this.mouseUpHandler,\n            a = [[e[a[0]].element, \"click\", this.buttonToMinClick], [e[a[1]].element, \"click\", this.buttonToMaxClick], [this.track.element, \"click\", this.trackClick], [c, \"mousedown\", f], [c.ownerDocument, \"mousemove\", g], [c.ownerDocument, \"mouseup\", h]];\n        z && a.push([c, \"touchstart\", f], [c.ownerDocument, \"touchmove\", g], [c.ownerDocument, \"touchend\", h]);\n        a.forEach(function (a) {\n          A.apply(null, a);\n        });\n        this._events = a;\n      },\n      removeEvents: function () {\n        this._events.forEach(function (a) {\n          h.apply(null, a);\n        });\n\n        this._events.length = 0;\n      },\n      destroy: function () {\n        var a = this.chart.scroller;\n        this.removeEvents();\n        [\"track\", \"scrollbarRifles\", \"scrollbar\", \"scrollbarGroup\", \"group\"].forEach(function (a) {\n          this[a] && this[a].destroy && (this[a] = this[a].destroy());\n        }, this);\n        a && this === a.scrollbar && (a.scrollbar = null, x(a.scrollbarButtons));\n      }\n    };\n    a.Scrollbar || (A(E, \"afterInit\", function () {\n      var b = this;\n      b.options && b.options.scrollbar && b.options.scrollbar.enabled && (b.options.scrollbar.vertical = !b.horiz, b.options.startOnTick = b.options.endOnTick = !1, b.scrollbar = new C(b.chart.renderer, b.options.scrollbar, b.chart), A(b.scrollbar, \"changed\", function (e) {\n        var c = Math.min(f(b.options.min, b.min), b.min, b.dataMin),\n            g = Math.max(f(b.options.max, b.max), b.max, b.dataMax) - c,\n            h;\n        b.horiz && !b.reversed || !b.horiz && b.reversed ? (h = c + g * this.to, c += g * this.from) : (h = c + g * (1 - this.from), c += g * (1 - this.to));\n        f(this.options.liveRedraw, a.svg && !a.isTouchDevice && !this.chart.isBoosting) || \"mouseup\" === e.DOMType || !v(e.DOMType) ? b.setExtremes(c, h, !0, \"mousemove\" !== e.DOMType, e) : this.setRange(this.from, this.to);\n      }));\n    }), A(E, \"afterRender\", function () {\n      var a = Math.min(f(this.options.min, this.min), this.min, f(this.dataMin, this.min)),\n          e = Math.max(f(this.options.max, this.max), this.max, f(this.dataMax, this.max)),\n          c = this.scrollbar,\n          g = this.axisTitleMargin + (this.titleOffset || 0),\n          h = this.chart.scrollbarsOffsets,\n          n = this.options.margin || 0;\n      c && (this.horiz ? (this.opposite || (h[1] += g), c.position(this.left, this.top + this.height + 2 + h[1] - (this.opposite ? n : 0), this.width, this.height), this.opposite || (h[1] += n), g = 1) : (this.opposite && (h[0] += g), c.position(this.left + this.width + 2 + h[0] - (this.opposite ? 0 : n), this.top, this.width, this.height), this.opposite && (h[0] += n), g = 0), h[g] += c.size + c.options.margin, isNaN(a) || isNaN(e) || !v(this.min) || !v(this.max) || this.min === this.max ? c.setRange(0, 1) : (h = (this.min - a) / (e - a), a = (this.max - a) / (e - a), this.horiz && !this.reversed || !this.horiz && this.reversed ? c.setRange(h, a) : c.setRange(1 - a, 1 - h)));\n    }), A(E, \"afterGetOffset\", function () {\n      var a = this.horiz ? 2 : 1,\n          e = this.scrollbar;\n      e && (this.chart.scrollbarsOffsets = [0, 0], this.chart.axisOffset[a] += e.size + e.options.margin);\n    }), a.Scrollbar = C);\n  });\n  I(H, \"parts/Navigator.js\", [H[\"parts/Globals.js\"]], function (a) {\n    function C(a) {\n      this.init(a);\n    }\n\n    var A = a.addEvent,\n        E = a.Axis,\n        m = a.Chart,\n        g = a.color,\n        v = a.defaultOptions,\n        x = a.defined,\n        y = a.destroyObjectProperties,\n        z = a.erase,\n        n = a.extend,\n        f = a.hasTouch,\n        h = a.isArray,\n        r = a.isNumber,\n        e = a.isTouchDevice,\n        b = a.merge,\n        l = a.pick,\n        c = a.removeEvent,\n        t = a.Scrollbar,\n        F = a.Series,\n        w,\n        B = function (a) {\n      var b = [].filter.call(arguments, r);\n      if (b.length) return Math[a].apply(0, b);\n    };\n\n    w = void 0 === a.seriesTypes.areaspline ? \"line\" : \"areaspline\";\n    n(v, {\n      navigator: {\n        height: 40,\n        margin: 25,\n        maskInside: !0,\n        handles: {\n          width: 7,\n          height: 15,\n          symbols: [\"navigator-handle\", \"navigator-handle\"],\n          enabled: !0,\n          lineWidth: 1,\n          backgroundColor: \"#f2f2f2\",\n          borderColor: \"#999999\"\n        },\n        maskFill: g(\"#6685c2\").setOpacity(.3).get(),\n        outlineColor: \"#cccccc\",\n        outlineWidth: 1,\n        series: {\n          type: w,\n          fillOpacity: .05,\n          lineWidth: 1,\n          compare: null,\n          dataGrouping: {\n            approximation: \"average\",\n            enabled: !0,\n            groupPixelWidth: 2,\n            smoothed: !0,\n            units: [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2, 3, 4]], [\"week\", [1, 2, 3]], [\"month\", [1, 3, 6]], [\"year\", null]]\n          },\n          dataLabels: {\n            enabled: !1,\n            zIndex: 2\n          },\n          id: \"highcharts-navigator-series\",\n          className: \"highcharts-navigator-series\",\n          lineColor: null,\n          marker: {\n            enabled: !1\n          },\n          pointRange: 0,\n          threshold: null\n        },\n        xAxis: {\n          overscroll: 0,\n          className: \"highcharts-navigator-xaxis\",\n          tickLength: 0,\n          lineWidth: 0,\n          gridLineColor: \"#e6e6e6\",\n          gridLineWidth: 1,\n          tickPixelInterval: 200,\n          labels: {\n            align: \"left\",\n            style: {\n              color: \"#999999\"\n            },\n            x: 3,\n            y: -4\n          },\n          crosshair: !1\n        },\n        yAxis: {\n          className: \"highcharts-navigator-yaxis\",\n          gridLineWidth: 0,\n          startOnTick: !1,\n          endOnTick: !1,\n          minPadding: .1,\n          maxPadding: .1,\n          labels: {\n            enabled: !1\n          },\n          crosshair: !1,\n          title: {\n            text: null\n          },\n          tickLength: 0,\n          tickWidth: 0\n        }\n      }\n    });\n\n    a.Renderer.prototype.symbols[\"navigator-handle\"] = function (a, b, c, e, f) {\n      a = f.width / 2;\n      b = Math.round(a / 3) + .5;\n      f = f.height;\n      return [\"M\", -a - 1, .5, \"L\", a, .5, \"L\", a, f + .5, \"L\", -a - 1, f + .5, \"L\", -a - 1, .5, \"M\", -b, 4, \"L\", -b, f - 3, \"M\", b - 1, 4, \"L\", b - 1, f - 3];\n    };\n\n    E.prototype.toFixedRange = function (a, b, c, e) {\n      var d = this.chart && this.chart.fixedRange;\n      a = l(c, this.translate(a, !0, !this.horiz));\n      b = l(e, this.translate(b, !0, !this.horiz));\n      c = d && (b - a) / d;\n      .7 < c && 1.3 > c && (e ? a = b - d : b = a + d);\n      r(a) && r(b) || (a = b = void 0);\n      return {\n        min: a,\n        max: b\n      };\n    };\n\n    C.prototype = {\n      drawHandle: function (a, b, c, e) {\n        var d = this.navigatorOptions.handles.height;\n        this.handles[b][e](c ? {\n          translateX: Math.round(this.left + this.height / 2),\n          translateY: Math.round(this.top + parseInt(a, 10) + .5 - d)\n        } : {\n          translateX: Math.round(this.left + parseInt(a, 10)),\n          translateY: Math.round(this.top + this.height / 2 - d / 2 - 1)\n        });\n      },\n      drawOutline: function (a, b, c, e) {\n        var d = this.navigatorOptions.maskInside,\n            f = this.outline.strokeWidth(),\n            g = f / 2,\n            f = f % 2 / 2,\n            k = this.outlineHeight,\n            h = this.scrollbarHeight,\n            p = this.size,\n            l = this.left - h,\n            u = this.top;\n        c ? (l -= g, c = u + b + f, b = u + a + f, a = [\"M\", l + k, u - h - f, \"L\", l + k, c, \"L\", l, c, \"L\", l, b, \"L\", l + k, b, \"L\", l + k, u + p + h].concat(d ? [\"M\", l + k, c - g, \"L\", l + k, b + g] : [])) : (a += l + h - f, b += l + h - f, u += g, a = [\"M\", l, u, \"L\", a, u, \"L\", a, u + k, \"L\", b, u + k, \"L\", b, u, \"L\", l + p + 2 * h, u].concat(d ? [\"M\", a - g, u, \"L\", b + g, u] : []));\n        this.outline[e]({\n          d: a\n        });\n      },\n      drawMasks: function (a, b, c, e) {\n        var d = this.left,\n            f = this.top,\n            g = this.height,\n            k,\n            h,\n            p,\n            l;\n        c ? (p = [d, d, d], l = [f, f + a, f + b], h = [g, g, g], k = [a, b - a, this.size - b]) : (p = [d, d + a, d + b], l = [f, f, f], h = [a, b - a, this.size - b], k = [g, g, g]);\n        this.shades.forEach(function (a, b) {\n          a[e]({\n            x: p[b],\n            y: l[b],\n            width: h[b],\n            height: k[b]\n          });\n        });\n      },\n      renderElements: function () {\n        var a = this,\n            b = a.navigatorOptions,\n            c = b.maskInside,\n            e = a.chart,\n            f = e.renderer,\n            g,\n            h = {\n          cursor: e.inverted ? \"ns-resize\" : \"ew-resize\"\n        };\n        a.navigatorGroup = g = f.g(\"navigator\").attr({\n          zIndex: 8,\n          visibility: \"hidden\"\n        }).add();\n        [!c, c, !c].forEach(function (d, c) {\n          a.shades[c] = f.rect().addClass(\"highcharts-navigator-mask\" + (1 === c ? \"-inside\" : \"-outside\")).add(g);\n          e.styledMode || a.shades[c].attr({\n            fill: d ? b.maskFill : \"rgba(0,0,0,0)\"\n          }).css(1 === c && h);\n        });\n        a.outline = f.path().addClass(\"highcharts-navigator-outline\").add(g);\n        e.styledMode || a.outline.attr({\n          \"stroke-width\": b.outlineWidth,\n          stroke: b.outlineColor\n        });\n        b.handles.enabled && [0, 1].forEach(function (d) {\n          b.handles.inverted = e.inverted;\n          a.handles[d] = f.symbol(b.handles.symbols[d], -b.handles.width / 2 - 1, 0, b.handles.width, b.handles.height, b.handles);\n          a.handles[d].attr({\n            zIndex: 7 - d\n          }).addClass(\"highcharts-navigator-handle highcharts-navigator-handle-\" + [\"left\", \"right\"][d]).add(g);\n\n          if (!e.styledMode) {\n            var c = b.handles;\n            a.handles[d].attr({\n              fill: c.backgroundColor,\n              stroke: c.borderColor,\n              \"stroke-width\": c.lineWidth\n            }).css(h);\n          }\n        });\n      },\n      update: function (a) {\n        (this.series || []).forEach(function (a) {\n          a.baseSeries && delete a.baseSeries.navigatorSeries;\n        });\n        this.destroy();\n        b(!0, this.chart.options.navigator, this.options, a);\n        this.init(this.chart);\n      },\n      render: function (b, d, c, e) {\n        var f = this.chart,\n            g,\n            k,\n            h = this.scrollbarHeight,\n            p,\n            u = this.xAxis;\n        g = u.fake ? f.xAxis[0] : u;\n        var t = this.navigatorEnabled,\n            n,\n            m = this.rendered;\n        k = f.inverted;\n        var w,\n            v = f.xAxis[0].minRange,\n            y = f.xAxis[0].options.maxRange;\n\n        if (!this.hasDragged || x(c)) {\n          if (!r(b) || !r(d)) if (m) c = 0, e = l(u.width, g.width);else return;\n          this.left = l(u.left, f.plotLeft + h + (k ? f.plotWidth : 0));\n          this.size = n = p = l(u.len, (k ? f.plotHeight : f.plotWidth) - 2 * h);\n          f = k ? h : p + 2 * h;\n          c = l(c, u.toPixels(b, !0));\n          e = l(e, u.toPixels(d, !0));\n          r(c) && Infinity !== Math.abs(c) || (c = 0, e = f);\n          b = u.toValue(c, !0);\n          d = u.toValue(e, !0);\n          w = Math.abs(a.correctFloat(d - b));\n          w < v ? this.grabbedLeft ? c = u.toPixels(d - v, !0) : this.grabbedRight && (e = u.toPixels(b + v, !0)) : x(y) && w > y && (this.grabbedLeft ? c = u.toPixels(d - y, !0) : this.grabbedRight && (e = u.toPixels(b + y, !0)));\n          this.zoomedMax = Math.min(Math.max(c, e, 0), n);\n          this.zoomedMin = Math.min(Math.max(this.fixedWidth ? this.zoomedMax - this.fixedWidth : Math.min(c, e), 0), n);\n          this.range = this.zoomedMax - this.zoomedMin;\n          n = Math.round(this.zoomedMax);\n          c = Math.round(this.zoomedMin);\n          t && (this.navigatorGroup.attr({\n            visibility: \"visible\"\n          }), m = m && !this.hasDragged ? \"animate\" : \"attr\", this.drawMasks(c, n, k, m), this.drawOutline(c, n, k, m), this.navigatorOptions.handles.enabled && (this.drawHandle(c, 0, k, m), this.drawHandle(n, 1, k, m)));\n          this.scrollbar && (k ? (k = this.top - h, g = this.left - h + (t || !g.opposite ? 0 : (g.titleOffset || 0) + g.axisTitleMargin), h = p + 2 * h) : (k = this.top + (t ? this.height : -h), g = this.left - h), this.scrollbar.position(g, k, f, h), this.scrollbar.setRange(this.zoomedMin / (p || 1), this.zoomedMax / (p || 1)));\n          this.rendered = !0;\n        }\n      },\n      addMouseEvents: function () {\n        var a = this,\n            b = a.chart,\n            c = b.container,\n            e = [],\n            g,\n            h;\n\n        a.mouseMoveHandler = g = function (b) {\n          a.onMouseMove(b);\n        };\n\n        a.mouseUpHandler = h = function (b) {\n          a.onMouseUp(b);\n        };\n\n        e = a.getPartsEvents(\"mousedown\");\n        e.push(A(c, \"mousemove\", g), A(c.ownerDocument, \"mouseup\", h));\n        f && (e.push(A(c, \"touchmove\", g), A(c.ownerDocument, \"touchend\", h)), e.concat(a.getPartsEvents(\"touchstart\")));\n        a.eventsToUnbind = e;\n        a.series && a.series[0] && e.push(A(a.series[0].xAxis, \"foundExtremes\", function () {\n          b.navigator.modifyNavigatorAxisExtremes();\n        }));\n      },\n      getPartsEvents: function (a) {\n        var b = this,\n            c = [];\n        [\"shades\", \"handles\"].forEach(function (d) {\n          b[d].forEach(function (e, f) {\n            c.push(A(e.element, a, function (a) {\n              b[d + \"Mousedown\"](a, f);\n            }));\n          });\n        });\n        return c;\n      },\n      shadesMousedown: function (a, b) {\n        a = this.chart.pointer.normalize(a);\n        var d = this.chart,\n            c = this.xAxis,\n            e = this.zoomedMin,\n            f = this.left,\n            g = this.size,\n            h = this.range,\n            l = a.chartX,\n            p,\n            t;\n        d.inverted && (l = a.chartY, f = this.top);\n        1 === b ? (this.grabbedCenter = l, this.fixedWidth = h, this.dragOffset = l - e) : (a = l - f - h / 2, 0 === b ? a = Math.max(0, a) : 2 === b && a + h >= g && (a = g - h, this.reversedExtremes ? (a -= h, t = this.getUnionExtremes().dataMin) : p = this.getUnionExtremes().dataMax), a !== e && (this.fixedWidth = h, b = c.toFixedRange(a, a + h, t, p), x(b.min) && d.xAxis[0].setExtremes(Math.min(b.min, b.max), Math.max(b.min, b.max), !0, null, {\n          trigger: \"navigator\"\n        })));\n      },\n      handlesMousedown: function (a, b) {\n        this.chart.pointer.normalize(a);\n        a = this.chart;\n        var d = a.xAxis[0],\n            c = this.reversedExtremes;\n        0 === b ? (this.grabbedLeft = !0, this.otherHandlePos = this.zoomedMax, this.fixedExtreme = c ? d.min : d.max) : (this.grabbedRight = !0, this.otherHandlePos = this.zoomedMin, this.fixedExtreme = c ? d.max : d.min);\n        a.fixedRange = null;\n      },\n      onMouseMove: function (b) {\n        var d = this,\n            c = d.chart,\n            f = d.left,\n            g = d.navigatorSize,\n            h = d.range,\n            p = d.dragOffset,\n            t = c.inverted;\n        b.touches && 0 === b.touches[0].pageX || (b = c.pointer.normalize(b), c = b.chartX, t && (f = d.top, c = b.chartY), d.grabbedLeft ? (d.hasDragged = !0, d.render(0, 0, c - f, d.otherHandlePos)) : d.grabbedRight ? (d.hasDragged = !0, d.render(0, 0, d.otherHandlePos, c - f)) : d.grabbedCenter && (d.hasDragged = !0, c < p ? c = p : c > g + p - h && (c = g + p - h), d.render(0, 0, c - p, c - p + h)), d.hasDragged && d.scrollbar && l(d.scrollbar.options.liveRedraw, a.svg && !e && !this.chart.isBoosting) && (b.DOMType = b.type, setTimeout(function () {\n          d.onMouseUp(b);\n        }, 0)));\n      },\n      onMouseUp: function (a) {\n        var b = this.chart,\n            c = this.xAxis,\n            e = this.scrollbar,\n            f,\n            g,\n            h = a.DOMEvent || a;\n        (!this.hasDragged || e && e.hasDragged) && \"scrollbar\" !== a.trigger || (e = this.getUnionExtremes(), this.zoomedMin === this.otherHandlePos ? f = this.fixedExtreme : this.zoomedMax === this.otherHandlePos && (g = this.fixedExtreme), this.zoomedMax === this.size && (g = this.reversedExtremes ? e.dataMin : e.dataMax), 0 === this.zoomedMin && (f = this.reversedExtremes ? e.dataMax : e.dataMin), c = c.toFixedRange(this.zoomedMin, this.zoomedMax, f, g), x(c.min) && b.xAxis[0].setExtremes(Math.min(c.min, c.max), Math.max(c.min, c.max), !0, this.hasDragged ? !1 : null, {\n          trigger: \"navigator\",\n          triggerOp: \"navigator-drag\",\n          DOMEvent: h\n        }));\n        \"mousemove\" !== a.DOMType && (this.grabbedLeft = this.grabbedRight = this.grabbedCenter = this.fixedWidth = this.fixedExtreme = this.otherHandlePos = this.hasDragged = this.dragOffset = null);\n      },\n      removeEvents: function () {\n        this.eventsToUnbind && (this.eventsToUnbind.forEach(function (a) {\n          a();\n        }), this.eventsToUnbind = void 0);\n        this.removeBaseSeriesEvents();\n      },\n      removeBaseSeriesEvents: function () {\n        var a = this.baseSeries || [];\n        this.navigatorEnabled && a[0] && (!1 !== this.navigatorOptions.adaptToUpdatedData && a.forEach(function (a) {\n          c(a, \"updatedData\", this.updatedDataHandler);\n        }, this), a[0].xAxis && c(a[0].xAxis, \"foundExtremes\", this.modifyBaseAxisExtremes));\n      },\n      init: function (a) {\n        var d = a.options,\n            c = d.navigator,\n            e = c.enabled,\n            f = d.scrollbar,\n            g = f.enabled,\n            d = e ? c.height : 0,\n            h = g ? f.height : 0;\n        this.handles = [];\n        this.shades = [];\n        this.chart = a;\n        this.setBaseSeries();\n        this.height = d;\n        this.scrollbarHeight = h;\n        this.scrollbarEnabled = g;\n        this.navigatorEnabled = e;\n        this.navigatorOptions = c;\n        this.scrollbarOptions = f;\n        this.outlineHeight = d + h;\n        this.opposite = l(c.opposite, !e && a.inverted);\n        var p = this,\n            e = p.baseSeries,\n            f = a.xAxis.length,\n            g = a.yAxis.length,\n            n = e && e[0] && e[0].xAxis || a.xAxis[0] || {\n          options: {}\n        };\n        a.isDirtyBox = !0;\n        p.navigatorEnabled ? (p.xAxis = new E(a, b({\n          breaks: n.options.breaks,\n          ordinal: n.options.ordinal\n        }, c.xAxis, {\n          id: \"navigator-x-axis\",\n          yAxis: \"navigator-y-axis\",\n          isX: !0,\n          type: \"datetime\",\n          index: f,\n          isInternal: !0,\n          offset: 0,\n          keepOrdinalPadding: !0,\n          startOnTick: !1,\n          endOnTick: !1,\n          minPadding: 0,\n          maxPadding: 0,\n          zoomEnabled: !1\n        }, a.inverted ? {\n          offsets: [h, 0, -h, 0],\n          width: d\n        } : {\n          offsets: [0, -h, 0, h],\n          height: d\n        })), p.yAxis = new E(a, b(c.yAxis, {\n          id: \"navigator-y-axis\",\n          alignTicks: !1,\n          offset: 0,\n          index: g,\n          isInternal: !0,\n          zoomEnabled: !1\n        }, a.inverted ? {\n          width: d\n        } : {\n          height: d\n        })), e || c.series.data ? p.updateNavigatorSeries(!1) : 0 === a.series.length && (p.unbindRedraw = A(a, \"beforeRedraw\", function () {\n          0 < a.series.length && !p.series && (p.setBaseSeries(), p.unbindRedraw());\n        })), p.reversedExtremes = a.inverted && !p.xAxis.reversed || !a.inverted && p.xAxis.reversed, p.renderElements(), p.addMouseEvents()) : p.xAxis = {\n          translate: function (b, d) {\n            var c = a.xAxis[0],\n                e = c.getExtremes(),\n                f = c.len - 2 * h,\n                g = B(\"min\", c.options.min, e.dataMin),\n                c = B(\"max\", c.options.max, e.dataMax) - g;\n            return d ? b * c / f + g : f * (b - g) / c;\n          },\n          toPixels: function (a) {\n            return this.translate(a);\n          },\n          toValue: function (a) {\n            return this.translate(a, !0);\n          },\n          toFixedRange: E.prototype.toFixedRange,\n          fake: !0\n        };\n        a.options.scrollbar.enabled && (a.scrollbar = p.scrollbar = new t(a.renderer, b(a.options.scrollbar, {\n          margin: p.navigatorEnabled ? 0 : 10,\n          vertical: a.inverted\n        }), a), A(p.scrollbar, \"changed\", function (b) {\n          var d = p.size,\n              c = d * this.to,\n              d = d * this.from;\n          p.hasDragged = p.scrollbar.hasDragged;\n          p.render(0, 0, d, c);\n          (a.options.scrollbar.liveRedraw || \"mousemove\" !== b.DOMType && \"touchmove\" !== b.DOMType) && setTimeout(function () {\n            p.onMouseUp(b);\n          });\n        }));\n        p.addBaseSeriesEvents();\n        p.addChartEvents();\n      },\n      getUnionExtremes: function (a) {\n        var b = this.chart.xAxis[0],\n            c = this.xAxis,\n            e = c.options,\n            f = b.options,\n            g;\n        a && null === b.dataMin || (g = {\n          dataMin: l(e && e.min, B(\"min\", f.min, b.dataMin, c.dataMin, c.min)),\n          dataMax: l(e && e.max, B(\"max\", f.max, b.dataMax, c.dataMax, c.max))\n        });\n        return g;\n      },\n      setBaseSeries: function (b, d) {\n        var c = this.chart,\n            e = this.baseSeries = [];\n        b = b || c.options && c.options.navigator.baseSeries || (c.series.length ? a.find(c.series, function (a) {\n          return !a.options.isInternal;\n        }).index : 0);\n        (c.series || []).forEach(function (a, d) {\n          a.options.isInternal || !a.options.showInNavigator && (d !== b && a.options.id !== b || !1 === a.options.showInNavigator) || e.push(a);\n        });\n        this.xAxis && !this.xAxis.fake && this.updateNavigatorSeries(!0, d);\n      },\n      updateNavigatorSeries: function (e, d) {\n        var f = this,\n            g = f.chart,\n            l = f.baseSeries,\n            p,\n            q,\n            t = f.navigatorOptions.series,\n            r,\n            m = {\n          enableMouseTracking: !1,\n          index: null,\n          linkedTo: null,\n          group: \"nav\",\n          padXAxis: !1,\n          xAxis: \"navigator-x-axis\",\n          yAxis: \"navigator-y-axis\",\n          showInLegend: !1,\n          stacking: !1,\n          isInternal: !0,\n          states: {\n            inactive: {\n              opacity: 1\n            }\n          }\n        },\n            w = f.series = (f.series || []).filter(function (a) {\n          var b = a.baseSeries;\n          return 0 > l.indexOf(b) ? (b && (c(b, \"updatedData\", f.updatedDataHandler), delete b.navigatorSeries), a.chart && a.destroy(), !1) : !0;\n        });\n        l && l.length && l.forEach(function (a) {\n          var c = a.navigatorSeries,\n              e = n({\n            color: a.color,\n            visible: a.visible\n          }, h(t) ? v.navigator.series : t);\n          c && !1 === f.navigatorOptions.adaptToUpdatedData || (m.name = \"Navigator \" + l.length, p = a.options || {}, r = p.navigatorOptions || {}, q = b(p, m, e, r), e = r.data || e.data, f.hasNavigatorData = f.hasNavigatorData || !!e, q.data = e || p.data && p.data.slice(0), c && c.options ? c.update(q, d) : (a.navigatorSeries = g.initSeries(q), a.navigatorSeries.baseSeries = a, w.push(a.navigatorSeries)));\n        });\n        if (t.data && (!l || !l.length) || h(t)) f.hasNavigatorData = !1, t = a.splat(t), t.forEach(function (a, d) {\n          m.name = \"Navigator \" + (w.length + 1);\n          q = b(v.navigator.series, {\n            color: g.series[d] && !g.series[d].options.isInternal && g.series[d].color || g.options.colors[d] || g.options.colors[0]\n          }, m, a);\n          q.data = a.data;\n          q.data && (f.hasNavigatorData = !0, w.push(g.initSeries(q)));\n        });\n        e && this.addBaseSeriesEvents();\n      },\n      addBaseSeriesEvents: function () {\n        var a = this,\n            b = a.baseSeries || [];\n        b[0] && b[0].xAxis && A(b[0].xAxis, \"foundExtremes\", this.modifyBaseAxisExtremes);\n        b.forEach(function (b) {\n          A(b, \"show\", function () {\n            this.navigatorSeries && this.navigatorSeries.setVisible(!0, !1);\n          });\n          A(b, \"hide\", function () {\n            this.navigatorSeries && this.navigatorSeries.setVisible(!1, !1);\n          });\n          !1 !== this.navigatorOptions.adaptToUpdatedData && b.xAxis && A(b, \"updatedData\", this.updatedDataHandler);\n          A(b, \"remove\", function () {\n            this.navigatorSeries && (z(a.series, this.navigatorSeries), x(this.navigatorSeries.options) && this.navigatorSeries.remove(!1), delete this.navigatorSeries);\n          });\n        }, this);\n      },\n      getBaseSeriesMin: function (a) {\n        return this.baseSeries.reduce(function (a, b) {\n          return Math.min(a, b.xData ? b.xData[0] : a);\n        }, a);\n      },\n      modifyNavigatorAxisExtremes: function () {\n        var a = this.xAxis,\n            b;\n        a.getExtremes && (!(b = this.getUnionExtremes(!0)) || b.dataMin === a.min && b.dataMax === a.max || (a.min = b.dataMin, a.max = b.dataMax));\n      },\n      modifyBaseAxisExtremes: function () {\n        var a = this.chart.navigator,\n            b = this.getExtremes(),\n            c = b.dataMin,\n            e = b.dataMax,\n            b = b.max - b.min,\n            f = a.stickToMin,\n            g = a.stickToMax,\n            h = l(this.options.overscroll, 0),\n            t,\n            n,\n            m = a.series && a.series[0],\n            w = !!this.setExtremes;\n        this.eventArgs && \"rangeSelectorButton\" === this.eventArgs.trigger || (f && (n = c, t = n + b), g && (t = e + h, f || (n = Math.max(t - b, a.getBaseSeriesMin(m && m.xData ? m.xData[0] : -Number.MAX_VALUE)))), w && (f || g) && r(n) && (this.min = this.userMin = n, this.max = this.userMax = t));\n        a.stickToMin = a.stickToMax = null;\n      },\n      updatedDataHandler: function () {\n        var a = this.chart.navigator,\n            b = this.navigatorSeries,\n            c = a.getBaseSeriesMin(this.xData[0]);\n        a.stickToMax = a.reversedExtremes ? 0 === Math.round(a.zoomedMin) : Math.round(a.zoomedMax) >= Math.round(a.size);\n        a.stickToMin = r(this.xAxis.min) && this.xAxis.min <= c && (!this.chart.fixedRange || !a.stickToMax);\n        b && !a.hasNavigatorData && (b.options.pointStart = this.xData[0], b.setData(this.options.data, !1, null, !1));\n      },\n      addChartEvents: function () {\n        this.eventsToUnbind || (this.eventsToUnbind = []);\n        this.eventsToUnbind.push(A(this.chart, \"redraw\", function () {\n          var a = this.navigator,\n              b = a && (a.baseSeries && a.baseSeries[0] && a.baseSeries[0].xAxis || a.scrollbar && this.xAxis[0]);\n          b && a.render(b.min, b.max);\n        }), A(this.chart, \"getMargins\", function () {\n          var a = this.navigator,\n              b = a.opposite ? \"plotTop\" : \"marginBottom\";\n          this.inverted && (b = a.opposite ? \"marginRight\" : \"plotLeft\");\n          this[b] = (this[b] || 0) + (a.navigatorEnabled || !this.inverted ? a.outlineHeight : 0) + a.navigatorOptions.margin;\n        }));\n      },\n      destroy: function () {\n        this.removeEvents();\n        this.xAxis && (z(this.chart.xAxis, this.xAxis), z(this.chart.axes, this.xAxis));\n        this.yAxis && (z(this.chart.yAxis, this.yAxis), z(this.chart.axes, this.yAxis));\n        (this.series || []).forEach(function (a) {\n          a.destroy && a.destroy();\n        });\n        \"series xAxis yAxis shades outline scrollbarTrack scrollbarRifles scrollbarGroup scrollbar navigatorGroup rendered\".split(\" \").forEach(function (a) {\n          this[a] && this[a].destroy && this[a].destroy();\n          this[a] = null;\n        }, this);\n        [this.handles].forEach(function (a) {\n          y(a);\n        }, this);\n      }\n    };\n    a.Navigator || (a.Navigator = C, A(E, \"zoom\", function (a) {\n      var b = this.chart.options,\n          c = b.chart.zoomType,\n          f = b.chart.pinchType,\n          g = b.navigator,\n          b = b.rangeSelector;\n      this.isXAxis && (g && g.enabled || b && b.enabled) && (\"y\" === c ? a.zoomed = !1 : (!e && \"xy\" === c || e && \"xy\" === f) && this.options.range && (c = this.previousZoom, x(a.newMin) ? this.previousZoom = [this.min, this.max] : c && (a.newMin = c[0], a.newMax = c[1], delete this.previousZoom)));\n      void 0 !== a.zoomed && a.preventDefault();\n    }), A(m, \"beforeShowResetZoom\", function () {\n      var a = this.options,\n          b = a.navigator,\n          c = a.rangeSelector;\n      if ((b && b.enabled || c && c.enabled) && (!e && \"x\" === a.chart.zoomType || e && \"x\" === a.chart.pinchType)) return !1;\n    }), A(m, \"beforeRender\", function () {\n      var a = this.options;\n      if (a.navigator.enabled || a.scrollbar.enabled) this.scroller = this.navigator = new C(this);\n    }), A(m, \"afterSetChartSize\", function () {\n      var a = this.legend,\n          b = this.navigator,\n          c,\n          e,\n          f,\n          g;\n      b && (e = a && a.options, f = b.xAxis, g = b.yAxis, c = b.scrollbarHeight, this.inverted ? (b.left = b.opposite ? this.chartWidth - c - b.height : this.spacing[3] + c, b.top = this.plotTop + c) : (b.left = this.plotLeft + c, b.top = b.navigatorOptions.top || this.chartHeight - b.height - c - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (e && \"bottom\" === e.verticalAlign && e.enabled && !e.floating ? a.legendHeight + l(e.margin, 10) : 0)), f && g && (this.inverted ? f.options.left = g.options.left = b.left : f.options.top = g.options.top = b.top, f.setAxisSize(), g.setAxisSize()));\n    }), A(m, \"update\", function (a) {\n      var d = a.options.navigator || {},\n          c = a.options.scrollbar || {};\n      this.navigator || this.scroller || !d.enabled && !c.enabled || (b(!0, this.options.navigator, d), b(!0, this.options.scrollbar, c), delete a.options.navigator, delete a.options.scrollbar);\n    }), A(m, \"afterUpdate\", function (a) {\n      this.navigator || this.scroller || !this.options.navigator.enabled && !this.options.scrollbar.enabled || (this.scroller = this.navigator = new C(this), l(a.redraw, !0) && this.redraw(a.animation));\n    }), A(m, \"afterAddSeries\", function () {\n      this.navigator && this.navigator.setBaseSeries(null, !1);\n    }), A(F, \"afterUpdate\", function () {\n      this.chart.navigator && !this.options.isInternal && this.chart.navigator.setBaseSeries(null, !1);\n    }), m.prototype.callbacks.push(function (a) {\n      var b = a.navigator;\n      b && a.xAxis[0] && (a = a.xAxis[0].getExtremes(), b.render(a.min, a.max));\n    }));\n  });\n  I(H, \"parts/OrdinalAxis.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.addEvent,\n        A = a.Axis,\n        E = a.Chart,\n        m = a.css,\n        g = a.defined,\n        v = a.extend,\n        x = a.noop,\n        y = a.pick,\n        z = a.timeUnits;\n    C(a.Series, \"updatedData\", function () {\n      var a = this.xAxis;\n      a && a.options.ordinal && delete a.ordinalIndex;\n    });\n\n    A.prototype.getTimeTicks = function (a, f, h, r, e, b, l) {\n      var c = 0,\n          t,\n          n,\n          m = {},\n          v,\n          p,\n          d,\n          k = [],\n          u = -Number.MAX_VALUE,\n          x = this.options.tickPixelInterval,\n          y = this.chart.time,\n          q = [];\n      if (!this.options.ordinal && !this.options.breaks || !e || 3 > e.length || void 0 === f) return y.getTimeTicks.apply(y, arguments);\n      p = e.length;\n\n      for (t = 0; t < p; t++) {\n        d = t && e[t - 1] > h;\n        e[t] < f && (c = t);\n\n        if (t === p - 1 || e[t + 1] - e[t] > 5 * b || d) {\n          if (e[t] > u) {\n            for (n = y.getTimeTicks(a, e[c], e[t], r); n.length && n[0] <= u;) n.shift();\n\n            n.length && (u = n[n.length - 1]);\n            q.push(k.length);\n            k = k.concat(n);\n          }\n\n          c = t + 1;\n        }\n\n        if (d) break;\n      }\n\n      n = n.info;\n\n      if (l && n.unitRange <= z.hour) {\n        t = k.length - 1;\n\n        for (c = 1; c < t; c++) y.dateFormat(\"%d\", k[c]) !== y.dateFormat(\"%d\", k[c - 1]) && (m[k[c]] = \"day\", v = !0);\n\n        v && (m[k[0]] = \"day\");\n        n.higherRanks = m;\n      }\n\n      n.segmentStarts = q;\n      k.info = n;\n\n      if (l && g(x)) {\n        c = q = k.length;\n        v = [];\n\n        for (var A, y = []; c--;) t = this.translate(k[c]), A && (y[c] = A - t), v[c] = A = t;\n\n        y.sort();\n        y = y[Math.floor(y.length / 2)];\n        y < .6 * x && (y = null);\n        c = k[q - 1] > h ? q - 1 : q;\n\n        for (A = void 0; c--;) t = v[c], q = Math.abs(A - t), A && q < .8 * x && (null === y || q < .8 * y) ? (m[k[c]] && !m[k[c + 1]] ? (q = c + 1, A = t) : q = c, k.splice(q, 1)) : A = t;\n      }\n\n      return k;\n    };\n\n    v(A.prototype, {\n      beforeSetTickPositions: function () {\n        var a,\n            f = [],\n            g,\n            r = !1,\n            e,\n            b = this.getExtremes(),\n            l = b.min,\n            c = b.max,\n            t,\n            m = this.isXAxis && !!this.options.breaks,\n            b = this.options.ordinal,\n            w = Number.MAX_VALUE,\n            v = this.chart.options.chart.ignoreHiddenSeries,\n            p;\n\n        if (b || m) {\n          this.series.forEach(function (b, c) {\n            g = [];\n\n            if (!(v && !1 === b.visible || !1 === b.takeOrdinalPosition && !m) && (f = f.concat(b.processedXData), a = f.length, f.sort(function (a, b) {\n              return a - b;\n            }), w = Math.min(w, y(b.closestPointRange, w)), a)) {\n              for (c = 0; c < a - 1;) f[c] !== f[c + 1] && g.push(f[c + 1]), c++;\n\n              g[0] !== f[0] && g.unshift(f[0]);\n              f = g;\n            }\n\n            b.isSeriesBoosting && (p = !0);\n          });\n          p && (f.length = 0);\n          a = f.length;\n\n          if (2 < a) {\n            e = f[1] - f[0];\n\n            for (t = a - 1; t-- && !r;) f[t + 1] - f[t] !== e && (r = !0);\n\n            !this.options.keepOrdinalPadding && (f[0] - l > e || c - f[f.length - 1] > e) && (r = !0);\n          } else this.options.overscroll && (2 === a ? w = f[1] - f[0] : 1 === a ? (w = this.options.overscroll, f = [f[0], f[0] + w]) : w = this.overscrollPointsRange);\n\n          r ? (this.options.overscroll && (this.overscrollPointsRange = w, f = f.concat(this.getOverscrollPositions())), this.ordinalPositions = f, e = this.ordinal2lin(Math.max(l, f[0]), !0), t = Math.max(this.ordinal2lin(Math.min(c, f[f.length - 1]), !0), 1), this.ordinalSlope = c = (c - l) / (t - e), this.ordinalOffset = l - e * c) : (this.overscrollPointsRange = y(this.closestPointRange, this.overscrollPointsRange), this.ordinalPositions = this.ordinalSlope = this.ordinalOffset = void 0);\n        }\n\n        this.isOrdinal = b && r;\n        this.groupIntervalFactor = null;\n      },\n      val2lin: function (a, f) {\n        var g = this.ordinalPositions;\n\n        if (g) {\n          var n = g.length,\n              e,\n              b;\n\n          for (e = n; e--;) if (g[e] === a) {\n            b = e;\n            break;\n          }\n\n          for (e = n - 1; e--;) if (a > g[e] || 0 === e) {\n            a = (a - g[e]) / (g[e + 1] - g[e]);\n            b = e + a;\n            break;\n          }\n\n          f = f ? b : this.ordinalSlope * (b || 0) + this.ordinalOffset;\n        } else f = a;\n\n        return f;\n      },\n      lin2val: function (a, f) {\n        var g = this.ordinalPositions;\n\n        if (g) {\n          var n = this.ordinalSlope,\n              e = this.ordinalOffset,\n              b = g.length - 1,\n              l;\n          if (f) 0 > a ? a = g[0] : a > b ? a = g[b] : (b = Math.floor(a), l = a - b);else for (; b--;) if (f = n * b + e, a >= f) {\n            n = n * (b + 1) + e;\n            l = (a - f) / (n - f);\n            break;\n          }\n          return void 0 !== l && void 0 !== g[b] ? g[b] + (l ? l * (g[b + 1] - g[b]) : 0) : a;\n        }\n\n        return a;\n      },\n      getExtendedPositions: function () {\n        var a = this,\n            f = a.chart,\n            g = a.series[0].currentDataGrouping,\n            r = a.ordinalIndex,\n            e = g ? g.count + g.unitName : \"raw\",\n            b = a.options.overscroll,\n            l = a.getExtremes(),\n            c,\n            t;\n        r || (r = a.ordinalIndex = {});\n        r[e] || (c = {\n          series: [],\n          chart: f,\n          getExtremes: function () {\n            return {\n              min: l.dataMin,\n              max: l.dataMax + b\n            };\n          },\n          options: {\n            ordinal: !0\n          },\n          val2lin: A.prototype.val2lin,\n          ordinal2lin: A.prototype.ordinal2lin\n        }, a.series.forEach(function (b) {\n          t = {\n            xAxis: c,\n            xData: b.xData.slice(),\n            chart: f,\n            destroyGroupedData: x\n          };\n          t.xData = t.xData.concat(a.getOverscrollPositions());\n          t.options = {\n            dataGrouping: g ? {\n              enabled: !0,\n              forced: !0,\n              approximation: \"open\",\n              units: [[g.unitName, [g.count]]]\n            } : {\n              enabled: !1\n            }\n          };\n          b.processData.apply(t);\n          c.series.push(t);\n        }), a.beforeSetTickPositions.apply(c), r[e] = c.ordinalPositions);\n        return r[e];\n      },\n      getOverscrollPositions: function () {\n        var g = this.options.overscroll,\n            f = this.overscrollPointsRange,\n            h = [],\n            r = this.dataMax;\n        if (a.defined(f)) for (h.push(r); r <= this.dataMax + g;) r += f, h.push(r);\n        return h;\n      },\n      getGroupIntervalFactor: function (a, f, g) {\n        var h;\n        g = g.processedXData;\n        var e = g.length,\n            b = [];\n        h = this.groupIntervalFactor;\n\n        if (!h) {\n          for (h = 0; h < e - 1; h++) b[h] = g[h + 1] - g[h];\n\n          b.sort(function (a, b) {\n            return a - b;\n          });\n          b = b[Math.floor(e / 2)];\n          a = Math.max(a, g[0]);\n          f = Math.min(f, g[e - 1]);\n          this.groupIntervalFactor = h = e * b / (f - a);\n        }\n\n        return h;\n      },\n      postProcessTickInterval: function (a) {\n        var f = this.ordinalSlope;\n        return f ? this.options.breaks ? this.closestPointRange || a : a / (f / this.closestPointRange) : a;\n      }\n    });\n    A.prototype.ordinal2lin = A.prototype.val2lin;\n    C(E, \"pan\", function (a) {\n      var f = this.xAxis[0],\n          g = f.options.overscroll,\n          n = a.originalEvent.chartX,\n          e = !1;\n\n      if (f.options.ordinal && f.series.length) {\n        var b = this.mouseDownX,\n            l = f.getExtremes(),\n            c = l.dataMax,\n            t = l.min,\n            v = l.max,\n            w = this.hoverPoints,\n            x = f.closestPointRange || f.overscrollPointsRange,\n            b = (b - n) / (f.translationSlope * (f.ordinalSlope || x)),\n            p = {\n          ordinalPositions: f.getExtendedPositions()\n        },\n            x = f.lin2val,\n            d = f.val2lin,\n            k;\n        p.ordinalPositions ? 1 < Math.abs(b) && (w && w.forEach(function (a) {\n          a.setState();\n        }), 0 > b ? (w = p, k = f.ordinalPositions ? f : p) : (w = f.ordinalPositions ? f : p, k = p), p = k.ordinalPositions, c > p[p.length - 1] && p.push(c), this.fixedRange = v - t, b = f.toFixedRange(null, null, x.apply(w, [d.apply(w, [t, !0]) + b, !0]), x.apply(k, [d.apply(k, [v, !0]) + b, !0])), b.min >= Math.min(l.dataMin, t) && b.max <= Math.max(c, v) + g && f.setExtremes(b.min, b.max, !0, !1, {\n          trigger: \"pan\"\n        }), this.mouseDownX = n, m(this.container, {\n          cursor: \"move\"\n        })) : e = !0;\n      } else e = !0;\n\n      e ? g && (f.max = f.dataMax + g) : a.preventDefault();\n    });\n    C(A, \"foundExtremes\", function () {\n      this.isXAxis && g(this.options.overscroll) && this.max === this.dataMax && (!this.chart.mouseIsDown || this.isInternal) && (!this.eventArgs || this.eventArgs && \"navigator\" !== this.eventArgs.trigger) && (this.max += this.options.overscroll, !this.isInternal && g(this.userMin) && (this.min += this.options.overscroll));\n    });\n    C(A, \"afterSetScale\", function () {\n      this.horiz && !this.isDirty && (this.isDirty = this.isOrdinal && this.chart.navigator && !this.chart.navigator.adaptToUpdatedData);\n    });\n  });\n  I(H, \"modules/broken-axis.src.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.addEvent,\n        A = a.pick,\n        E = a.extend,\n        m = a.isArray,\n        g = a.find,\n        v = a.fireEvent,\n        x = a.Axis,\n        y = a.Series,\n        z = function (a, f) {\n      return g(f, function (f) {\n        return f.from < a && a < f.to;\n      });\n    };\n\n    E(x.prototype, {\n      isInBreak: function (a, f) {\n        var g = a.repeat || Infinity,\n            m = a.from,\n            e = a.to - a.from;\n        f = f >= m ? (f - m) % g : g - (m - f) % g;\n        return a.inclusive ? f <= e : f < e && 0 !== f;\n      },\n      isInAnyBreak: function (a, f) {\n        var g = this.options.breaks,\n            m = g && g.length,\n            e,\n            b,\n            l;\n\n        if (m) {\n          for (; m--;) this.isInBreak(g[m], a) && (e = !0, b || (b = A(g[m].showPoints, !this.isXAxis)));\n\n          l = e && f ? e && !b : e;\n        }\n\n        return l;\n      }\n    });\n    C(x, \"afterInit\", function () {\n      \"function\" === typeof this.setBreaks && this.setBreaks(this.options.breaks, !1);\n    });\n    C(x, \"afterSetTickPositions\", function () {\n      if (this.isBroken) {\n        var a = this.tickPositions,\n            f = this.tickPositions.info,\n            g = [],\n            m;\n\n        for (m = 0; m < a.length; m++) this.isInAnyBreak(a[m]) || g.push(a[m]);\n\n        this.tickPositions = g;\n        this.tickPositions.info = f;\n      }\n    });\n    C(x, \"afterSetOptions\", function () {\n      this.isBroken && (this.options.ordinal = !1);\n    });\n\n    x.prototype.setBreaks = function (a, f) {\n      function g(a) {\n        var b = a,\n            f,\n            g;\n\n        for (g = 0; g < e.breakArray.length; g++) if (f = e.breakArray[g], f.to <= a) b -= f.len;else if (f.from >= a) break;else if (e.isInBreak(f, a)) {\n          b -= a - f.from;\n          break;\n        }\n\n        return b;\n      }\n\n      function n(a) {\n        var b, f;\n\n        for (f = 0; f < e.breakArray.length && !(b = e.breakArray[f], b.from >= a); f++) b.to < a ? a += b.len : e.isInBreak(b, a) && (a += b.len);\n\n        return a;\n      }\n\n      var e = this,\n          b = m(a) && !!a.length;\n      e.isDirty = e.isBroken !== b;\n      e.isBroken = b;\n      e.options.breaks = e.userOptions.breaks = a;\n      e.forceRedraw = !0;\n      b || e.val2lin !== g || (delete e.val2lin, delete e.lin2val);\n      b && (e.userOptions.ordinal = !1, e.val2lin = g, e.lin2val = n, e.setExtremes = function (a, b, e, f, g) {\n        if (this.isBroken) {\n          for (var c, h = this.options.breaks; c = z(a, h);) a = c.to;\n\n          for (; c = z(b, h);) b = c.from;\n\n          b < a && (b = a);\n        }\n\n        x.prototype.setExtremes.call(this, a, b, e, f, g);\n      }, e.setAxisTranslation = function (a) {\n        x.prototype.setAxisTranslation.call(this, a);\n        this.unitLength = null;\n\n        if (this.isBroken) {\n          a = e.options.breaks;\n          var b = [],\n              f = [],\n              g = 0,\n              h,\n              l,\n              p = e.userMin || e.min,\n              d = e.userMax || e.max,\n              k = A(e.pointRangePadding, 0),\n              u,\n              m;\n          a.forEach(function (a) {\n            l = a.repeat || Infinity;\n            e.isInBreak(a, p) && (p += a.to % l - p % l);\n            e.isInBreak(a, d) && (d -= d % l - a.from % l);\n          });\n          a.forEach(function (a) {\n            u = a.from;\n\n            for (l = a.repeat || Infinity; u - l > p;) u -= l;\n\n            for (; u < p;) u += l;\n\n            for (m = u; m < d; m += l) b.push({\n              value: m,\n              move: \"in\"\n            }), b.push({\n              value: m + (a.to - a.from),\n              move: \"out\",\n              size: a.breakSize\n            });\n          });\n          b.sort(function (a, b) {\n            return a.value === b.value ? (\"in\" === a.move ? 0 : 1) - (\"in\" === b.move ? 0 : 1) : a.value - b.value;\n          });\n          h = 0;\n          u = p;\n          b.forEach(function (a) {\n            h += \"in\" === a.move ? 1 : -1;\n            1 === h && \"in\" === a.move && (u = a.value);\n            0 === h && (f.push({\n              from: u,\n              to: a.value,\n              len: a.value - u - (a.size || 0)\n            }), g += a.value - u - (a.size || 0));\n          });\n          e.breakArray = f;\n          e.unitLength = d - p - g + k;\n          v(e, \"afterBreaks\");\n          e.staticScale ? e.transA = e.staticScale : e.unitLength && (e.transA *= (d - e.min + k) / e.unitLength);\n          k && (e.minPixelPadding = e.transA * e.minPointOffset);\n          e.min = p;\n          e.max = d;\n        }\n      });\n      A(f, !0) && this.chart.redraw();\n    };\n\n    C(y, \"afterGeneratePoints\", function () {\n      var a = this.xAxis,\n          f = this.yAxis,\n          g = this.points,\n          m,\n          e = g.length,\n          b = this.options.connectNulls,\n          l;\n      if (a && f && (a.options.breaks || f.options.breaks)) for (; e--;) m = g[e], l = null === m.y && !1 === b, l || !a.isInAnyBreak(m.x, !0) && !f.isInAnyBreak(m.y, !0) || (g.splice(e, 1), this.data[e] && this.data[e].destroyElements());\n    });\n    C(y, \"afterRender\", function () {\n      this.drawBreaks(this.xAxis, [\"x\"]);\n      this.drawBreaks(this.yAxis, A(this.pointArrayMap, [\"y\"]));\n    });\n\n    a.Series.prototype.drawBreaks = function (a, f) {\n      var g = this,\n          m = g.points,\n          e,\n          b,\n          l,\n          c;\n      a && f.forEach(function (f) {\n        e = a.breakArray || [];\n        b = a.isXAxis ? a.min : A(g.options.threshold, a.min);\n        m.forEach(function (g) {\n          c = A(g[\"stack\" + f.toUpperCase()], g[f]);\n          e.forEach(function (e) {\n            l = !1;\n            if (b < e.from && c > e.to || b > e.from && c < e.from) l = \"pointBreak\";else if (b < e.from && c > e.from && c < e.to || b > e.from && c > e.to && c < e.from) l = \"pointInBreak\";\n            l && v(a, l, {\n              point: g,\n              brk: e\n            });\n          });\n        });\n      });\n    };\n\n    a.Series.prototype.gappedPath = function () {\n      var g = this.currentDataGrouping,\n          f = g && g.gapSize,\n          g = this.options.gapSize,\n          h = this.points.slice(),\n          m = h.length - 1,\n          e = this.yAxis;\n      if (g && 0 < m) for (\"value\" !== this.options.gapUnit && (g *= this.closestPointRange), f && f > g && (g = f); m--;) h[m + 1].x - h[m].x > g && (f = (h[m].x + h[m + 1].x) / 2, h.splice(m + 1, 0, {\n        isNull: !0,\n        x: f\n      }), this.options.stacking && (f = e.stacks[this.stackKey][f] = new a.StackItem(e, e.options.stackLabels, !1, f, this.stack), f.total = 0));\n      return this.getGraphPath(h);\n    };\n  });\n  I(H, \"masters/modules/broken-axis.src.js\", [], function () {});\n  I(H, \"parts/DataGrouping.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.addEvent,\n        A = a.arrayMax,\n        E = a.arrayMin,\n        m = a.Axis,\n        g = a.defaultPlotOptions,\n        v = a.defined,\n        x = a.extend,\n        y = a.format,\n        z = a.isNumber,\n        n = a.merge,\n        f = a.pick,\n        h = a.Point,\n        r = a.Series,\n        e = a.Tooltip,\n        b = a.approximations = {\n      sum: function (a) {\n        var b = a.length,\n            d;\n        if (!b && a.hasNulls) d = null;else if (b) for (d = 0; b--;) d += a[b];\n        return d;\n      },\n      average: function (a) {\n        var d = a.length;\n        a = b.sum(a);\n        z(a) && d && (a /= d);\n        return a;\n      },\n      averages: function () {\n        var a = [];\n        [].forEach.call(arguments, function (d) {\n          a.push(b.average(d));\n        });\n        return void 0 === a[0] ? void 0 : a;\n      },\n      open: function (a) {\n        return a.length ? a[0] : a.hasNulls ? null : void 0;\n      },\n      high: function (a) {\n        return a.length ? A(a) : a.hasNulls ? null : void 0;\n      },\n      low: function (a) {\n        return a.length ? E(a) : a.hasNulls ? null : void 0;\n      },\n      close: function (a) {\n        return a.length ? a[a.length - 1] : a.hasNulls ? null : void 0;\n      },\n      ohlc: function (a, d, c, e) {\n        a = b.open(a);\n        d = b.high(d);\n        c = b.low(c);\n        e = b.close(e);\n        if (z(a) || z(d) || z(c) || z(e)) return [a, d, c, e];\n      },\n      range: function (a, d) {\n        a = b.low(a);\n        d = b.high(d);\n        if (z(a) || z(d)) return [a, d];\n        if (null === a && null === d) return null;\n      }\n    },\n        l = function (a, d, c, e) {\n      var f = this,\n          g = f.data,\n          h = f.options && f.options.data,\n          k = [],\n          l = [],\n          p = [],\n          t = a.length,\n          m,\n          u,\n          r = !!d,\n          w = [],\n          x = f.pointArrayMap,\n          y = x && x.length,\n          B = [\"x\"].concat(x || [\"y\"]),\n          D = 0,\n          F = 0,\n          G,\n          A;\n      e = \"function\" === typeof e ? e : b[e] ? b[e] : b[f.getDGApproximation && f.getDGApproximation() || \"average\"];\n      y ? x.forEach(function () {\n        w.push([]);\n      }) : w.push([]);\n      G = y || 1;\n\n      for (A = 0; A <= t && !(a[A] >= c[0]); A++);\n\n      for (A; A <= t; A++) {\n        for (; void 0 !== c[D + 1] && a[A] >= c[D + 1] || A === t;) {\n          m = c[D];\n          f.dataGroupInfo = {\n            start: f.cropStart + F,\n            length: w[0].length\n          };\n          u = e.apply(f, w);\n          f.pointClass && !v(f.dataGroupInfo.options) && (f.dataGroupInfo.options = n(f.pointClass.prototype.optionsToObject.call({\n            series: f\n          }, f.options.data[f.cropStart + F])), B.forEach(function (a) {\n            delete f.dataGroupInfo.options[a];\n          }));\n          void 0 !== u && (k.push(m), l.push(u), p.push(f.dataGroupInfo));\n          F = A;\n\n          for (m = 0; m < G; m++) w[m].length = 0, w[m].hasNulls = !1;\n\n          D += 1;\n          if (A === t) break;\n        }\n\n        if (A === t) break;\n\n        if (x) {\n          m = f.cropStart + A;\n          u = g && g[m] || f.pointClass.prototype.applyOptions.apply({\n            series: f\n          }, [h[m]]);\n          var C;\n\n          for (m = 0; m < y; m++) C = u[x[m]], z(C) ? w[m].push(C) : null === C && (w[m].hasNulls = !0);\n        } else m = r ? d[A] : null, z(m) ? w[0].push(m) : null === m && (w[0].hasNulls = !0);\n      }\n\n      return {\n        groupedXData: k,\n        groupedYData: l,\n        groupMap: p\n      };\n    },\n        c = {\n      approximations: b,\n      groupData: l\n    },\n        t = r.prototype,\n        F = t.processData,\n        w = t.generatePoints,\n        B = {\n      groupPixelWidth: 2,\n      dateTimeLabelFormats: {\n        millisecond: [\"%A, %b %e, %H:%M:%S.%L\", \"%A, %b %e, %H:%M:%S.%L\", \"-%H:%M:%S.%L\"],\n        second: [\"%A, %b %e, %H:%M:%S\", \"%A, %b %e, %H:%M:%S\", \"-%H:%M:%S\"],\n        minute: [\"%A, %b %e, %H:%M\", \"%A, %b %e, %H:%M\", \"-%H:%M\"],\n        hour: [\"%A, %b %e, %H:%M\", \"%A, %b %e, %H:%M\", \"-%H:%M\"],\n        day: [\"%A, %b %e, %Y\", \"%A, %b %e\", \"-%A, %b %e, %Y\"],\n        week: [\"Week from %A, %b %e, %Y\", \"%A, %b %e\", \"-%A, %b %e, %Y\"],\n        month: [\"%B %Y\", \"%B\", \"-%B %Y\"],\n        year: [\"%Y\", \"%Y\", \"-%Y\"]\n      }\n    },\n        p = {\n      line: {},\n      spline: {},\n      area: {},\n      areaspline: {},\n      column: {\n        groupPixelWidth: 10\n      },\n      columnrange: {\n        groupPixelWidth: 10\n      },\n      candlestick: {\n        groupPixelWidth: 10\n      },\n      ohlc: {\n        groupPixelWidth: 5\n      }\n    },\n        d = a.defaultDataGroupingUnits = [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1]], [\"week\", [1]], [\"month\", [1, 3, 6]], [\"year\", null]];\n\n    t.getDGApproximation = function () {\n      return a.seriesTypes.arearange && this instanceof a.seriesTypes.arearange ? \"range\" : a.seriesTypes.ohlc && this instanceof a.seriesTypes.ohlc ? \"ohlc\" : a.seriesTypes.column && this instanceof a.seriesTypes.column ? \"sum\" : \"average\";\n    };\n\n    t.groupData = l;\n\n    t.processData = function () {\n      var a = this.chart,\n          b = this.options.dataGrouping,\n          c = !1 !== this.allowDG && b && f(b.enabled, a.options.isStock),\n          e = this.visible || !a.options.chart.ignoreHiddenSeries,\n          g,\n          h = this.currentDataGrouping,\n          l,\n          m = !1;\n      this.forceCrop = c;\n      this.groupPixelWidth = null;\n      this.hasProcessed = !0;\n      c && !this.requireSorting && (this.requireSorting = m = !0);\n      c = !1 === F.apply(this, arguments) || !c;\n      m && (this.requireSorting = !1);\n\n      if (!c) {\n        this.destroyGroupedData();\n        var p,\n            c = b.groupAll ? this.xData : this.processedXData,\n            n = b.groupAll ? this.yData : this.processedYData,\n            r = a.plotSizeX,\n            a = this.xAxis,\n            w = a.options.ordinal,\n            x = this.groupPixelWidth = a.getGroupPixelWidth && a.getGroupPixelWidth();\n\n        if (x) {\n          this.isDirty = g = !0;\n          this.points = null;\n          m = a.getExtremes();\n          l = m.min;\n          var m = m.max,\n              w = w && a.getGroupIntervalFactor(l, m, this) || 1,\n              x = x * (m - l) / r * w,\n              r = a.getTimeTicks(a.normalizeTimeTickInterval(x, b.units || d), Math.min(l, c[0]), Math.max(m, c[c.length - 1]), a.options.startOfWeek, c, this.closestPointRange),\n              n = t.groupData.apply(this, [c, n, r, b.approximation]),\n              c = n.groupedXData,\n              w = n.groupedYData,\n              y = 0;\n\n          if (b.smoothed && c.length) {\n            p = c.length - 1;\n\n            for (c[p] = Math.min(c[p], m); p-- && 0 < p;) c[p] += x / 2;\n\n            c[0] = Math.max(c[0], l);\n          }\n\n          for (p = 1; p < r.length; p++) r.info.segmentStarts && -1 !== r.info.segmentStarts.indexOf(p) || (y = Math.max(r[p] - r[p - 1], y));\n\n          l = r.info;\n          l.gapSize = y;\n          this.closestPointRange = r.info.totalRange;\n          this.groupMap = n.groupMap;\n\n          if (v(c[0]) && c[0] < a.dataMin && e) {\n            if (!v(a.options.min) && a.min <= a.dataMin || a.min === a.dataMin) a.min = c[0];\n            a.dataMin = c[0];\n          }\n\n          b.groupAll && (b = this.cropData(c, w, a.min, a.max, 1), c = b.xData, w = b.yData);\n          this.processedXData = c;\n          this.processedYData = w;\n        } else this.groupMap = null;\n\n        this.hasGroupedData = g;\n        this.currentDataGrouping = l;\n        this.preventGraphAnimation = (h && h.totalRange) !== (l && l.totalRange);\n      }\n    };\n\n    t.destroyGroupedData = function () {\n      var a = this.groupedData;\n      (a || []).forEach(function (b, d) {\n        b && (a[d] = b.destroy ? b.destroy() : null);\n      });\n      this.groupedData = null;\n    };\n\n    t.generatePoints = function () {\n      w.apply(this);\n      this.destroyGroupedData();\n      this.groupedData = this.hasGroupedData ? this.points : null;\n    };\n\n    C(h, \"update\", function () {\n      if (this.dataGroup) return a.error(24, !1, this.series.chart), !1;\n    });\n    C(e, \"headerFormatter\", function (a) {\n      var b = this.chart.time,\n          d = a.labelConfig,\n          c = d.series,\n          e = c.tooltipOptions,\n          f = c.options.dataGrouping,\n          g = e.xDateFormat,\n          h,\n          k = c.xAxis,\n          l,\n          m = e[(a.isFooter ? \"footer\" : \"header\") + \"Format\"];\n      k && \"datetime\" === k.options.type && f && z(d.key) && (l = c.currentDataGrouping, f = f.dateTimeLabelFormats || B.dateTimeLabelFormats, l ? (e = f[l.unitName], 1 === l.count ? g = e[0] : (g = e[1], h = e[2])) : !g && f && (g = this.getXDateFormat(d, e, k)), g = b.dateFormat(g, d.key), h && (g += b.dateFormat(h, d.key + l.totalRange - 1)), c.chart.styledMode && (m = this.styledModeFormat(m)), a.text = y(m, {\n        point: x(d.point, {\n          key: g\n        }),\n        series: c\n      }, b), a.preventDefault());\n    });\n    C(r, \"destroy\", t.destroyGroupedData);\n    C(r, \"afterSetOptions\", function (a) {\n      a = a.options;\n      var b = this.type,\n          d = this.chart.options.plotOptions,\n          c = g[b].dataGrouping,\n          e = this.useCommonDataGrouping && B;\n      if (p[b] || e) c || (c = n(B, p[b])), a.dataGrouping = n(e, c, d.series && d.series.dataGrouping, d[b].dataGrouping, this.userOptions.dataGrouping);\n    });\n    C(m, \"afterSetScale\", function () {\n      this.series.forEach(function (a) {\n        a.hasProcessed = !1;\n      });\n    });\n\n    m.prototype.getGroupPixelWidth = function () {\n      var a = this.series,\n          b = a.length,\n          d,\n          c = 0,\n          e = !1,\n          g;\n\n      for (d = b; d--;) (g = a[d].options.dataGrouping) && (c = Math.max(c, f(g.groupPixelWidth, B.groupPixelWidth)));\n\n      for (d = b; d--;) (g = a[d].options.dataGrouping) && a[d].hasProcessed && (b = (a[d].processedXData || a[d].data).length, a[d].groupPixelWidth || b > this.chart.plotSizeX / c || b && g.forced) && (e = !0);\n\n      return e ? c : 0;\n    };\n\n    m.prototype.setDataGrouping = function (a, b) {\n      var d;\n      b = f(b, !0);\n      a || (a = {\n        forced: !1,\n        units: null\n      });\n      if (this instanceof m) for (d = this.series.length; d--;) this.series[d].update({\n        dataGrouping: a\n      }, !1);else this.chart.options.series.forEach(function (b) {\n        b.dataGrouping = a;\n      }, !1);\n      this.ordinalSlope = null;\n      b && this.chart.redraw();\n    };\n\n    return a.dataGrouping = c;\n  });\n  I(H, \"parts/OHLCSeries.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.Point,\n        A = a.seriesType,\n        E = a.seriesTypes;\n    A(\"ohlc\", \"column\", {\n      lineWidth: 1,\n      tooltip: {\n        pointFormat: '\\x3cspan style\\x3d\"color:{point.color}\"\\x3e\\u25cf\\x3c/span\\x3e \\x3cb\\x3e {series.name}\\x3c/b\\x3e\\x3cbr/\\x3eOpen: {point.open}\\x3cbr/\\x3eHigh: {point.high}\\x3cbr/\\x3eLow: {point.low}\\x3cbr/\\x3eClose: {point.close}\\x3cbr/\\x3e'\n      },\n      threshold: null,\n      states: {\n        hover: {\n          lineWidth: 3\n        }\n      },\n      stickyTracking: !0\n    }, {\n      directTouch: !1,\n      pointArrayMap: [\"open\", \"high\", \"low\", \"close\"],\n      toYData: function (a) {\n        return [a.open, a.high, a.low, a.close];\n      },\n      pointValKey: \"close\",\n      pointAttrToOptions: {\n        stroke: \"color\",\n        \"stroke-width\": \"lineWidth\"\n      },\n      init: function () {\n        E.column.prototype.init.apply(this, arguments);\n        this.options.stacking = !1;\n      },\n      pointAttribs: function (a, g) {\n        g = E.column.prototype.pointAttribs.call(this, a, g);\n        var m = this.options;\n        delete g.fill;\n        !a.options.color && m.upColor && a.open < a.close && (g.stroke = m.upColor);\n        return g;\n      },\n      translate: function () {\n        var a = this,\n            g = a.yAxis,\n            v = !!a.modifyValue,\n            x = [\"plotOpen\", \"plotHigh\", \"plotLow\", \"plotClose\", \"yBottom\"];\n        E.column.prototype.translate.apply(a);\n        a.points.forEach(function (m) {\n          [m.open, m.high, m.low, m.close, m.low].forEach(function (y, n) {\n            null !== y && (v && (y = a.modifyValue(y)), m[x[n]] = g.toPixels(y, !0));\n          });\n          m.tooltipPos[1] = m.plotHigh + g.pos - a.chart.plotTop;\n        });\n      },\n      drawPoints: function () {\n        var a = this,\n            g = a.chart;\n        a.points.forEach(function (m) {\n          var v,\n              y,\n              z,\n              n,\n              f = m.graphic,\n              h,\n              r = !f;\n          void 0 !== m.plotY && (f || (m.graphic = f = g.renderer.path().add(a.group)), g.styledMode || f.attr(a.pointAttribs(m, m.selected && \"select\")), y = f.strokeWidth() % 2 / 2, h = Math.round(m.plotX) - y, z = Math.round(m.shapeArgs.width / 2), n = [\"M\", h, Math.round(m.yBottom), \"L\", h, Math.round(m.plotHigh)], null !== m.open && (v = Math.round(m.plotOpen) + y, n.push(\"M\", h, v, \"L\", h - z, v)), null !== m.close && (v = Math.round(m.plotClose) + y, n.push(\"M\", h, v, \"L\", h + z, v)), f[r ? \"attr\" : \"animate\"]({\n            d: n\n          }).addClass(m.getClassName(), !0));\n        });\n      },\n      animate: null\n    }, {\n      getClassName: function () {\n        return C.prototype.getClassName.call(this) + (this.open < this.close ? \" highcharts-point-up\" : \" highcharts-point-down\");\n      }\n    });\n  });\n  I(H, \"parts/CandlestickSeries.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.defaultPlotOptions,\n        A = a.merge,\n        E = a.seriesType,\n        m = a.seriesTypes;\n    E(\"candlestick\", \"ohlc\", A(C.column, {\n      states: {\n        hover: {\n          lineWidth: 2\n        }\n      },\n      tooltip: C.ohlc.tooltip,\n      threshold: null,\n      lineColor: \"#000000\",\n      lineWidth: 1,\n      upColor: \"#ffffff\",\n      stickyTracking: !0\n    }), {\n      pointAttribs: function (a, v) {\n        var g = m.column.prototype.pointAttribs.call(this, a, v),\n            y = this.options,\n            z = a.open < a.close,\n            n = y.lineColor || this.color;\n        g[\"stroke-width\"] = y.lineWidth;\n        g.fill = a.options.color || (z ? y.upColor || this.color : this.color);\n        g.stroke = a.lineColor || (z ? y.upLineColor || n : n);\n        v && (a = y.states[v], g.fill = a.color || g.fill, g.stroke = a.lineColor || g.stroke, g[\"stroke-width\"] = a.lineWidth || g[\"stroke-width\"]);\n        return g;\n      },\n      drawPoints: function () {\n        var a = this,\n            m = a.chart,\n            x = a.yAxis.reversed;\n        a.points.forEach(function (g) {\n          var v = g.graphic,\n              n,\n              f,\n              h,\n              r,\n              e,\n              b,\n              l,\n              c = !v;\n          void 0 !== g.plotY && (v || (g.graphic = v = m.renderer.path().add(a.group)), a.chart.styledMode || v.attr(a.pointAttribs(g, g.selected && \"select\")).shadow(a.options.shadow), e = v.strokeWidth() % 2 / 2, b = Math.round(g.plotX) - e, n = g.plotOpen, f = g.plotClose, h = Math.min(n, f), n = Math.max(n, f), l = Math.round(g.shapeArgs.width / 2), f = x ? n !== g.yBottom : Math.round(h) !== Math.round(g.plotHigh), r = x ? Math.round(h) !== Math.round(g.plotHigh) : n !== g.yBottom, h = Math.round(h) + e, n = Math.round(n) + e, e = [], e.push(\"M\", b - l, n, \"L\", b - l, h, \"L\", b + l, h, \"L\", b + l, n, \"Z\", \"M\", b, h, \"L\", b, f ? Math.round(x ? g.yBottom : g.plotHigh) : h, \"M\", b, n, \"L\", b, r ? Math.round(x ? g.plotHigh : g.yBottom) : n), v[c ? \"attr\" : \"animate\"]({\n            d: e\n          }).addClass(g.getClassName(), !0));\n        });\n      }\n    });\n  });\n  I(H, \"mixins/on-series.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.defined,\n        A = a.seriesTypes,\n        E = a.stableSort;\n    return {\n      getPlotBox: function () {\n        return a.Series.prototype.getPlotBox.call(this.options.onSeries && this.chart.get(this.options.onSeries) || this);\n      },\n      translate: function () {\n        A.column.prototype.translate.apply(this);\n        var a = this,\n            g = a.options,\n            v = a.chart,\n            x = a.points,\n            y = x.length - 1,\n            z,\n            n = g.onSeries,\n            n = n && v.get(n),\n            g = g.onKey || \"y\",\n            f = n && n.options.step,\n            h = n && n.points,\n            r = h && h.length,\n            e = v.inverted,\n            b = a.xAxis,\n            l = a.yAxis,\n            c = 0,\n            t,\n            F,\n            w,\n            B;\n        if (n && n.visible && r) for (c = (n.pointXOffset || 0) + (n.barW || 0) / 2, v = n.currentDataGrouping, F = h[r - 1].x + (v ? v.totalRange : 0), E(x, function (a, b) {\n          return a.x - b.x;\n        }), g = \"plot\" + g[0].toUpperCase() + g.substr(1); r-- && x[y] && !(t = h[r], v = x[y], v.y = t.y, t.x <= v.x && void 0 !== t[g] && (v.x <= F && (v.plotY = t[g], t.x < v.x && !f && (w = h[r + 1]) && void 0 !== w[g] && (B = (v.x - t.x) / (w.x - t.x), v.plotY += B * (w[g] - t[g]), v.y += B * (w.y - t.y))), y--, r++, 0 > y)););\n        x.forEach(function (f, d) {\n          var g;\n          f.plotX += c;\n          if (void 0 === f.plotY || e) 0 <= f.plotX && f.plotX <= b.len ? e ? (f.plotY = b.translate(f.x, 0, 1, 0, 1), f.plotX = C(f.y) ? l.translate(f.y, 0, 0, 0, 1) : 0) : f.plotY = (b.opposite ? 0 : a.yAxis.len) + b.offset : f.shapeArgs = {};\n          (z = x[d - 1]) && z.plotX === f.plotX && (void 0 === z.stackIndex && (z.stackIndex = 0), g = z.stackIndex + 1);\n          f.stackIndex = g;\n        });\n        this.onSeries = n;\n      }\n    };\n  });\n  I(H, \"parts/FlagsSeries.js\", [H[\"parts/Globals.js\"], H[\"mixins/on-series.js\"]], function (a, C) {\n    function A(a) {\n      h[a + \"pin\"] = function (e, b, f, c, g) {\n        var l = g && g.anchorX;\n        g = g && g.anchorY;\n        var m;\n        \"circle\" === a && c > f && (e -= Math.round((c - f) / 2), f = c);\n        m = h[a](e, b, f, c);\n        l && g && (m.push(\"M\", \"circle\" === a ? e + f / 2 : m[1] + m[4] / 2, b > g ? b : b + c, \"L\", l, g), m = m.concat(h.circle(l - 1, g - 1, 2, 2)));\n        return m;\n      };\n    }\n\n    var E = a.addEvent,\n        m = a.merge,\n        g = a.noop,\n        v = a.defined,\n        x = a.Renderer,\n        y = a.Series,\n        z = a.seriesType,\n        n = a.TrackerMixin,\n        f = a.VMLRenderer,\n        h = a.SVGRenderer.prototype.symbols;\n    z(\"flags\", \"column\", {\n      pointRange: 0,\n      allowOverlapX: !1,\n      shape: \"flag\",\n      stackDistance: 12,\n      textAlign: \"center\",\n      tooltip: {\n        pointFormat: \"{point.text}\\x3cbr/\\x3e\"\n      },\n      threshold: null,\n      y: -30,\n      fillColor: \"#ffffff\",\n      lineWidth: 1,\n      states: {\n        hover: {\n          lineColor: \"#000000\",\n          fillColor: \"#ccd6eb\"\n        }\n      },\n      style: {\n        fontSize: \"11px\",\n        fontWeight: \"bold\"\n      }\n    }, {\n      sorted: !1,\n      noSharedTooltip: !0,\n      allowDG: !1,\n      takeOrdinalPosition: !1,\n      trackerGroups: [\"markerGroup\"],\n      forceCrop: !0,\n      init: y.prototype.init,\n      pointAttribs: function (a, e) {\n        var b = this.options,\n            f = a && a.color || this.color,\n            c = b.lineColor,\n            g = a && a.lineWidth;\n        a = a && a.fillColor || b.fillColor;\n        e && (a = b.states[e].fillColor, c = b.states[e].lineColor, g = b.states[e].lineWidth);\n        return {\n          fill: a || f,\n          stroke: c || f,\n          \"stroke-width\": g || b.lineWidth || 0\n        };\n      },\n      translate: C.translate,\n      getPlotBox: C.getPlotBox,\n      drawPoints: function () {\n        var f = this.points,\n            e = this.chart,\n            b = e.renderer,\n            g,\n            c,\n            h = e.inverted,\n            n = this.options,\n            w = n.y,\n            x,\n            p,\n            d,\n            k,\n            u,\n            y,\n            z = this.yAxis,\n            q = {},\n            A = [],\n            C;\n\n        for (p = f.length; p--;) d = f[p], y = (h ? d.plotY : d.plotX) > this.xAxis.len, g = d.plotX, k = d.stackIndex, x = d.options.shape || n.shape, c = d.plotY, void 0 !== c && (c = d.plotY + w - (void 0 !== k && k * n.stackDistance)), d.anchorX = k ? void 0 : d.plotX, u = k ? void 0 : d.plotY, C = \"flag\" !== x, k = d.graphic, void 0 !== c && 0 <= g && !y ? (k || (k = d.graphic = b.label(\"\", null, null, x, null, null, n.useHTML), e.styledMode || k.attr(this.pointAttribs(d)).css(m(n.style, d.style)), k.attr({\n          align: C ? \"center\" : \"left\",\n          width: n.width,\n          height: n.height,\n          \"text-align\": n.textAlign\n        }).addClass(\"highcharts-point\").add(this.markerGroup), d.graphic.div && (d.graphic.div.point = d), e.styledMode || k.shadow(n.shadow), k.isNew = !0), 0 < g && (g -= k.strokeWidth() % 2), x = {\n          y: c,\n          anchorY: u\n        }, n.allowOverlapX && (x.x = g, x.anchorX = d.anchorX), k.attr({\n          text: d.options.title || n.title || \"A\"\n        })[k.isNew ? \"attr\" : \"animate\"](x), n.allowOverlapX || (q[d.plotX] ? q[d.plotX].size = Math.max(q[d.plotX].size, k.width) : q[d.plotX] = {\n          align: C ? .5 : 0,\n          size: k.width,\n          target: g,\n          anchorX: g\n        }), d.tooltipPos = [g, c + z.pos - e.plotTop]) : k && (d.graphic = k.destroy());\n\n        n.allowOverlapX || (a.objectEach(q, function (a) {\n          a.plotX = a.anchorX;\n          A.push(a);\n        }), a.distribute(A, h ? z.len : this.xAxis.len, 100), f.forEach(function (a) {\n          var b = a.graphic && q[a.plotX];\n          b && (a.graphic[a.graphic.isNew ? \"attr\" : \"animate\"]({\n            x: b.pos + b.align * b.size,\n            anchorX: a.anchorX\n          }), v(b.pos) ? a.graphic.isNew = !1 : (a.graphic.attr({\n            x: -9999,\n            anchorX: -9999\n          }), a.graphic.isNew = !0));\n        }));\n        n.useHTML && a.wrap(this.markerGroup, \"on\", function (b) {\n          return a.SVGElement.prototype.on.apply(b.apply(this, [].slice.call(arguments, 1)), [].slice.call(arguments, 1));\n        });\n      },\n      drawTracker: function () {\n        var a = this.points;\n        n.drawTrackerPoint.apply(this);\n        a.forEach(function (e) {\n          var b = e.graphic;\n          b && E(b.element, \"mouseover\", function () {\n            0 < e.stackIndex && !e.raised && (e._y = b.y, b.attr({\n              y: e._y - 8\n            }), e.raised = !0);\n            a.forEach(function (a) {\n              a !== e && a.raised && a.graphic && (a.graphic.attr({\n                y: a._y\n              }), a.raised = !1);\n            });\n          });\n        });\n      },\n      animate: function (a) {\n        a ? this.setClip() : this.animate = null;\n      },\n      setClip: function () {\n        y.prototype.setClip.apply(this, arguments);\n        !1 !== this.options.clip && this.sharedClipKey && this.markerGroup.clip(this.chart[this.sharedClipKey]);\n      },\n      buildKDTree: g,\n      invertGroups: g\n    }, {\n      isValid: function () {\n        return a.isNumber(this.y) || void 0 === this.y;\n      }\n    });\n\n    h.flag = function (a, e, b, f, c) {\n      var g = c && c.anchorX || a;\n      c = c && c.anchorY || e;\n      return h.circle(g - 1, c - 1, 2, 2).concat([\"M\", g, c, \"L\", a, e + f, a, e, a + b, e, a + b, e + f, a, e + f, \"Z\"]);\n    };\n\n    A(\"circle\");\n    A(\"square\");\n    x === f && [\"flag\", \"circlepin\", \"squarepin\"].forEach(function (a) {\n      f.prototype.symbols[a] = h[a];\n    });\n  });\n  I(H, \"parts/RangeSelector.js\", [H[\"parts/Globals.js\"]], function (a) {\n    function C(a) {\n      this.init(a);\n    }\n\n    var A = a.addEvent,\n        E = a.Axis,\n        m = a.Chart,\n        g = a.css,\n        v = a.createElement,\n        x = a.defaultOptions,\n        y = a.defined,\n        z = a.destroyObjectProperties,\n        n = a.discardElement,\n        f = a.extend,\n        h = a.fireEvent,\n        r = a.isNumber,\n        e = a.merge,\n        b = a.pick,\n        l = a.pInt,\n        c = a.splat;\n    f(x, {\n      rangeSelector: {\n        verticalAlign: \"top\",\n        buttonTheme: {\n          width: 28,\n          height: 18,\n          padding: 2,\n          zIndex: 7\n        },\n        floating: !1,\n        x: 0,\n        y: 0,\n        height: void 0,\n        inputPosition: {\n          align: \"right\",\n          x: 0,\n          y: 0\n        },\n        buttonPosition: {\n          align: \"left\",\n          x: 0,\n          y: 0\n        },\n        labelStyle: {\n          color: \"#666666\"\n        }\n      }\n    });\n    x.lang = e(x.lang, {\n      rangeSelectorZoom: \"Zoom\",\n      rangeSelectorFrom: \"From\",\n      rangeSelectorTo: \"To\"\n    });\n    C.prototype = {\n      clickButton: function (a, e) {\n        var f = this.chart,\n            g = this.buttonOptions[a],\n            h = f.xAxis[0],\n            d = f.scroller && f.scroller.getUnionExtremes() || h || {},\n            k = d.dataMin,\n            l = d.dataMax,\n            m,\n            t = h && Math.round(Math.min(h.max, b(l, h.max))),\n            q = g.type,\n            n,\n            d = g._range,\n            v,\n            x,\n            y,\n            z = g.dataGrouping;\n\n        if (null !== k && null !== l) {\n          f.fixedRange = d;\n          z && (this.forcedDataGrouping = !0, E.prototype.setDataGrouping.call(h || {\n            chart: this.chart\n          }, z, !1), this.frozenStates = g.preserveDataGrouping);\n          if (\"month\" === q || \"year\" === q) h ? (q = {\n            range: g,\n            max: t,\n            chart: f,\n            dataMin: k,\n            dataMax: l\n          }, m = h.minFromRange.call(q), r(q.newMax) && (t = q.newMax)) : d = g;else if (d) m = Math.max(t - d, k), t = Math.min(m + d, l);else if (\"ytd\" === q) {\n            if (h) void 0 === l && (k = Number.MAX_VALUE, l = Number.MIN_VALUE, f.series.forEach(function (a) {\n              a = a.xData;\n              k = Math.min(a[0], k);\n              l = Math.max(a[a.length - 1], l);\n            }), e = !1), t = this.getYTDExtremes(l, k, f.time.useUTC), m = v = t.min, t = t.max;else {\n              this.deferredYTDClick = a;\n              return;\n            }\n          } else \"all\" === q && h && (m = k, t = l);\n          m += g._offsetMin;\n          t += g._offsetMax;\n          this.setSelected(a);\n          h ? h.setExtremes(m, t, b(e, 1), null, {\n            trigger: \"rangeSelectorButton\",\n            rangeSelectorButton: g\n          }) : (n = c(f.options.xAxis)[0], y = n.range, n.range = d, x = n.min, n.min = v, A(f, \"load\", function () {\n            n.range = y;\n            n.min = x;\n          }));\n        }\n      },\n      setSelected: function (a) {\n        this.selected = this.options.selected = a;\n      },\n      defaultButtons: [{\n        type: \"month\",\n        count: 1,\n        text: \"1m\"\n      }, {\n        type: \"month\",\n        count: 3,\n        text: \"3m\"\n      }, {\n        type: \"month\",\n        count: 6,\n        text: \"6m\"\n      }, {\n        type: \"ytd\",\n        text: \"YTD\"\n      }, {\n        type: \"year\",\n        count: 1,\n        text: \"1y\"\n      }, {\n        type: \"all\",\n        text: \"All\"\n      }],\n      init: function (a) {\n        var b = this,\n            c = a.options.rangeSelector,\n            e = c.buttons || [].concat(b.defaultButtons),\n            f = c.selected,\n            d = function () {\n          var a = b.minInput,\n              d = b.maxInput;\n          a && a.blur && h(a, \"blur\");\n          d && d.blur && h(d, \"blur\");\n        };\n\n        b.chart = a;\n        b.options = c;\n        b.buttons = [];\n        b.buttonOptions = e;\n        this.unMouseDown = A(a.container, \"mousedown\", d);\n        this.unResize = A(a, \"resize\", d);\n        e.forEach(b.computeButtonRange);\n        void 0 !== f && e[f] && this.clickButton(f, !1);\n        A(a, \"load\", function () {\n          a.xAxis && a.xAxis[0] && A(a.xAxis[0], \"setExtremes\", function (d) {\n            this.max - this.min !== a.fixedRange && \"rangeSelectorButton\" !== d.trigger && \"updatedData\" !== d.trigger && b.forcedDataGrouping && !b.frozenStates && this.setDataGrouping(!1, !1);\n          });\n        });\n      },\n      updateButtonStates: function () {\n        var a = this,\n            b = this.chart,\n            c = b.xAxis[0],\n            e = Math.round(c.max - c.min),\n            f = !c.hasVisibleSeries,\n            d = b.scroller && b.scroller.getUnionExtremes() || c,\n            g = d.dataMin,\n            h = d.dataMax,\n            b = a.getYTDExtremes(h, g, b.time.useUTC),\n            l = b.min,\n            m = b.max,\n            q = a.selected,\n            n = r(q),\n            v = a.options.allButtonsEnabled,\n            x = a.buttons;\n        a.buttonOptions.forEach(function (b, d) {\n          var k = b._range,\n              p = b.type,\n              t = b.count || 1,\n              u = x[d],\n              r = 0,\n              w = b._offsetMax - b._offsetMin;\n          b = d === q;\n          var y = k > h - g,\n              z = k < c.minRange,\n              B = !1,\n              A = !1,\n              k = k === e;\n          (\"month\" === p || \"year\" === p) && e + 36E5 >= 864E5 * {\n            month: 28,\n            year: 365\n          }[p] * t - w && e - 36E5 <= 864E5 * {\n            month: 31,\n            year: 366\n          }[p] * t + w ? k = !0 : \"ytd\" === p ? (k = m - l + w === e, B = !b) : \"all\" === p && (k = c.max - c.min >= h - g, A = !b && n && k);\n          p = !v && (y || z || A || f);\n          t = b && k || k && !n && !B || b && a.frozenStates;\n          p ? r = 3 : t && (n = !0, r = 2);\n          u.state !== r && (u.setState(r), 0 === r && q === d && a.setSelected(null));\n        });\n      },\n      computeButtonRange: function (a) {\n        var c = a.type,\n            e = a.count || 1,\n            f = {\n          millisecond: 1,\n          second: 1E3,\n          minute: 6E4,\n          hour: 36E5,\n          day: 864E5,\n          week: 6048E5\n        };\n        if (f[c]) a._range = f[c] * e;else if (\"month\" === c || \"year\" === c) a._range = 864E5 * {\n          month: 30,\n          year: 365\n        }[c] * e;\n        a._offsetMin = b(a.offsetMin, 0);\n        a._offsetMax = b(a.offsetMax, 0);\n        a._range += a._offsetMax - a._offsetMin;\n      },\n      setInputValue: function (a, b) {\n        var c = this.chart.options.rangeSelector,\n            e = this.chart.time,\n            f = this[a + \"Input\"];\n        y(b) && (f.previousValue = f.HCTime, f.HCTime = b);\n        f.value = e.dateFormat(c.inputEditDateFormat || \"%Y-%m-%d\", f.HCTime);\n        this[a + \"DateBox\"].attr({\n          text: e.dateFormat(c.inputDateFormat || \"%b %e, %Y\", f.HCTime)\n        });\n      },\n      showInput: function (a) {\n        var b = this.inputGroup,\n            c = this[a + \"DateBox\"];\n        g(this[a + \"Input\"], {\n          left: b.translateX + c.x + \"px\",\n          top: b.translateY + \"px\",\n          width: c.width - 2 + \"px\",\n          height: c.height - 2 + \"px\",\n          border: \"2px solid silver\"\n        });\n      },\n      hideInput: function (a) {\n        g(this[a + \"Input\"], {\n          border: 0,\n          width: \"1px\",\n          height: \"1px\"\n        });\n        this.setInputValue(a);\n      },\n      drawInput: function (b) {\n        function c() {\n          var a = y.value,\n              b = (k.inputDateParser || Date.parse)(a),\n              d = m.xAxis[0],\n              c = m.scroller && m.scroller.xAxis ? m.scroller.xAxis : d,\n              e = c.dataMin,\n              c = c.dataMax;\n          b !== y.previousValue && (y.previousValue = b, r(b) || (b = a.split(\"-\"), b = Date.UTC(l(b[0]), l(b[1]) - 1, l(b[2]))), r(b) && (m.time.useUTC || (b += 6E4 * new Date().getTimezoneOffset()), t ? b > h.maxInput.HCTime ? b = void 0 : b < e && (b = e) : b < h.minInput.HCTime ? b = void 0 : b > c && (b = c), void 0 !== b && d.setExtremes(t ? b : d.min, t ? d.max : b, void 0, void 0, {\n            trigger: \"rangeSelectorInput\"\n          })));\n        }\n\n        var h = this,\n            m = h.chart,\n            p = m.renderer.style || {},\n            d = m.renderer,\n            k = m.options.rangeSelector,\n            n = h.div,\n            t = \"min\" === b,\n            y,\n            q,\n            z = this.inputGroup;\n        this[b + \"Label\"] = q = d.label(x.lang[t ? \"rangeSelectorFrom\" : \"rangeSelectorTo\"], this.inputGroup.offset).addClass(\"highcharts-range-label\").attr({\n          padding: 2\n        }).add(z);\n        z.offset += q.width + 5;\n        this[b + \"DateBox\"] = d = d.label(\"\", z.offset).addClass(\"highcharts-range-input\").attr({\n          padding: 2,\n          width: k.inputBoxWidth || 90,\n          height: k.inputBoxHeight || 17,\n          \"text-align\": \"center\"\n        }).on(\"click\", function () {\n          h.showInput(b);\n          h[b + \"Input\"].focus();\n        });\n        m.styledMode || d.attr({\n          stroke: k.inputBoxBorderColor || \"#cccccc\",\n          \"stroke-width\": 1\n        });\n        d.add(z);\n        z.offset += d.width + (t ? 10 : 0);\n        this[b + \"Input\"] = y = v(\"input\", {\n          name: b,\n          className: \"highcharts-range-selector\",\n          type: \"text\"\n        }, {\n          top: m.plotTop + \"px\"\n        }, n);\n        m.styledMode || (q.css(e(p, k.labelStyle)), d.css(e({\n          color: \"#333333\"\n        }, p, k.inputStyle)), g(y, f({\n          position: \"absolute\",\n          border: 0,\n          width: \"1px\",\n          height: \"1px\",\n          padding: 0,\n          textAlign: \"center\",\n          fontSize: p.fontSize,\n          fontFamily: p.fontFamily,\n          top: \"-9999em\"\n        }, k.inputStyle)));\n\n        y.onfocus = function () {\n          h.showInput(b);\n        };\n\n        y.onblur = function () {\n          y === a.doc.activeElement && c();\n          h.hideInput(b);\n          y.blur();\n        };\n\n        y.onchange = c;\n\n        y.onkeypress = function (a) {\n          13 === a.keyCode && c();\n        };\n      },\n      getPosition: function () {\n        var a = this.chart,\n            b = a.options.rangeSelector,\n            a = \"top\" === b.verticalAlign ? a.plotTop - a.axisOffset[0] : 0;\n        return {\n          buttonTop: a + b.buttonPosition.y,\n          inputTop: a + b.inputPosition.y - 10\n        };\n      },\n      getYTDExtremes: function (a, b, c) {\n        var e = this.chart.time,\n            f = new e.Date(a),\n            d = e.get(\"FullYear\", f);\n        c = c ? e.Date.UTC(d, 0, 1) : +new e.Date(d, 0, 1);\n        b = Math.max(b || 0, c);\n        f = f.getTime();\n        return {\n          max: Math.min(a || f, f),\n          min: b\n        };\n      },\n      render: function (a, c) {\n        var e = this,\n            f = e.chart,\n            g = f.renderer,\n            d = f.container,\n            h = f.options,\n            l = h.exporting && !1 !== h.exporting.enabled && h.navigation && h.navigation.buttonOptions,\n            m = x.lang,\n            n = e.div,\n            q = h.rangeSelector,\n            t = b(h.chart.style && h.chart.style.zIndex, 0) + 1,\n            h = q.floating,\n            r = e.buttons,\n            n = e.inputGroup,\n            y = q.buttonTheme,\n            z = q.buttonPosition,\n            A = q.inputPosition,\n            C = q.inputEnabled,\n            F = y && y.states,\n            E = f.plotLeft,\n            H,\n            I = e.buttonGroup,\n            S;\n        S = e.rendered;\n        var W = e.options.verticalAlign,\n            Q = f.legend,\n            ca = Q && Q.options,\n            U = z.y,\n            T = A.y,\n            X = S || !1,\n            Y = X ? \"animate\" : \"attr\",\n            V = 0,\n            aa = 0,\n            Z;\n\n        if (!1 !== q.enabled) {\n          S || (e.group = S = g.g(\"range-selector-group\").attr({\n            zIndex: 7\n          }).add(), e.buttonGroup = I = g.g(\"range-selector-buttons\").add(S), e.zoomText = g.text(m.rangeSelectorZoom, 0, 15).add(I), f.styledMode || (e.zoomText.css(q.labelStyle), y[\"stroke-width\"] = b(y[\"stroke-width\"], 0)), e.buttonOptions.forEach(function (a, b) {\n            r[b] = g.button(a.text, 0, 0, function (d) {\n              var c = a.events && a.events.click,\n                  f;\n              c && (f = c.call(a, d));\n              !1 !== f && e.clickButton(b);\n              e.isActive = !0;\n            }, y, F && F.hover, F && F.select, F && F.disabled).attr({\n              \"text-align\": \"center\"\n            }).add(I);\n          }), !1 !== C && (e.div = n = v(\"div\", null, {\n            position: \"relative\",\n            height: 0,\n            zIndex: t\n          }), d.parentNode.insertBefore(n, d), e.inputGroup = n = g.g(\"input-group\").add(S), n.offset = 0, e.drawInput(\"min\"), e.drawInput(\"max\")));\n          e.zoomText[Y]({\n            x: b(E + z.x, E)\n          });\n          H = b(E + z.x, E) + e.zoomText.getBBox().width + 5;\n          e.buttonOptions.forEach(function (a, d) {\n            r[d][Y]({\n              x: H\n            });\n            H += r[d].width + b(q.buttonSpacing, 5);\n          });\n          E = f.plotLeft - f.spacing[3];\n          e.updateButtonStates();\n          l && this.titleCollision(f) && \"top\" === W && \"right\" === z.align && z.y + I.getBBox().height - 12 < (l.y || 0) + l.height && (V = -40);\n          \"left\" === z.align ? Z = z.x - f.spacing[3] : \"right\" === z.align && (Z = z.x + V - f.spacing[1]);\n          I.align({\n            y: z.y,\n            width: I.getBBox().width,\n            align: z.align,\n            x: Z\n          }, !0, f.spacingBox);\n          e.group.placed = X;\n          e.buttonGroup.placed = X;\n          !1 !== C && (V = l && this.titleCollision(f) && \"top\" === W && \"right\" === A.align && A.y - n.getBBox().height - 12 < (l.y || 0) + l.height + f.spacing[0] ? -40 : 0, \"left\" === A.align ? Z = E : \"right\" === A.align && (Z = -Math.max(f.axisOffset[1], -V)), n.align({\n            y: A.y,\n            width: n.getBBox().width,\n            align: A.align,\n            x: A.x + Z - 2\n          }, !0, f.spacingBox), d = n.alignAttr.translateX + n.alignOptions.x - V + n.getBBox().x + 2, l = n.alignOptions.width, m = I.alignAttr.translateX + I.getBBox().x, Z = I.getBBox().width + 20, (A.align === z.align || m + Z > d && d + l > m && U < T + n.getBBox().height) && n.attr({\n            translateX: n.alignAttr.translateX + (f.axisOffset[1] >= -V ? 0 : -V),\n            translateY: n.alignAttr.translateY + I.getBBox().height + 10\n          }), e.setInputValue(\"min\", a), e.setInputValue(\"max\", c), e.inputGroup.placed = X);\n          e.group.align({\n            verticalAlign: W\n          }, !0, f.spacingBox);\n          a = e.group.getBBox().height + 20;\n          c = e.group.alignAttr.translateY;\n          \"bottom\" === W && (Q = ca && \"bottom\" === ca.verticalAlign && ca.enabled && !ca.floating ? Q.legendHeight + b(ca.margin, 10) : 0, a = a + Q - 20, aa = c - a - (h ? 0 : q.y) - 10);\n          if (\"top\" === W) h && (aa = 0), f.titleOffset && (aa = f.titleOffset + f.options.title.margin), aa += f.margin[0] - f.spacing[0] || 0;else if (\"middle\" === W) if (T === U) aa = 0 > T ? c + void 0 : c;else if (T || U) aa = 0 > T || 0 > U ? aa - Math.min(T, U) : c - a + NaN;\n          e.group.translate(q.x, q.y + Math.floor(aa));\n          !1 !== C && (e.minInput.style.marginTop = e.group.translateY + \"px\", e.maxInput.style.marginTop = e.group.translateY + \"px\");\n          e.rendered = !0;\n        }\n      },\n      getHeight: function () {\n        var a = this.options,\n            b = this.group,\n            c = a.y,\n            e = a.buttonPosition.y,\n            f = a.inputPosition.y;\n        if (a.height) return a.height;\n        a = b ? b.getBBox(!0).height + 13 + c : 0;\n        b = Math.min(f, e);\n        if (0 > f && 0 > e || 0 < f && 0 < e) a += Math.abs(b);\n        return a;\n      },\n      titleCollision: function (a) {\n        return !(a.options.title.text || a.options.subtitle.text);\n      },\n      update: function (a) {\n        var b = this.chart;\n        e(!0, b.options.rangeSelector, a);\n        this.destroy();\n        this.init(b);\n        b.rangeSelector.render();\n      },\n      destroy: function () {\n        var b = this,\n            c = b.minInput,\n            e = b.maxInput;\n        b.unMouseDown();\n        b.unResize();\n        z(b.buttons);\n        c && (c.onfocus = c.onblur = c.onchange = null);\n        e && (e.onfocus = e.onblur = e.onchange = null);\n        a.objectEach(b, function (a, c) {\n          a && \"chart\" !== c && (a.destroy ? a.destroy() : a.nodeType && n(this[c]));\n          a !== C.prototype[c] && (b[c] = null);\n        }, this);\n      }\n    };\n\n    E.prototype.minFromRange = function () {\n      var a = this.range,\n          c = {\n        month: \"Month\",\n        year: \"FullYear\"\n      }[a.type],\n          e,\n          f = this.max,\n          g,\n          d,\n          h = this.chart.time,\n          l = function (a, b) {\n        var d = new h.Date(a),\n            e = h.get(c, d);\n        h.set(c, d, e + b);\n        e === h.get(c, d) && h.set(\"Date\", d, 0);\n        return d.getTime() - a;\n      };\n\n      r(a) ? (e = f - a, d = a) : (e = f + l(f, -a.count), this.chart && (this.chart.fixedRange = f - e));\n      g = b(this.dataMin, Number.MIN_VALUE);\n      r(e) || (e = g);\n      e <= g && (e = g, void 0 === d && (d = l(e, a.count)), this.newMax = Math.min(e + d, this.dataMax));\n      r(f) || (e = void 0);\n      return e;\n    };\n\n    a.RangeSelector || (A(m, \"afterGetContainer\", function () {\n      this.options.rangeSelector.enabled && (this.rangeSelector = new C(this));\n    }), A(m, \"beforeRender\", function () {\n      var a = this.axes,\n          b = this.rangeSelector;\n      b && (r(b.deferredYTDClick) && (b.clickButton(b.deferredYTDClick), delete b.deferredYTDClick), a.forEach(function (a) {\n        a.updateNames();\n        a.setScale();\n      }), this.getAxisMargins(), b.render(), a = b.options.verticalAlign, b.options.floating || (\"bottom\" === a ? this.extraBottomMargin = !0 : \"middle\" !== a && (this.extraTopMargin = !0)));\n    }), A(m, \"update\", function (a) {\n      var b = a.options.rangeSelector;\n      a = this.rangeSelector;\n      var c = this.extraBottomMargin,\n          e = this.extraTopMargin;\n      b && b.enabled && !y(a) && (this.options.rangeSelector.enabled = !0, this.rangeSelector = new C(this));\n      this.extraTopMargin = this.extraBottomMargin = !1;\n      a && (a.render(), b = b && b.verticalAlign || a.options && a.options.verticalAlign, a.options.floating || (\"bottom\" === b ? this.extraBottomMargin = !0 : \"middle\" !== b && (this.extraTopMargin = !0)), this.extraBottomMargin !== c || this.extraTopMargin !== e) && (this.isDirtyBox = !0);\n    }), A(m, \"render\", function () {\n      var a = this.rangeSelector;\n      a && !a.options.floating && (a.render(), a = a.options.verticalAlign, \"bottom\" === a ? this.extraBottomMargin = !0 : \"middle\" !== a && (this.extraTopMargin = !0));\n    }), A(m, \"getMargins\", function () {\n      var a = this.rangeSelector;\n      a && (a = a.getHeight(), this.extraTopMargin && (this.plotTop += a), this.extraBottomMargin && (this.marginBottom += a));\n    }), m.prototype.callbacks.push(function (a) {\n      function b() {\n        c = a.xAxis[0].getExtremes();\n        r(c.min) && e.render(c.min, c.max);\n      }\n\n      var c,\n          e = a.rangeSelector,\n          f,\n          d;\n      e && (d = A(a.xAxis[0], \"afterSetExtremes\", function (a) {\n        e.render(a.min, a.max);\n      }), f = A(a, \"redraw\", b), b());\n      A(a, \"destroy\", function () {\n        e && (f(), d());\n      });\n    }), a.RangeSelector = C);\n  });\n  I(H, \"parts/StockChart.js\", [H[\"parts/Globals.js\"]], function (a) {\n    var C = a.addEvent,\n        A = a.arrayMax,\n        E = a.arrayMin,\n        m = a.Axis,\n        g = a.Chart,\n        v = a.defined,\n        x = a.extend,\n        y = a.format,\n        z = a.isNumber,\n        n = a.isString,\n        f = a.merge,\n        h = a.pick,\n        r = a.Point,\n        e = a.Renderer,\n        b = a.Series,\n        l = a.splat,\n        c = a.SVGRenderer,\n        t = a.VMLRenderer,\n        F = b.prototype,\n        w = F.init,\n        B = F.processData,\n        p = r.prototype.tooltipFormatter;\n\n    a.StockChart = a.stockChart = function (b, c, e) {\n      var d = n(b) || b.nodeName,\n          k = arguments[d ? 1 : 0],\n          m = k,\n          p = k.series,\n          r = a.getOptions(),\n          u,\n          t = h(k.navigator && k.navigator.enabled, r.navigator.enabled, !0),\n          v = t ? {\n        startOnTick: !1,\n        endOnTick: !1\n      } : null;\n      k.xAxis = l(k.xAxis || {}).map(function (a, b) {\n        return f({\n          minPadding: 0,\n          maxPadding: 0,\n          overscroll: 0,\n          ordinal: !0,\n          title: {\n            text: null\n          },\n          labels: {\n            overflow: \"justify\"\n          },\n          showLastLabel: !0\n        }, r.xAxis, r.xAxis && r.xAxis[b], a, {\n          type: \"datetime\",\n          categories: null\n        }, v);\n      });\n      k.yAxis = l(k.yAxis || {}).map(function (a, b) {\n        u = h(a.opposite, !0);\n        return f({\n          labels: {\n            y: -2\n          },\n          opposite: u,\n          showLastLabel: !(!a.categories && \"category\" !== a.type),\n          title: {\n            text: null\n          }\n        }, r.yAxis, r.yAxis && r.yAxis[b], a);\n      });\n      k.series = null;\n      k = f({\n        chart: {\n          panning: !0,\n          pinchType: \"x\"\n        },\n        navigator: {\n          enabled: t\n        },\n        scrollbar: {\n          enabled: h(r.scrollbar.enabled, !0)\n        },\n        rangeSelector: {\n          enabled: h(r.rangeSelector.enabled, !0)\n        },\n        title: {\n          text: null\n        },\n        tooltip: {\n          split: h(r.tooltip.split, !0),\n          crosshairs: !0\n        },\n        legend: {\n          enabled: !1\n        }\n      }, k, {\n        isStock: !0\n      });\n      k.series = m.series = p;\n      return d ? new g(b, k, e) : new g(k, c);\n    };\n\n    C(b, \"setOptions\", function (b) {\n      function c(b) {\n        return a.seriesTypes[b] && d instanceof a.seriesTypes[b];\n      }\n\n      var d = this,\n          e;\n      this.chart.options.isStock && (c(\"column\") || c(\"columnrange\") ? e = {\n        borderWidth: 0,\n        shadow: !1\n      } : !c(\"line\") || c(\"scatter\") || c(\"sma\") || (e = {\n        marker: {\n          enabled: !1,\n          radius: 2\n        }\n      }), e && (b.plotOptions[this.type] = f(b.plotOptions[this.type], e)));\n    });\n    C(m, \"autoLabelAlign\", function (a) {\n      var b = this.chart,\n          c = this.options,\n          b = b._labelPanes = b._labelPanes || {},\n          d = this.options.labels;\n      this.chart.options.isStock && \"yAxis\" === this.coll && (c = c.top + \",\" + c.height, !b[c] && d.enabled && (15 === d.x && (d.x = 0), void 0 === d.align && (d.align = \"right\"), b[c] = this, a.align = \"right\", a.preventDefault()));\n    });\n    C(m, \"destroy\", function () {\n      var a = this.chart,\n          b = this.options && this.options.top + \",\" + this.options.height;\n      b && a._labelPanes && a._labelPanes[b] === this && delete a._labelPanes[b];\n    });\n    C(m, \"getPlotLinePath\", function (b) {\n      function c(a) {\n        var b = \"xAxis\" === a ? \"yAxis\" : \"xAxis\";\n        a = d.options[b];\n        return z(a) ? [f[b][a]] : n(a) ? [f.get(a)] : e.map(function (a) {\n          return a[b];\n        });\n      }\n\n      var d = this,\n          e = this.isLinked && !this.series ? this.linkedParent.series : this.series,\n          f = d.chart,\n          g = f.renderer,\n          l = d.left,\n          m = d.top,\n          p,\n          r,\n          t,\n          w,\n          x = [],\n          y = [],\n          A,\n          B,\n          C = b.translatedValue,\n          E = b.value,\n          F = b.force,\n          H;\n      if (f.options.isStock && !1 !== b.acrossPanes && \"xAxis\" === d.coll || \"yAxis\" === d.coll) b.preventDefault(), y = c(d.coll), A = d.isXAxis ? f.yAxis : f.xAxis, A.forEach(function (a) {\n        if (v(a.options.id) ? -1 === a.options.id.indexOf(\"navigator\") : 1) {\n          var b = a.isXAxis ? \"yAxis\" : \"xAxis\",\n              b = v(a.options[b]) ? f[b][a.options[b]] : f[b][0];\n          d === b && y.push(a);\n        }\n      }), B = y.length ? [] : [d.isXAxis ? f.yAxis[0] : f.xAxis[0]], y.forEach(function (b) {\n        -1 !== B.indexOf(b) || a.find(B, function (a) {\n          return a.pos === b.pos && a.len === b.len;\n        }) || B.push(b);\n      }), H = h(C, d.translate(E, null, null, b.old)), z(H) && (d.horiz ? B.forEach(function (a) {\n        var b;\n        r = a.pos;\n        w = r + a.len;\n        p = t = Math.round(H + d.transB);\n        \"pass\" !== F && (p < l || p > l + d.width) && (F ? p = t = Math.min(Math.max(l, p), l + d.width) : b = !0);\n        b || x.push(\"M\", p, r, \"L\", t, w);\n      }) : B.forEach(function (a) {\n        var b;\n        p = a.pos;\n        t = p + a.len;\n        r = w = Math.round(m + d.height - H);\n        \"pass\" !== F && (r < m || r > m + d.height) && (F ? r = w = Math.min(Math.max(m, r), d.top + d.height) : b = !0);\n        b || x.push(\"M\", p, r, \"L\", t, w);\n      })), b.path = 0 < x.length ? g.crispPolyLine(x, b.lineWidth || 1) : null;\n    });\n\n    c.prototype.crispPolyLine = function (a, b) {\n      var c;\n\n      for (c = 0; c < a.length; c += 6) a[c + 1] === a[c + 4] && (a[c + 1] = a[c + 4] = Math.round(a[c + 1]) - b % 2 / 2), a[c + 2] === a[c + 5] && (a[c + 2] = a[c + 5] = Math.round(a[c + 2]) + b % 2 / 2);\n\n      return a;\n    };\n\n    e === t && (t.prototype.crispPolyLine = c.prototype.crispPolyLine);\n    C(m, \"afterHideCrosshair\", function () {\n      this.crossLabel && (this.crossLabel = this.crossLabel.hide());\n    });\n    C(m, \"afterDrawCrosshair\", function (a) {\n      var b, c;\n\n      if (v(this.crosshair.label) && this.crosshair.label.enabled && this.cross) {\n        var d = this.chart,\n            e = this.options.crosshair.label,\n            f = this.horiz;\n        b = this.opposite;\n        c = this.left;\n        var g = this.top,\n            l = this.crossLabel,\n            m = e.format,\n            n = \"\",\n            p = \"inside\" === this.options.tickPosition,\n            r = !1 !== this.crosshair.snap,\n            t = 0,\n            w = a.e || this.cross && this.cross.e,\n            z = a.point;\n        a = this.lin2log;\n        var A, B;\n        this.isLog ? (A = a(this.min), B = a(this.max)) : (A = this.min, B = this.max);\n        a = f ? \"center\" : b ? \"right\" === this.labelAlign ? \"right\" : \"left\" : \"left\" === this.labelAlign ? \"left\" : \"center\";\n        l || (l = this.crossLabel = d.renderer.label(null, null, null, e.shape || \"callout\").addClass(\"highcharts-crosshair-label\" + (this.series[0] && \" highcharts-color-\" + this.series[0].colorIndex)).attr({\n          align: e.align || a,\n          padding: h(e.padding, 8),\n          r: h(e.borderRadius, 3),\n          zIndex: 2\n        }).add(this.labelGroup), d.styledMode || l.attr({\n          fill: e.backgroundColor || this.series[0] && this.series[0].color || \"#666666\",\n          stroke: e.borderColor || \"\",\n          \"stroke-width\": e.borderWidth || 0\n        }).css(x({\n          color: \"#ffffff\",\n          fontWeight: \"normal\",\n          fontSize: \"11px\",\n          textAlign: \"center\"\n        }, e.style)));\n        f ? (a = r ? z.plotX + c : w.chartX, g += b ? 0 : this.height) : (a = b ? this.width + c : 0, g = r ? z.plotY + g : w.chartY);\n        m || e.formatter || (this.isDatetimeAxis && (n = \"%b %d, %Y\"), m = \"{value\" + (n ? \":\" + n : \"\") + \"}\");\n        n = r ? z[this.isXAxis ? \"x\" : \"y\"] : this.toValue(f ? w.chartX : w.chartY);\n        l.attr({\n          text: m ? y(m, {\n            value: n\n          }, d.time) : e.formatter.call(this, n),\n          x: a,\n          y: g,\n          visibility: n < A || n > B ? \"hidden\" : \"visible\"\n        });\n        e = l.getBBox();\n\n        if (f) {\n          if (p && !b || !p && b) g = l.y - e.height;\n        } else g = l.y - e.height / 2;\n\n        f ? (b = c - e.x, c = c + this.width - e.x) : (b = \"left\" === this.labelAlign ? c : 0, c = \"right\" === this.labelAlign ? c + this.width : d.chartWidth);\n        l.translateX < b && (t = b - l.translateX);\n        l.translateX + e.width >= c && (t = -(l.translateX + e.width - c));\n        l.attr({\n          x: a + t,\n          y: g,\n          anchorX: f ? a : this.opposite ? 0 : d.chartWidth,\n          anchorY: f ? this.opposite ? d.chartHeight : 0 : g + e.height / 2\n        });\n      }\n    });\n\n    F.init = function () {\n      w.apply(this, arguments);\n      this.setCompare(this.options.compare);\n    };\n\n    F.setCompare = function (a) {\n      this.modifyValue = \"value\" === a || \"percent\" === a ? function (b, c) {\n        var d = this.compareValue;\n        if (void 0 !== b && void 0 !== d) return b = \"value\" === a ? b - d : b / d * 100 - (100 === this.options.compareBase ? 0 : 100), c && (c.change = b), b;\n      } : null;\n      this.userOptions.compare = a;\n      this.chart.hasRendered && (this.isDirty = !0);\n    };\n\n    F.processData = function () {\n      var a,\n          b = -1,\n          c,\n          e,\n          f = !0 === this.options.compareStart ? 0 : 1,\n          g,\n          h;\n      B.apply(this, arguments);\n      if (this.xAxis && this.processedYData) for (c = this.processedXData, e = this.processedYData, g = e.length, this.pointArrayMap && (b = this.pointArrayMap.indexOf(this.options.pointValKey || this.pointValKey || \"y\")), a = 0; a < g - f; a++) if (h = e[a] && -1 < b ? e[a][b] : e[a], z(h) && c[a + f] >= this.xAxis.min && 0 !== h) {\n        this.compareValue = h;\n        break;\n      }\n    };\n\n    C(b, \"afterGetExtremes\", function () {\n      if (this.modifyValue) {\n        var a = [this.modifyValue(this.dataMin), this.modifyValue(this.dataMax)];\n        this.dataMin = E(a);\n        this.dataMax = A(a);\n      }\n    });\n\n    m.prototype.setCompare = function (a, b) {\n      this.isXAxis || (this.series.forEach(function (b) {\n        b.setCompare(a);\n      }), h(b, !0) && this.chart.redraw());\n    };\n\n    r.prototype.tooltipFormatter = function (b) {\n      b = b.replace(\"{point.change}\", (0 < this.change ? \"+\" : \"\") + a.numberFormat(this.change, h(this.series.tooltipOptions.changeDecimals, 2)));\n      return p.apply(this, [b]);\n    };\n\n    C(b, \"render\", function () {\n      var a;\n      this.chart.is3d && this.chart.is3d() || this.chart.polar || !this.xAxis || this.xAxis.isRadial || (a = this.yAxis.len - (this.xAxis.axisLine ? Math.floor(this.xAxis.axisLine.strokeWidth() / 2) : 0), !this.clipBox && this.animate ? (this.clipBox = f(this.chart.clipBox), this.clipBox.width = this.xAxis.len, this.clipBox.height = a) : this.chart[this.sharedClipKey] && (this.chart[this.sharedClipKey].animate({\n        width: this.xAxis.len,\n        height: a\n      }), this.chart[this.sharedClipKey + \"m\"] && this.chart[this.sharedClipKey + \"m\"].animate({\n        width: this.xAxis.len\n      })));\n    });\n    C(g, \"update\", function (a) {\n      a = a.options;\n      \"scrollbar\" in a && this.navigator && (f(!0, this.options.scrollbar, a.scrollbar), this.navigator.update({}, !1), delete a.scrollbar);\n    });\n  });\n  I(H, \"masters/modules/stock.src.js\", [], function () {});\n  I(H, \"masters/highstock.src.js\", [H[\"masters/highcharts.src.js\"]], function (a) {\n    return a;\n  });\n  H[\"masters/highstock.src.js\"]._modules = H;\n  return H[\"masters/highstock.src.js\"];\n});","map":null,"metadata":{},"sourceType":"script"}